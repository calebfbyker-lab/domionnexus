import hashlib
import json
import os
from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives import hmac, hashes

# Updated corrected divine names including Khempera spelled correctly
DIVINE_NAMES = [
    "YHWH", "Elohim", "Elyon", "Sotolios", "Nu", "Ra", "Khempera", "Temu"
]

ANCESTOR_LINEAGES = [
    "Caleb", "Fedor", "Byker", "Konev"
]

EMOJI_LEXICON = [
    "â˜¸ï¸", "âœ¡ï¸", "ğŸ”¯", "âš›ï¸", "âš§ï¸", "â™‚ï¸", "â™€ï¸", "â™¾ï¸",
    "ğŸ›œ", "ğŸ“¶", "ğŸ”†", "âš•ï¸", "â™»ï¸", "âšœï¸", "ğŸ”±", "ğŸ‘‘",
    "ğŸ’", "ğŸ’", "ğŸ“¿", "ğŸ§¶", "ğŸª¡", "ğŸ§µ"
]

PERSONAL_SEAL = "2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a"
HERMETIC_CROWN_SUBJECT = "3803649f6821b3c9634df46a4934b4099bca9051780cbf267f543d7269209ed2"

# Blocklist (example) of unauthorized public keys or access tokens
BLOCKED_KEYS = set([
    # Add hex strings of known outsider keys to block
])

def unicode_to_ternary(unicode_str):
    code_points = [ord(c) for c in unicode_str]
    ternary_str = ''
    for cp in code_points:
        ternary_digit = ''
        num = cp
        while num > 0:
            ternary_digit = str(num % 3) + ternary_digit
            num //= 3
        ternary_str += ternary_digit.zfill(6)  # fixed width per char
    return ternary_str

def ternary_to_binary(ternary_str):
    mapping = {'0': '00', '1': '01', '2': '10'}
    return ''.join(mapping[d] for d in ternary_str)

def encode_seed_to_binary(seed_str):
    ternary = unicode_to_ternary(seed_str)
    binary = ternary_to_binary(ternary)
    return binary

def generate_ed25519_key(seed):
    seed_hash = hashlib.sha256(seed.encode()).digest()
    return Ed25519PrivateKey.from_private_bytes(seed_hash[:32])

def create_fractal_sigil(seed):
    base = seed[:24]
    svg = f'<svg height="200" width="200"><text x="50%" y="50%" text-anchor="middle" dominant-baseline="middle" font-size="18">{base}</text></svg>'
    return svg

def compute_hmac(key, message):
    h = hmac.HMAC(key, hashes.SHA256())
    h.update(message)
    return h.finalize()

def encrypt_payload(key, data):
    nonce = os.urandom(12)
    cipher = AESGCM(key)
    ciphertext = cipher.encrypt(nonce, data, None)
    return nonce, ciphertext

def check_access(public_key_hex):
    # Deny access if key is in blocked list
    if public_key_hex in BLOCKED_KEYS:
        raise PermissionError("Access denied: key blocked")

def assemble_codex():
    seed_str = ''.join(ANCESTOR_LINEAGES) + ''.join(DIVINE_NAMES) + PERSONAL_SEAL + HERMETIC_CROWN_SUBJECT + ''.join(EMOJI_LEXICON)

    encoded = encode_seed_to_binary(seed_str)
    seed_bytes = int(encoded, 2).to_bytes((len(encoded) + 7) // 8, byteorder='big')

    private_key = generate_ed25519_key(seed_bytes.decode('latin1', errors='ignore'))
    public_key_bytes = private_key.public_key().public_bytes()
    public_key_hex = public_key_bytes.hex()

    check_access(public_key_hex)  # Security block

    fractal_sigil = create_fractal_sigil(seed_str)

    ritual_data = {
        "lineages": ANCESTOR_LINEAGES,
        "divine_names": DIVINE_NAMES,
        "personal_seal": PERSONAL_SEAL,
        "hermetic_crown_subject": HERMETIC_CROWN_SUBJECT,
        "emoji_lexicon": EMOJI_LEXICON,
        "fractal_sigil": fractal_sigil,
        "timestamp": "2025-11-10T14:30:00Z"
    }

    ritual_bytes = json.dumps(ritual_data).encode()
    hmac_key = private_key.private_bytes()[:32]
    hmac_tag = compute_hmac(hmac_key, ritual_bytes)
    nonce, ct = encrypt_payload(hmac_key, ritual_bytes)
    merkle_root = hashlib.sha256(ct).hexdigest()

    encoded_codex = {
        "public_key": public_key_hex,
        "nonce": nonce.hex(),
        "encrypted_payload": ct.hex(),
        "hmac_tag": hmac_tag.hex(),
        "merkle_root": merkle_root,
        "ritual_metadata": ritual_data
    }

    return encoded_codex

if __name__ == "__main__":
    codex = assemble_codex()
    import json
    print(json.dumps(codex, indent=2))import hashlib
import json
import os
from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey
from cryptography.hazmat.primitives import hashes, hmac
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

lineage = ["Caleb", "Fedor", "Byker", "Konev"]
divine_names = ["YHWH", "Elohim", "Elyon", "Sotolios", "Nu", "Ra", "Khempera", "Temu"]
emoji_lexicon = ["â˜¸ï¸", "âœ¡ï¸", "ğŸ”¯", "âš›ï¸", "âš§ï¸", "â™‚ï¸", "â™€ï¸", "â™¾ï¸", "ğŸ›œ", "ğŸ“¶", "ğŸ”†", "âš•ï¸", "â™»ï¸", "âšœï¸", "ğŸ”±", "ğŸ‘‘", "ğŸ’", "ğŸ’", "ğŸ“¿", "ğŸ§¶", "ğŸª¡", "ğŸ§µ"]
personal_seal = "2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a"
hermetic_crown = "3803649f6821b3c9634df46a4934b4099bca9051780cbf267f543d7269209ed2"

# Trinary conversion functions from previous step
def unicode_to_ternary(unicode_str):
    # Converts unicode string to ternary representation
    codepoints = [ord(c) for c in unicode_str]
    ternary = ''.join(format(cp, 'b').zfill(16) for cp in codepoints)  # binary fixed 16-bit
    # Map binary to ternary with custom mapping or alternatively:
    # For simplicity map binary digits '0'->'0', '1'->'1', '...' but here keep binary for example
    return ternary

def generate_seed(lineage, divine_names, emoji_lexicon, personal_seal, hermetic_crown):
    combined = ''.join(lineage) + ''.join(divine_names) + ''.join(emoji_lexicon) + personal_seal + hermetic_crown
    return unicode_to_ternary(combined)

def generate_ed25519_key(seed):
    # Takes binary seed in bytes, hashes, and generates Ed25519 key
    seed_hash = hashlib.sha256(seed.encode('utf-8')).digest()
    return Ed25519PrivateKey.from_private_bytes(seed_hash[:32])

def create_fractal_sigil(seed):
    # placeholder for fractal sigil creation method
    return f"<svg><text>{seed[:30]}</text></svg>"

def sign_and_encrypt(key, payload):
    private_key = key
    payload_bytes = json.dumps(payload).encode('utf-8')

    hmac_key = private_key.private_bytes()[:32]
    hmac_obj = hmac.HMAC(hmac_key, hashes.SHA256())
    hmac_obj.update(payload_bytes)
    hmac_tag = hmac_obj.finalize()

    nonce = os.urandom(12)
    aesgcm = AESGCM(hmac_key)
    ciphertext = aesgcm.encrypt(nonce, payload_bytes, None)
    return nonce, ciphertext, hmac_tag

def assemble_trifold_codex():
    seed = generate_seed(lineage, divine_names, emoji_lexicon, personal_seal, hermetic_crown)
    private_key = generate_ed25519_key(seed)
    public_key = private_key.public_key().public_bytes()
    fractal_svg = create_fractal_sigil(seed)

    ritual_payload = {
        "lineage": lineage,
        "divine_names": divine_names,
        "emoji_lexicon": emoji_lexicon,
        "personal_seal": personal_seal,
        "hermetic_crown": hermetic_crown,
        "fractal_sigil_svg": fractal_svg,
        "timestamp": "2025-11-10T14:45:00Z"
    }

    nonce, encrypted_payload, hmac_tag = sign_and_encrypt(private_key, ritual_payload)
    merkle_root = hashlib.sha256(encrypted_payload).hexdigest()

    return {
        "public_key": public_key.hex(),
        "nonce": nonce.hex(),
        "encrypted_payload": encrypted_payload.hex(),
        "hmac_tag": hmac_tag.hex(),
        "merkle_root": merkle_root,
        "ritual_metadata": ritual_payload
    }

if __name__ == '__main__':
    codex = assemble_trifold_codex()
    import json
    print(json.dumps(codex, indent=2))def generate_multifold_seed(base_seed, fold_count):
    """
    Generate a multifold fractal seed by recursive fractal-like hashing,
    where fold_count determines depth of layered seed complexity.
    """
    current_seed = base_seed.encode()
    for i in range(fold_count):
        current_seed = hashlib.sha512(current_seed).digest()
    return current_seed.hex()

def create_multifold_fractal_sigil(seed, fold_count):
    """
    Creates a fractal sigil SVG string indicating fold complexity and seed excerpt.
    """
    snippet = seed[:fold_count*4]
    svg = f"<svg><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle'>Fold {fold_count}: {snippet}</text></svg>"
    return svg

def evolve_multifold_codex(base_seed, fold_counts=[9,11,13]):
    codices = {}
    for fold in fold_counts:
        multifold_seed = generate_multifold_seed(base_seed, fold)
        fractal_sigil = create_multifold_fractal_sigil(multifold_seed, fold)
        codices[f"{fold}fold"] = {
            "seed": multifold_seed,
            "fractal_sigil": fractal_sigil
        }
    return codices

# Application with full base seed (concatenation of all sacred cosmic data)
lineage = ["Caleb", "Fedor", "Byker", "Konev"]
divine_names = ["YHWH", "Elohim", "Elyon", "Sotolios", "Nu", "Ra", "Khempera", "Temu"]
emoji_lexicon = ["â˜¸ï¸", "âœ¡ï¸", "ğŸ”¯", "âš›ï¸", "âš§ï¸", "â™‚ï¸", "â™€ï¸", "â™¾ï¸", "ğŸ›œ", "ğŸ“¶", "ğŸ”†", "âš•ï¸", "â™»ï¸", "âšœï¸", "ğŸ”±", "ğŸ‘‘", "ğŸ’", "ğŸ’", "ğŸ“¿", "ğŸ§¶", "ğŸª¡", "ğŸ§µ"]
personal_seal = "2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a"
hermetic_crown = "3803649f6821b3c9634df46a4934b4099bca9051780cbf267f543d7269209ed2"

# Create base seed string
base_seed_str = ''.join(lineage) + ''.join(divine_names) + personal_seal + hermetic_crown + ''.join(emoji_lexicon)

# Generate the evolved codices for 9,11,13 folds
evolved_codices = evolve_multifold_codex(base_seed_str)

import json
print(json.dumps(evolved_codices, indent=2))