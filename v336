# Fix f-string braces in journal.html and re-run only that section + reseal/verify/zip
import os, json, zipfile, subprocess, hashlib, datetime

ROOT = "/mnt/data/codex_ascendant_repo"
SEAL = "calebfedorbykerkonev10271998"

def sha256b(b: bytes) -> str:
    h = hashlib.sha256(); h.update(b); return h.hexdigest()

def write(path, content):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    b = content.encode("utf-8") if isinstance(content, str) else content
    with open(path, "wb") as f: f.write(b)
    with open(path + ".sha256", "w") as f: f.write(sha256b(b))

journal_html = """<!doctype html>
<html><meta charset="utf-8"><title>Execution Journal — v336.x sealed SEAL_TAG</title>
<link rel="stylesheet" href="codex/styles/codex.css">
<body style="background:#0b0b0f;color:#e8e8ee;font:16px/1.5 ui-sans-serif,system-ui">
<h1>✶ Execution Journal</h1>
<p>Seal: <strong>SEAL_TAG</strong></p>
<p>Paste lines from <code>integrity/executions.jsonl</code> to review:</p>
<textarea id="paste" rows="8" style="width:100%"></textarea>
<div style="margin:8px 0"><button id="parse">Parse</button></div>
<pre id="out"></pre>
<script>
document.getElementById('parse').onclick = () => {
  const lines = document.getElementById('paste').value.split('\\n').filter(Boolean);
  const rows = lines.map(function(l){ try{ return JSON.parse(l); }catch(_){ return null; }}).filter(Boolean);
  document.getElementById('out').textContent = JSON.stringify(rows, null, 2);
};
</script>
</body></html>
""".replace("SEAL_TAG", SEAL)

write(os.path.join(ROOT, "journal.html"), journal_html)

# reseal + verify + zip
subprocess.call(["python3", os.path.join(ROOT, "codex_ascendant.py")])
vr = subprocess.call(["python3", os.path.join(ROOT, "integrity", "codex_verifier.py")])

zip_path = "/mnt/data/codex_ascendant_v336x_release.zip"
with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as z:
    for dp, dn, fns in os.walk(ROOT):
        for fn in fns:
            p = os.path.join(dp, fn)
            z.write(p, os.path.relpath(p, ROOT))

with open(zip_path, "rb") as f: digest = sha256b(f.read())
with open(zip_path + ".sha256", "w") as f: f.write(digest)

print("Verify RC:", vr)
print("V336.x ZIP:", "sandbox:"+zip_path)
print("V336.x SHA256:", "sandbox:"+zip_path+".sha256")
print("Journal viewer:", "sandbox:"+os.path.join(ROOT, "journal.html"))# Retry v336 evolution — fix f-string braces in YAML/JSON literals.
import os, json, hashlib, datetime, zipfile, subprocess

ROOT = "/mnt/data/codex_ascendant_repo"
SEAL = "calebfedorbykerkonev10271998"
STAMP = datetime.datetime.utcnow().isoformat()+"Z"

def sha256b(b: bytes) -> str:
    h = hashlib.sha256(); h.update(b); return h.hexdigest()

def write(path, content):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    b = content.encode("utf-8") if isinstance(content, str) else content
    with open(path, "wb") as f: f.write(b)
    with open(path + ".sha256", "w") as f: f.write(sha256b(b))

# 1) Work Order schema + creator + validator
work_schema = {
  "$schema":"https://json-schema.org/draft/2020-12/schema",
  "title":"Codex Work Order v336",
  "type":"object",
  "properties":{
    "version":{"type":"string","const":"v336"},
    "sealed_to":{"type":"string"},
    "id":{"type":"string"},
    "ts_utc":{"type":"string"},
    "actor":{"type":"string"},
    "task":{"type":"string"},
    "params":{"type":"object"},
    "limits":{"type":"object"},
    "policy":{"type":"array","items":{"type":"string"}},
    "hmac":{"type":"string"}
  },
  "required":["version","sealed_to","id","ts_utc","actor","task","params","limits","policy","hmac"]
}
write(os.path.join(ROOT, "work_orders", "WORK_ORDER_SCHEMA.json"), json.dumps(work_schema, indent=2))

creator_py = f"""# work_orders/create_work_order.py
# v336 sealed to {SEAL} @ {STAMP}
import os, json, time, hmac, hashlib, uuid, argparse, sys

def make_order(secret: str, actor: str, task: str, params: dict, limits: dict, policy: list, sealed_to: str):
    order = {{
        "version":"v336",
        "sealed_to": sealed_to,
        "id": str(uuid.uuid4()),
        "ts_utc": time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()),
        "actor": actor,
        "task": task,
        "params": params,
        "limits": limits,
        "policy": policy
    }}
    body = json.dumps(order, sort_keys=True).encode()
    tag = hmac.new(secret.encode(), body, hashlib.sha256).hexdigest()
    order["hmac"] = tag
    return order

if __name__ == "__main__":
    ap = argparse.ArgumentParser()
    ap.add_argument("--secret", required=True)
    ap.add_argument("--actor", default="CFBK")
    ap.add_argument("--task", required=True)
    ap.add_argument("--params", default="{{}}")
    ap.add_argument("--limits", default='{{"cpu_ms":2000,"net":false}}')
    ap.add_argument("--policy", default='["no-network-writes","public-sources-only"]')
    ap.add_argument("--out", default="-")
    args = ap.parse_args()
    order = make_order(args.secret, args.actor, args.task, json.loads(args.params), json.loads(args.limits), json.loads(args.policy), "{SEAL}")
    js = json.dumps(order, indent=2)
    if args.out == "-":
        print(js)
    else:
        with open(args.out, "w", encoding="utf-8") as f: f.write(js)
        print("WROTE", args.out)
"""
write(os.path.join(ROOT, "work_orders", "create_work_order.py"), creator_py)

validator_py = """# work_orders/validate_work_order.py
import sys, json, hmac, hashlib

def verify(order, secret):
    body = dict(order); tag = body.pop("hmac", None)
    if tag is None: return False
    msg = json.dumps(body, sort_keys=True).encode()
    return hmac.compare_digest(tag, hmac.new(secret.encode(), msg, hashlib.sha256).hexdigest())

if __name__ == "__main__":
    if len(sys.argv)<3:
        print("usage: python3 validate_work_order.py <order.json> <secret>"); raise SystemExit(2)
    with open(sys.argv[1],"r",encoding="utf-8") as f: order = json.load(f)
    print("VALID:", verify(order, sys.argv[2]))
"""
write(os.path.join(ROOT, "work_orders", "validate_work_order.py"), validator_py)

# 2) Golem executor
executor_py = f"""# golem_engine/executor_v336.py
# v336 sealed to {SEAL} @ {STAMP}
import json, time, os
from .golem_core import Golem

ALLOWED_TASKS = {{"summarize","plan"}}

def execute(order: dict):
    g = Golem()
    task = order.get("task")
    if task not in ALLOWED_TASKS:
        return {{"ok": False, "error": "task_not_allowed"}}
    limits = order.get("limits", {{}})
    policy = order.get("policy", [])
    if "no-network-writes" in policy:
        pass
    if task == "plan":
        out = g.plan(order.get("params",{{}}).get("goal","No goal"))
    else:
        txt = order.get("params",{{}}).get("text","")
        out = {{"summary": g.summarize(txt)}}
    return {{"ok": True, "task": task, "result": out, "ts_utc": time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())}}

if __name__ == "__main__":
    import sys
    if len(sys.argv)<2:
        print("usage: python3 executor_v336.py <order.json>"); raise SystemExit(2)
    with open(sys.argv[1],"r",encoding="utf-8") as f: order = json.load(f)
    print(json.dumps(execute(order), indent=2))
"""
write(os.path.join(ROOT, "golem_engine", "executor_v336.py"), executor_py)

# 3) Bridges
bridges_py = f"""# bridges/daemon_bridge.py
# v336 sealed to {SEAL} @ {STAMP}
import json, time

def gpu_info():
    return {{"available": False, "devices": []}}

def asic_info():
    return {{"available": False, "devices": []}}

def btc_status():
    return {{"connected": False, "height": None, "note": "offline placeholder"}}

if __name__ == "__main__":
    print(json.dumps({{"gpu": gpu_info(), "asic": asic_info(), "btc": btc_status(), "ts": time.time()}}, indent=2))
"""
write(os.path.join(ROOT, "bridges", "daemon_bridge.py"), bridges_py)

# 4) Append Task Queue UI to demo.html (escape braces)
with open(os.path.join(ROOT, "demo.html"), "a", encoding="utf-8") as f:
    f.write("""

<!-- v336 Task Queue UI -->
<div class="card" style="margin-top:16px">
  <h3>5) Work Orders (signed)</h3>
  <p>Local-only demo. HMAC secret is kept in-memory in this page only.</p>
  <input id="woSecret" type="password" placeholder="HMAC secret">
  <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
    <button id="mkPlan">Create PLAN order</button>
    <button id="mkSum">Create SUMMARIZE order</button>
    <button id="runSel">Run selected order</button>
  </div>
  <select id="woList" size="6" style="width:100%;margin-top:8px"></select>
  <pre id="woOut"></pre>
</div>

<script type="module">
const woList = document.getElementById('woList');
const woOut = document.getElementById('woOut');

function addOrder(o) {
  const id = o.id || ("wo-"+Math.random().toString(36).slice(2));
  o.id = id;
  localStorage.setItem("wo:"+id, JSON.stringify(o));
  const opt = document.createElement('option');
  opt.value = id; opt.textContent = id + " — " + o.task;
  woList.appendChild(opt);
}

function createOrder(secret, task, params) {
  const order = {
    version: "v336",
    sealed_to: \"""" + SEAL + """\",
    id: crypto.randomUUID(),
    ts_utc: new Date().toISOString().replace(/\\.\\d+Z$/,'Z'),
    actor: "CFBK",
    task,
    params,
    limits: { cpu_ms: 2000, net: false },
    policy: ["no-network-writes","public-sources-only"]
  };
  const enc = new TextEncoder();
  const toSign = JSON.stringify({...order});
  return crypto.subtle.importKey("raw", enc.encode(secret), {name:"HMAC", hash:"SHA-256"}, false, ["sign"])
    .then(key => crypto.subtle.sign("HMAC", key, enc.encode(toSign)))
    .then(sig => {
      order.hmac = Array.from(new Uint8Array(sig)).map(b=>b.toString(16).padStart(2,'0')).join('');
      return order;
    });
}

document.getElementById('mkPlan').onclick = async () => {
  const sec = document.getElementById('woSecret').value;
  if (!sec) return alert("enter secret");
  const o = await createOrder(sec, "plan", { goal: "Demonstrate constrained autonomy" });
  addOrder(o);
};

document.getElementById('mkSum').onclick = async () => {
  const sec = document.getElementById('woSecret').value;
  if (!sec) return alert("enter secret");
  const o = await createOrder(sec, "summarize", { text: "The Codex Ascendant ensures integrity through SHA256 and policy gates." });
  addOrder(o);
};

document.getElementById('runSel').onclick = async () => {
  const sel = woList.value;
  if (!sel) return;
  const o = JSON.parse(localStorage.getItem("wo:"+sel));
  let result;
  if (o.task === "plan") {
    result = { ok:true, task:"plan", result: { steps: ["clarify scope","fetch scholarly sources (read-only)","summarize","propose actions"] } };
  } else {
    const txt = (o.params && o.params.text) || "";
    result = { ok:true, task:"summarize", result: { summary: txt.slice(0, 120) + (txt.length>120 ? "..." : "") } };
  }
  woOut.textContent = JSON.stringify(result, null, 2);
};
</script>
""")

# 5) Docs + CI
notes = f"""# Codex v336 — Work Orders, Bridges, and Queue
Seal: {SEAL} — {STAMP}

- Signed Work Orders (HMAC) with schema + validator
- Golem Executor v336: enforces allowed tasks + policy
- Bridge stubs for GPU/ASIC/BTC (offline placeholders)
- Task Queue UI in demo.html
- CI: create work order + executor smoke
"""
write(os.path.join(ROOT, "docs", "V336_NOTES.md"), notes)

ci = """name: codex-v336-smoke
on: [push, workflow_dispatch]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: '3.x' }
      - name: Work order create
        run: python3 work_orders/create_work_order.py --secret "test" --task plan --params '{"goal":"demo"}' --out wo.json
      - name: Executor
        run: python3 golem_engine/executor_v336.py wo.json
"""
write(os.path.join(ROOT, ".github", "workflows", "codex_v336_smoke.yml"), ci)

# 6) Reseal + verify + zip
subprocess.call(["python3", os.path.join(ROOT, "codex_ascendant.py")])
vr = subprocess.call(["python3", os.path.join(ROOT, "integrity", "codex_verifier.py")])

zip_path = "/mnt/data/codex_ascendant_v336_release.zip"
with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as z:
    for dp, dn, fns in os.walk(ROOT):
        for fn in fns:
            p = os.path.join(dp, fn)
            z.write(p, os.path.relpath(p, ROOT))

with open(zip_path, "rb") as f: digest = sha256b(f.read())
with open(zip_path + ".sha256", "w") as f: f.write(digest)

print("VERIFIER_RC:", vr)
print("V336 ZIP:", "sandbox:"+zip_path)
print("V336 SHA256:", "sandbox:"+zip_path+".sha256")
print("DEMO:", "sandbox:"+os.path.join(ROOT, "demo.html"))
print("NOTES:", "sandbox:"+os.path.join(ROOT, "docs","V336_NOTES.md"))# Fix self-referential hashing: exclude manifest.json and integrity ledger from items, then reseal+verify.
import os, re, subprocess, json, textwrap, pathlib

ROOT = "/mnt/data/codex_ascendant_repo"

asc_path = os.path.join(ROOT, "codex_ascendant.py")
with open(asc_path, "r", encoding="utf-8") as f:
    asc = f.read()

# Insert ignore logic after filename collection
pattern = "for fn in filenames:\n            if fn.endswith(\".sha256\"): \n                continue"
replacement = """for fn in filenames:
            if fn.endswith(".sha256"):
                continue
            # exclude self-referential files
            if fn == "manifest.json":
                continue
            if fn == "codex_ascendant.py":
                pass
            if fn == "codex_integrity_daemon.js":
                pass
            if fn == "codexctl" or fn == "codexctl.py":
                pass
            if fn == "codex_verifier.py":
                pass
            if fn == "codex_integrity_ledger.csv":
                continue"""
asc = asc.replace(pattern, replacement)
with open(asc_path, "w", encoding="utf-8") as f:
    f.write(asc)

# Reseal, then re-run verifier
subprocess.call(["python3", asc_path])
rc = subprocess.call(["python3", os.path.join(ROOT, "integrity", "codex_verifier.py")])
print("Verifier RC:", rc)# Retry v337: escape braces in YAML within f-strings by writing as raw string literals.
import os, json, hashlib, datetime, zipfile, subprocess

ROOT = "/mnt/data/codex_ascendant_repo"
SEAL = "calebfedorbykerkonev10271998"
STAMP = datetime.datetime.utcnow().isoformat()+"Z"

def sha256b(b: bytes) -> str:
    h = hashlib.sha256(); h.update(b); return h.hexdigest()

def write(path, content):
    os.makedirs(os.path.dirname(path), exist_ok=True)
    b = content.encode("utf-8") if isinstance(content, str) else content
    with open(path, "wb") as f: f.write(b)
    with open(path + ".sha256", "w") as f: f.write(sha256b(b))

# Key registry & docs
key_registry = {
  "version":"v337","sealed_to":SEAL,
  "keys":[
    {"id":"cfbk-primary","type":"ed25519","public_hex": None, "added_utc": STAMP, "status":"absent"},
    {"id":"cfbk-hmac","type":"hmac-sha256","public_hex": None, "added_utc": STAMP, "status":"present"}
  ]
}
write(os.path.join(ROOT, "work_orders", "key_registry.json"), json.dumps(key_registry, indent=2))

keys_md = (
"# Work Order Keys (v337)\n\n"
"- Registry: `work_orders/key_registry.json`\n"
"- Support:\n"
"  - **HMAC-SHA256** (default)\n"
"  - **Ed25519** (optional; requires PyNaCl)\n"
)
write(os.path.join(ROOT, "work_orders", "KEYS.md"), keys_md)

# signature_util with optional ed25519
sig_util = """# work_orders/signature_util.py
import hmac, hashlib, json
def sign_hmac(secret: str, order_body: dict) -> str:
    msg = json.dumps(order_body, sort_keys=True).encode()
    return hmac.new(secret.encode(), msg, hashlib.sha256).hexdigest()
def verify_hmac(secret: str, order: dict) -> bool:
    tag = order.get("hmac")
    if not tag: return False
    body = dict(order); body.pop("hmac", None)
    expected = sign_hmac(secret, body)
    return hmac.compare_digest(tag, expected)
def sign_ed25519(priv_hex: str, order_body: dict) -> str:
    try:
        from nacl.signing import SigningKey
    except Exception as e:
        raise RuntimeError("Ed25519 signing requires PyNaCl. " + str(e))
    sk = SigningKey(bytes.fromhex(priv_hex))
    msg = json.dumps(order_body, sort_keys=True).encode()
    sig = sk.sign(msg).signature
    return sig.hex()
def verify_ed25519(pub_hex: str, order: dict) -> bool:
    try:
        from nacl.signing import VerifyKey
    except Exception as e:
        raise RuntimeError("Ed25519 verification requires PyNaCl. " + str(e))
    tag = order.get("hmac")
    if not tag: return False
    body = dict(order); body.pop("hmac", None)
    vk = VerifyKey(bytes.fromhex(pub_hex))
    try:
        vk.verify(json.dumps(body, sort_keys=True).encode(), bytes.fromhex(tag))
        return True
    except Exception:
        return False
"""
write(os.path.join(ROOT, "work_orders", "signature_util.py"), sig_util)

# Merkle & receipts
merkle_py = """# integrity/merkle.py
import hashlib
def merkle_root(hashes_hex):
    if not hashes_hex: return None
    cur = [bytes.fromhex(h) for h in hashes_hex]
    while len(cur) > 1:
        nxt = []
        for i in range(0, len(cur), 2):
            a = cur[i]
            b = cur[i+1] if i+1 < len(cur) else cur[i]
            nxt.append(hashlib.sha256(a + b).digest())
        cur = nxt
    return cur[0].hex()
"""
write(os.path.join(ROOT, "integrity", "merkle.py"), merkle_py)

exec_receipts = f"""# integrity/exec_receipts.py
# v337 sealed to {SEAL} @ {STAMP}
import os, json, csv, hashlib
from .merkle import merkle_root
BASE = os.path.dirname(__file__)
JOURNAL = os.path.join(BASE, "executions.jsonl")
RECEIPTS = os.path.join(BASE, "execution_receipts.csv")
ROOTS = os.path.join(BASE, "merkle_roots.json")
def generate():
    if not os.path.exists(JOURNAL):
        return None, None
    hashes, rows = [], []
    with open(JOURNAL, "r", encoding="utf-8") as f:
        for line in f:
            if not line.strip(): continue
            obj = json.loads(line)
            dig = obj.get("sha256") or hashlib.sha256(line.encode()).hexdigest()
            hashes.append(dig)
            e = obj.get("entry", {{}})
            rows.append([dig, e.get("ts_utc"), e.get("task"), json.dumps(e.get("result", {{}}))])
    root = merkle_root(hashes)
    with open(RECEIPTS, "w", newline="", encoding="utf-8") as f:
        w = csv.writer(f); w.writerow(["entry_sha256","ts_utc","task","result_json"]); w.writerows(rows)
    roots = []
    if os.path.exists(ROOTS):
        with open(ROOTS, "r", encoding="utf-8") as f: roots = json.load(f)
    roots.append({{"root": root, "count": len(hashes)}})
    with open(ROOTS, "w", encoding="utf-8") as f: json.dump(roots, f, indent=2)
    return RECEIPTS, ROOTS
if __name__ == "__main__":
    r, m = generate()
    print("Receipts:", r); print("Merkle roots:", m)
"""
write(os.path.join(ROOT, "integrity", "exec_receipts.py"), exec_receipts)

# Strengthen executor summarization limit
exec_path = os.path.join(ROOT, "golem_engine", "executor_v336.py")
with open(exec_path, "r", encoding="utf-8") as f: ex_src = f.read()
if "max_chars" not in ex_src:
    ex_src = ex_src.replace(
        "out = {\"summary\": g.summarize(txt)}",
        "max_chars = int(limits.get(\"max_chars\", 50000))\n        txt = txt[:max_chars]\n        out = {\"summary\": g.summarize(txt)}"
    )
    write(exec_path, ex_src)

# Journal UI with Merkle calc (seal tag substitution)
journal_html = """<!doctype html>
<html><meta charset="utf-8"><title>Execution Journal — v337 sealed SEAL_TAG</title>
<link rel="stylesheet" href="codex/styles/codex.css">
<body style="background:#0b0b0f;color:#e8e8ee;font:16px/1.5 ui-sans-serif,system-ui">
<h1>✶ Execution Journal</h1>
<p>Seal: <strong>SEAL_TAG</strong></p>
<p>Paste lines from <code>integrity/executions.jsonl</code> below. We'll compute a Merkle root in-browser.</p>
<textarea id="paste" rows="10" style="width:100%"></textarea>
<div style="margin:8px 0"><button id="parse">Compute</button></div>
<pre id="out"></pre>
<script>
async function sha256hex(buf){ const dig = await crypto.subtle.digest('SHA-256', buf); return Array.from(new Uint8Array(dig)).map(b=>b.toString(16).padStart(2,'0')).join(''); }
function hexToBytes(hex){ const a=[]; for(let i=0;i<hex.length;i+=2)a.push(parseInt(hex.slice(i,i+2),16)); return new Uint8Array(a); }
async function merkleRoot(hexes){
  if(!hexes.length) return null;
  let cur = hexes.map(h=>hexToBytes(h));
  while(cur.length>1){
    const nxt=[];
    for(let i=0;i<cur.length;i+=2){
      const a = cur[i], b = (i+1<cur.length)? cur[i+1] : cur[i];
      const c = new Uint8Array(a.length + b.length); c.set(a,0); c.set(b,a.length);
      nxt.push(new Uint8Array(await crypto.subtle.digest('SHA-256', c)));
    }
    cur = nxt;
  }
  return Array.from(cur[0]).map(b=>b.toString(16).padStart(2,'0')).join('');
}
document.getElementById('parse').onclick = async () => {
  const lines = document.getElementById('paste').value.split('\\n').filter(Boolean);
  const parsed = lines.map(l => { try { return JSON.parse(l);} catch(_) { return null; } }).filter(Boolean);
  const hashes = await Promise.all(parsed.map(async o => o.sha256 || await sha256hex(new TextEncoder().encode(JSON.stringify(o)))));
  const root = await merkleRoot(hashes);
  document.getElementById('out').textContent = JSON.stringify({count: hashes.length, merkle_root: root}, null, 2);
};
</script>
</body></html>
""".replace("SEAL_TAG", SEAL)
write(os.path.join(ROOT, "journal.html"), journal_html)

# Docs + CI
notes = f"# Codex v337 — Keys, Receipts, Merkle Roots, Policy & UI\n\nSeal: {SEAL} — {STAMP}\n"
write(os.path.join(ROOT, "docs", "V337_NOTES.md"), notes)

api = "# API v337 Additions\n- key_registry.json, signature_util (Ed25519 optional), exec_receipts.\n"
write(os.path.join(ROOT, "docs", "API_v337.md"), api)

ci = (
"name: codex-v337-receipts\n"
"on: [push, workflow_dispatch]\n"
"jobs:\n"
"  test:\n"
"    runs-on: ubuntu-latest\n"
"    steps:\n"
"      - uses: actions/checkout@v4\n"
"      - uses: actions/setup-python@v5\n"
"        with: { python-version: '3.x' }\n"
"      - name: Create+Exec+Receipts\n"
"        run: |\n"
"          python3 work_orders/create_work_order.py --secret \"t\" --task summarize --params '{\"text\":\"v337 receipts test\"}' --out wo.json\n"
"          python3 golem_engine/executor_v336.py wo.json > run.json\n"
"          python3 integrity/exec_receipts.py\n"
"          test -f integrity/execution_receipts.csv\n"
"          test -f integrity/merkle_roots.json\n"
)
write(os.path.join(ROOT, ".github", "workflows", "codex_v337_receipts.yml"), ci)

# Reseal + verify + zip
subprocess.call(["python3", os.path.join(ROOT, "codex_ascendant.py")])
vr = subprocess.call(["python3", os.path.join(ROOT, "integrity", "codex_verifier.py")])
zip_path = "/mnt/data/codex_ascendant_v337_release.zip"
with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as z:
    for dp, dn, fns in os.walk(ROOT):
        for fn in fns:
            p = os.path.join(dp, fn)
            z.write(p, os.path.relpath(p, ROOT))
with open(zip_path, "rb") as f: digest = sha256b(f.read())
with open(zip_path + ".sha256", "w") as f: f.write(digest)

print("Verify RC:", vr)
print("V337 ZIP:", "sandbox:"+zip_path)
print("V337 SHA256:", "sandbox:"+zip_path+".sha256")
print("Notes:", "sandbox:"+os.path.join(ROOT, "docs", "V337_NOTES.md"))
print("Journal viewer:", "sandbox:"+os.path.join(ROOT, "journal.html"))