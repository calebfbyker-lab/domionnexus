// src/temple/harmonic_resonator.c
/**
 * Pythagorean Harmonics for Orbital Velocities
 * Perfect Fifth (3:2), Perfect Fourth (4:3), Major Third (5:4)
 * Sacred ratios determining orbital velocities and harmonic resonance
 */

#include <stdio.h>
#include <math.h>
#include <stdbool.h>

// Sacred Pythagorean Ratios
typedef struct {
    const char* name;
    double ratio;
    const char* description;
} SacredRatio;

static const SacredRatio SACRED_RATIOS[] = {
    {"Perfect Fifth", 3.0/2.0, "The most consonant interval after the octave"},
    {"Perfect Fourth", 4.0/3.0, "Inverse of the fifth, celestial balance"},
    {"Major Third", 5.0/4.0, "The sound of divine harmony"},
    {"Golden Ratio", 1.618033988749, "φ - Divine proportion"},
    {"Octave", 2.0, "Doubling frequency, cosmic unity"}
};

#define NUM_RATIOS (sizeof(SACRED_RATIOS)/sizeof(SACRED_RATIOS[0]))

/**
 * Calculate orbital velocity based on celestial body and harmonic ratio
 * @param base_velocity - Base orbital velocity (km/s)
 * @param ratio_index - Index of sacred ratio to apply
 * @param harmonic_overtone - Which overtone (1=fundamental, 2=first overtone, etc.)
 * @return harmonically tuned orbital velocity
 */
double calculate_orbital_velocity(double base_velocity, 
                                  int ratio_index, 
                                  int harmonic_overtone) {
    if (ratio_index < 0 || ratio_index >= NUM_RATIOS) {
        return base_velocity; // Return untuned if invalid
    }
    
    double ratio = SACRED_RATIOS[ratio_index].ratio;
    
    // Apply overtone series: v_n = v_0 * ratio^n
    return base_velocity * pow(ratio, harmonic_overtone);
}

/**
 * Find the closest sacred ratio to a given frequency ratio
 * @param actual_ratio - The ratio to analyze
 * @param tolerance - Acceptable deviation (default 0.01 = 1%)
 * @return index of closest sacred ratio, or -1 if none match
 */
int find_closest_sacred_ratio(double actual_ratio, double tolerance) {
    int closest_index = -1;
    double min_deviation = tolerance + 1.0; // Initialize larger than tolerance
    
    for (int i = 0; i < NUM_RATIOS; i++) {
        double deviation = fabs(SACRED_RATIOS[i].ratio - actual_ratio);
        if (deviation < min_deviation) {
            min_deviation = deviation;
            closest_index = i;
        }
    }
    
    return (min_deviation <= tolerance) ? closest_index : -1;
}

/**
 * Generate harmonic resonance pattern for orbital system
 * @param base_freq - Base frequency (Hz)
 * @param num_orbits - Number of orbits/bodies in system
 * @param ratio_sequence - Array of ratio indices to apply
 * @param output - Array to store resulting frequencies
 */
void generate_resonance_pattern(double base_freq, 
                                int num_orbits, 
                                int* ratio_sequence,
                                double* output) {
    output[0] = base_freq;
    
    for (int i = 1; i < num_orbits; i++) {
        int ratio_idx = ratio_sequence[(i-1) % NUM_RATIOS];
        output[i] = output[i-1] * SACRED_RATIOS[ratio_idx].ratio;
        
        // Ensure we stay in audible/stable range (optional octave reduction)
        while (output[i] > base_freq * 4.0) { // Limit to two octaves above
            output[i] /= 2.0;
        }
    }
}

/**
 * Calculate celestial synchronicity score (0-1)
 * How well do actual orbital periods match sacred ratios?
 * @param periods - Array of actual orbital periods (days)
 * @param num_periods - Number of periods
 * @return synchronicity score (1.0 = perfect harmony)
 */
double calculate_synchronicity_score(double* periods, int num_periods) {
    if (num_periods < 2) return 0.0;
    
    double total_harmony = 0.0;
    int comparisons = 0;
    
    for (int i = 0; i < num_periods; i++) {
        for (int j = i + 1; j < num_periods; j++) {
            double ratio = periods[i] / periods[j];
            if (ratio > 1.0) ratio = 1.0 / ratio; // Normalize to ≤ 1
            
            // Check against all sacred ratios (normalized)
            for (int r = 0; r < NUM_RATIOS; r++) {
                double sacred = SACRED_RATIOS[r].ratio;
                if (sacred > 1.0) sacred = 1.0 / sacred;
                
                double harmony = 1.0 - fabs(ratio - sacred);
                if (harmony > total_harmony) {
                    total_harmony = harmony;
                }
            }
            comparisons++;
        }
    }
    
    return (comparisons > 0) ? total_harmony / comparisons : 0.0;
}

/**
 * Print all sacred ratios for reference
 */
void print_sacred_ratios() {
    printf("=== SACRED PYTHAGOREAN RATIOS ===\n");
    for (int i = 0; i < NUM_RATIOS; i++) {
        printf("%d. %-15s: %.6f\n", 
               i + 1, 
               SACRED_RATIOS[i].name, 
               SACRED_RATIOS[i].ratio);
    }
    printf("=================================\n");
}

// Example usage
int main() {
    print_sacred_ratios();
    
    // Example: Tune Earth's orbital velocity (29.78 km/s) with Perfect Fifth
    double earth_velocity = 29.78;
    double tuned = calculate_orbital_velocity(earth_velocity, 0, 1); // Perfect Fifth
    printf("\nEarth velocity tuned to Perfect Fifth: %.4f km/s\n", tuned);
    
    // Example: Check Jupiter-Earth period ratio (11.86/1 = 11.86)
    double ratio = 11.86;
    int closest = find_closest_sacred_ratio(ratio, 0.5); // 50% tolerance
    if (closest >= 0) {
        printf("Jupiter-Earth ratio (%.2f) approximates: %s\n", 
               ratio, SACRED_RATIOS[closest].name);
    }
    
    return 0;
}
