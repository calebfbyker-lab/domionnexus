# Build v219 â€” "Codex Logos Î› (Lambda): Orchestrator â€¢ Autoâ€‘Healing â€¢ Monetization"
# Ports: API :8950, UI :8951

import os, json, zipfile, hashlib, datetime, shutil, textwrap

BASE="/mnt/data/codex_v219_lambda_orchestrator"
if os.path.exists(BASE):
    shutil.rmtree(BASE)
os.makedirs(BASE, exist_ok=True)

def W(rel, content, mode=0o644):
    p=os.path.join(BASE, rel)
    os.makedirs(os.path.dirname(p), exist_ok=True)
    with open(p,"w",encoding="utf-8") as f: f.write(content)
    os.chmod(p, mode)
    return p

def sha256_file(p):
    h=hashlib.sha256()
    with open(p,"rb") as f:
        for chunk in iter(lambda:f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()

now = datetime.datetime.utcnow().isoformat()+"Z"

# ---------------- Root README ----------------
W("README.md", f"""# Codex Logos Î› (Lambda) â€” v219
**Orchestrator â€¢ Autoâ€‘Healing â€¢ Monetization (BTC-ready stubs)**

- API (Python stdlib): **:8950**
- UI  (Node/Express): **:8951**
- Features: health mesh for Î¥/Î¦/Î§/Î¨, job scheduler, self-heal probes, revenue ledger,
  mock BTC/Lightning adapters (pluggable), and manifest sealing.

## Quickstart
```bash
docker compose up --build
# API -> http://localhost:8950/health
# UI  -> http://localhost:8951/
```
""")

W("docker-compose.yml","""services:
  lambda-api:
    build: ./codex
    environment:
      - MESH_UPSILON=http://localhost:8917/health
      - MESH_PHI=http://localhost:8920/health
      - MESH_CHI=http://localhost:8922/health
      - MESH_PSI=http://localhost:8940/health
    ports: ["8950:8950"]
    restart: unless-stopped
  lambda-ui:
    build: ./ui
    environment:
      - LAMBDA_API=http://localhost:8950
    ports: ["8951:3000"]
    restart: unless-stopped
""")

# ---------------- API ----------------
W("codex/Dockerfile","""FROM python:3.12-alpine
RUN apk add --no-cache bash curl
WORKDIR /app
COPY . /app
EXPOSE 8950
CMD ["python3","api.py"]
""")

# Health mesh + scheduler + revenue ledger
W("codex/mesh.py","""import os, json, time, urllib.request
MESH={
  'upsilon': os.getenv('MESH_UPSILON','http://localhost:8917/health'),
  'phi':     os.getenv('MESH_PHI',    'http://localhost:8920/health'),
  'chi':     os.getenv('MESH_CHI',    'http://localhost:8922/health'),
  'psi':     os.getenv('MESH_PSI',    'http://localhost:8940/health'),
}
def check(url:str)->dict:
  try:
    with urllib.request.urlopen(url, timeout=2.5) as r:
      body=r.read().decode('utf-8')
      return {'ok':True,'status':r.status,'body':body[:256]}
  except Exception as e:
    return {'ok':False,'error':str(e)}
def mesh_health()->dict:
  return {k:check(v) for k,v in MESH.items()}
JOBS=[]
def schedule(task:str, ts:float)->dict:
  JOBS.append({'task':task,'ts':ts,'status':'queued'}); return {'ok':True,'size':len(JOBS)}
def tick(now:float)->dict:
  ran=0
  for j in JOBS:
    if j['status']=='queued' and now>=j['ts']:
      j['status']='done'; ran+=1
  return {'ran':ran,'pending':sum(1 for j in JOBS if j['status']=='queued')}
""")

W("codex/revenue.py","""import time, json, hashlib
LEDGER=[]
def _entry(kind:str, amt:int, meta:dict)->dict:
  ts=time.time(); h=hashlib.sha256(f'{ts}{kind}{amt}{meta}'.encode()).hexdigest()
  rec={'ts':ts,'kind':kind,'amount_sats':amt,'meta':meta,'hash':h}
  LEDGER.append(rec); return rec
def invoice_sats(msats:int, memo:str)->dict:
  return _entry('invoice', msats//1000, {'memo':memo,'bolt11':'lnbc1placeholder'})
def receive_tx(addr:str, sats:int)->dict:
  return _entry('onchain', sats, {'address':addr})
def summary()->dict:
  total=sum(x['amount_sats'] for x in LEDGER)
  return {'count':len(LEDGER),'total_sats':total}
""")

W("codex/api.py","""#!/usr/bin/env python3
import http.server, json, time, os
from urllib.parse import urlparse, parse_qs
from mesh import mesh_health, schedule, tick
from revenue import invoice_sats, receive_tx, summary

def _ok(h,obj): h.send_response(200); h.send_header('Content-Type','application/json'); h.end_headers(); h.wfile.write(json.dumps(obj, indent=2).encode())
class H(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        p=urlparse(self.path).path; q=parse_qs(urlparse(self.path).query)
        if p=='/health': return _ok(self, {'ok':True,'v':'v219-lambda'})
        if p=='/mesh/health': return _ok(self, mesh_health())
        if p=='/jobs/tick': return _ok(self, tick(time.time()))
        if p=='/revenue/summary': return _ok(self, summary())
        return _ok(self, {'ok':True,'service':'lambda'})

    def do_POST(self):
        p=urlparse(self.path).path
        ln=int(self.headers.get('Content-Length','0') or '0'); body=json.loads(self.rfile.read(ln).decode() or '{}') if ln>0 else {}
        if p=='/jobs/schedule': return _ok(self, schedule(body.get('task','noop'), float(body.get('ts', time.time()+1))))
        if p=='/payments/invoice': return _ok(self, invoice_sats(int(body.get('msats',1000)), body.get('memo','memo')))
        if p=='/payments/receive': return _ok(self, receive_tx(body.get('address','bc1qplaceholder'), int(body.get('sats',1))))
        self.send_error(404)

if __name__=='__main__':
    import http.server; http.server.test(HandlerClass=H, port=8950)
""", 0o755)

# ---------------- UI ----------------
W("ui/Dockerfile","""FROM node:20-alpine
WORKDIR /app
COPY . /app
RUN npm ci --ignore-scripts --fund=false --audit=false
EXPOSE 3000
CMD ["node","server.js"]
""")
W("ui/package.json", json.dumps({
  "name": "lambda-ui",
  "version": "0.1.0",
  "private": True,
  "type": "module",
  "scripts": {"start":"node server.js"},
  "dependencies": {"express":"^4.19.2","node-fetch":"^3.3.2"}
}, indent=2))
W("ui/server.js","""import express from 'express'; import fetch from 'node-fetch';
const app=express(); const API=process.env.LAMBDA_API||'http://localhost:8950';
app.get('/', async (req,res)=>{
  const [h, m, s] = await Promise.all([
    fetch(API+'/health').then(r=>r.json()).catch(()=>({ok:false})),
    fetch(API+'/mesh/health').then(r=>r.json()).catch(()=>({})),
    fetch(API+'/revenue/summary').then(r=>r.json()).catch(()=>({}))
  ]);
  res.send(`<pre>Î› UI â€” v219
API: ${API}

Health:
${JSON.stringify(h,null,2)}

Mesh:
${JSON.stringify(m,null,2)}

Revenue:
${JSON.stringify(s,null,2)}
</pre>`);
});
app.listen(3000, ()=>console.log('Î› UI on :3000'));
""")

# ---------------- CI ----------------
W(".github/workflows/ci.yml","""name: Codex Î› (v219) CI
on: [push, workflow_dispatch]
jobs:
  smoke:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Python compile
        run: python3 -m py_compile $(git ls-files '*.py')
      - name: Revenue smoke
        run: python3 - <<'PY'\nfrom codex.revenue import invoice_sats, summary\ninvoice_sats(10000,'test'); print(summary())\nPY
""")

# ---------------- Manifest ----------------
manifest={}
for root,_,files in os.walk(BASE):
    for fn in files:
        p=os.path.join(root,fn)
        rel=os.path.relpath(p, BASE)
        manifest[rel]=sha256_file(p)
W("codex/manifest.json", json.dumps({"generated_utc": now, "files": manifest}, indent=2))

# ---------------- ZIP ----------------
zip_path="/mnt/data/codex_v219_lambda_orchestrator.zip"
with zipfile.ZipFile(zip_path,"w",zipfile.ZIP_DEFLATED) as z:
    for root,_,files in os.walk(BASE):
        for fn in files:
            fp=os.path.join(root,fn)
            z.write(fp, arcname=os.path.relpath(fp, BASE))

print("READY", zip_path, BASE)# Build v219.x â€” "Codex Logos Î›Â·Î£ (Lambda-Plus): Autoscaling â€¢ Webhooks â€¢ Policy/RAG Bridge â€¢ Settlement"
# Extends v219 with autoscaler rules, webhook bus, Chi/Psi bridges, glyph router weights, CSV settlement report, Makefile & workflows.
# Ports: API :8952, UI :8953

import os, json, zipfile, hashlib, datetime, shutil, csv, io, math

BASE="/mnt/data/codex_v219x_lambda_plus"
if os.path.exists(BASE):
    shutil.rmtree(BASE)
os.makedirs(BASE, exist_ok=True)

def W(rel, content, mode=0o644):
    p=os.path.join(BASE, rel)
    os.makedirs(os.path.dirname(p), exist_ok=True)
    with open(p,"w",encoding="utf-8") as f: f.write(content)
    os.chmod(p, mode)
    return p

def sha256_file(p):
    h=hashlib.sha256()
    with open(p,"rb") as f:
        for chunk in iter(lambda:f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()

now = datetime.datetime.utcnow().isoformat()+"Z"

# ---------------- Root README ----------------
W("README.md", f"""# Codex Logos Î›Â·Î£ (Lambdaâ€‘Plus) â€” v219.x
**Autoscaling â€¢ Webhooks â€¢ Policy/RAG Bridge â€¢ Glyph Router â€¢ Settlement CSV**

- API: **:8952**
- UI : **:8953**
- New endpoints:
  - `/autoscale/rules` (GET/POST), `/autoscale/eval`
  - `/webhook/subscribe` (POST), `/webhook/emit` (POST)
  - `/router/weight?q=âœ¶â™¾ðŸ”¥ðŸ’Ž` â€” XTSG/emoji weighted routing
  - `/bridge/policy/eval` â€” proxy to Chi
  - `/bridge/rag/query` â€” proxy to Psi
  - `/settlement/report.csv` â€” CSV summary from revenue ledger

## Quickstart
```bash
docker compose up --build
# API -> http://localhost:8952/health
# UI  -> http://localhost:8953/
```
""")

W("docker-compose.yml","""services:
  lambda-plus-api:
    build: ./codex
    environment:
      - CHI_URL=http://localhost:8922
      - PSI_URL=http://localhost:8940
    ports: ["8952:8952"]
    restart: unless-stopped
  lambda-plus-ui:
    build: ./ui
    environment:
      - LAMBDA_PLUS_API=http://localhost:8952
    ports: ["8953:3000"]
    restart: unless-stopped
""")

# ---------------- API ----------------
W("codex/Dockerfile","""FROM python:3.12-alpine
RUN apk add --no-cache bash curl
WORKDIR /app
COPY . /app
EXPOSE 8952
CMD ["python3","api.py"]
""")

W("codex/glyphs.py","""import math
MAP={'âœ¶':(1,0,0),'â™¾':(0,1,1),'ðŸ”¥':(1,1,0),'ðŸ’Ž':(2,0,1),'â˜¸ï¸':(0,2,2),'âš›ï¸':(1,2,1),'âœ¡ï¸':(2,2,0),'â˜¯ï¸':(1,1,2),'ðŸª¬':(1,0,2)}
def weight(q:str)->dict:
    v=[0,0,0]
    for ch in q:
        t=MAP.get(ch); 
        if t: v=[a+b for a,b in zip(v,t)]
    mag=math.sqrt(sum(x*x for x in v)) or 1.0
    norm=[round(x/mag,3) for x in v]
    tier='gold' if norm[0]+norm[1]>1.5 else 'silver' if sum(norm)>1.0 else 'bronze'
    return {'vector':norm,'tier':tier}
""")

W("codex/autoscale.py","""import time, json
RULES=[{'metric':'cpu','gte':0.7,'scale_to':3},{'metric':'queue','gte':100,'scale_to':5}]
METRICS={'cpu':0.2,'queue':0}
def list_rules(): return {'rules':RULES}
def put_rule(rule:dict): RULES.append(rule); return {'ok':True,'count':len(RULES)}
def set_metric(name:str,val:float): METRICS[name]=val; return {'ok':True,'metrics':METRICS}
def evaluate()->dict:
    desired=1; reasons=[]
    for r in RULES:
        if METRICS.get(r['metric'],0)>=r['gte']:
            desired=max(desired, int(r['scale_to'])); reasons.append(r)
    return {'desired_replicas':desired,'reasons':reasons,'metrics':METRICS}
""")

W("codex/webhooks.py","""SUBS=[]; LOG=[]
def subscribe(url:str, topic:str='events')->dict:
    SUBS.append({'url':url,'topic':topic}); return {'ok':True,'subs':len(SUBS)}
def emit(topic:str, payload:dict)->dict:
    LOG.append({'topic':topic,'payload':payload});  # offline stub (no external HTTP)
    delivered=sum(1 for s in SUBS if s['topic']==topic)
    return {'ok':True,'delivered':delivered,'subs':len(SUBS)}
def log()->dict: return {'log':LOG[-50:]}
""")

W("codex/revenue.py","""import time, json, hashlib, csv, io
LEDGER=[]
def _entry(kind:str, amt:int, meta:dict)->dict:
  ts=time.time(); h=hashlib.sha256(f'{ts}{kind}{amt}{meta}'.encode()).hexdigest()
  rec={'ts':ts,'kind':kind,'amount_sats':amt,'meta':meta,'hash':h}
  LEDGER.append(rec); return rec
def invoice_sats(msats:int, memo:str)->dict:
  return _entry('invoice', msats//1000, {'memo':memo,'bolt11':'lnbc1placeholder'})
def receive_tx(addr:str, sats:int)->dict:
  return _entry('onchain', sats, {'address':addr})
def summary()->dict:
  total=sum(x['amount_sats'] for x in LEDGER)
  return {'count':len(LEDGER),'total_sats':total}
def to_csv()->str:
  out=io.StringIO(); w=csv.writer(out); w.writerow(['ts','kind','amount_sats','meta','hash'])
  for r in LEDGER: w.writerow([r['ts'],r['kind'],r['amount_sats'],json.dumps(r['meta']),r['hash']])
  return out.getvalue()
""")

W("codex/api.py","""#!/usr/bin/env python3
import http.server, json, os, urllib.parse, urllib.request
from urllib.parse import urlparse, parse_qs
from glyphs import weight as glyph_weight
from autoscale import list_rules, put_rule, evaluate, set_metric
from webhooks import subscribe, emit, log as wh_log
from revenue import invoice_sats, receive_tx, summary, to_csv

CHI=os.getenv('CHI_URL','http://localhost:8922')
PSI=os.getenv('PSI_URL','http://localhost:8940')

def _ok(h,obj,code=200,ctype='application/json'):
    h.send_response(code); h.send_header('Content-Type', ctype); h.end_headers()
    h.wfile.write(json.dumps(obj, indent=2).encode() if ctype=='application/json' else obj)

def _get(u):
    try:
        with urllib.request.urlopen(u, timeout=3) as r: return json.loads(r.read().decode())
    except Exception as e: return {'error':str(e)}

class H(http.server.SimpleHTTPRequestHandler):
    def _json(self):
        ln=int(self.headers.get('Content-Length','0') or '0')
        return json.loads(self.rfile.read(ln).decode() or '{}') if ln>0 else {}

    def do_GET(self):
        p=urlparse(self.path).path; q=parse_qs(urlparse(self.path).query)
        if p=='/health': return _ok(self, {'ok':True,'v':'v219.x-lambda-plus'})
        if p=='/router/weight':
            return _ok(self, glyph_weight(q.get('q',['âœ¶â™¾ðŸ”¥ðŸ’Ž'])[0]))
        if p=='/autoscale/rules': return _ok(self, list_rules())
        if p=='/autoscale/eval':
            return _ok(self, evaluate())
        if p=='/webhook/log': return _ok(self, wh_log())
        if p=='/bridge/policy/eval':
            subj=q.get('subject',['{}'])[0]; res=q.get('resource',['{}'])[0]; act=q.get('action',['read'])[0]
            return _ok(self, _get(f\"{CHI}/policy/eval?subject={urllib.parse.quote(subj)}&resource={urllib.parse.quote(res)}&action={act}\"))
        if p=='/bridge/rag/query':
            qq=q.get('q',['hermetic'])[0]
            return _ok(self, _get(f\"{PSI}/rag/query?q={urllib.parse.quote(qq)}\"))
        if p=='/settlement/report.csv':
            return _ok(self, to_csv(), ctype='text/csv')
        return _ok(self, {'ok':True,'service':'lambda-plus'})

    def do_POST(self):
        p=urlparse(self.path).path; body=self._json()
        if p=='/autoscale/rules': return _ok(self, put_rule(body))
        if p=='/autoscale/metrics': return _ok(self, set_metric(body.get('name','cpu'), float(body.get('val',0.1))))
        if p=='/webhook/subscribe': return _ok(self, subscribe(body.get('url','http://example'), body.get('topic','events')))
        if p=='/webhook/emit': return _ok(self, emit(body.get('topic','events'), body.get('payload',{})))
        if p=='/payments/invoice': return _ok(self, invoice_sats(int(body.get('msats',1000)), body.get('memo','memo')))
        if p=='/payments/receive': return _ok(self, receive_tx(body.get('address','bc1qplaceholder'), int(body.get('sats',1))))
        self.send_error(404)

if __name__=='__main__':
    import http.server
    http.server.test(HandlerClass=H, port=8952)
""", 0o755)

# ---------------- UI ----------------
W("ui/Dockerfile","""FROM node:20-alpine
WORKDIR /app
COPY . /app
RUN npm ci --ignore-scripts --fund=false --audit=false
EXPOSE 3000
CMD ["node","server.js"]
""")
W("ui/package.json", json.dumps({
  "name": "lambda-plus-ui",
  "version": "0.1.0",
  "private": True,
  "type": "module",
  "scripts": {"start":"node server.js"},
  "dependencies": {"express":"^4.19.2","node-fetch":"^3.3.2"}
}, indent=2))
W("ui/server.js","""import express from 'express'; import fetch from 'node-fetch';
const app=express(); const API=process.env.LAMBDA_PLUS_API||'http://localhost:8952';
app.get('/', async (req,res)=>{
  const [h, autoscale, router] = await Promise.all([
    fetch(API+'/health').then(r=>r.json()).catch(()=>({ok:false})),
    fetch(API+'/autoscale/eval').then(r=>r.json()).catch(()=>({})),
    fetch(API+'/router/weight?q=âœ¶â™¾ðŸ”¥ðŸ’Žâ˜¯ï¸').then(r=>r.json()).catch(()=>({}))
  ]);
  res.send(`<pre>Î›Â·Î£ UI â€” v219.x
API: ${API}

Health:
${JSON.stringify(h,null,2)}

Autoscale:
${JSON.stringify(autoscale,null,2)}

Router:
${JSON.stringify(router,null,2)}
</pre>`);
});
app.listen(3000, ()=>console.log('Î›Â·Î£ UI on :3000'));
""")

# Makefile & CI
W("Makefile",""".PHONY: up down test manifest
up: ; docker compose up --build -d
down: ; docker compose down
test:
\tcurl -s localhost:8952/health || true
manifest:
\tpython3 - <<'PY'\nimport json,hashlib,os\nm={}\nfor root,_,files in os.walk('.'):\n  for f in files:\n    p=os.path.join(root,f)\n    with open(p,'rb') as fh:\n      m[p]=hashlib.sha256(fh.read()).hexdigest()\nprint(json.dumps(m,indent=2))\nPY
""")

W(".github/workflows/ci.yml","""name: Codex Î›Â·Î£ (v219.x) CI
on: [push, workflow_dispatch]
jobs:
  smoke:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Python compile
        run: python3 -m py_compile $(git ls-files '*.py')
      - name: Glyph router smoke
        run: python3 - <<'PY'\nfrom codex.glyphs import weight; print(weight('âœ¶â™¾ðŸ”¥ðŸ’Ž'))\nPY
""")

# ---------------- Manifest ----------------
manifest={}
for root,_,files in os.walk(BASE):
    for fn in files:
        p=os.path.join(root,fn)
        rel=os.path.relpath(p, BASE)
        manifest[rel]=sha256_file(p)
W("codex/manifest.json", json.dumps({"generated_utc": now, "files": manifest}, indent=2))

# ---------------- ZIP ----------------
zip_path="/mnt/data/codex_v219x_lambda_plus.zip"
with zipfile.ZipFile(zip_path,"w",zipfile.ZIP_DEFLATED) as z:
    for root,_,files in os.walk(BASE):
        for fn in files:
            fp=os.path.join(root,fn)
            z.write(fp, arcname=os.path.relpath(fp, BASE))

print("READY", zip_path, BASE)