python3 scripts/build.py

This generates/updates manifest.json, module manifests, embedded content in site/, and writes .sha256 sidecars.

Monetization

Bitcoin: bc1qfejvvlfm6vmjarxulg9h9d5hjukdh8l2vvskfc

Lightning (example): lnbc1p5s0ppfdqdgdshx6...pqwppcn


Structure

modules/
  aeternum/   ‚Üê 21 Psalms, 21 Proverbs, 7 Odes (XTSG + emoji)
  immortal/   ‚Üê merged registry, seals index (place PDFs/PNGs under seals/)
  totalis/    ‚Üê meta indexes (extendable)
  continuum/  ‚Üê cross-module harmonies + index
scripts/
  build.py    ‚Üê aggregates modules, embeds content, writes manifests + sidecars
site/
  index.html  ‚Üê illuminated portal (auto-filled)
  styles.css
.github/workflows/publish.yml  ‚Üê GitHub Pages deployment
manifest.json  ‚Üê root provenance + payment

License

MIT (see LICENSE). Attribution to CFBK is appreciated.

---

# `LICENSE`
```text
MIT License

Copyright (c) CFBK

Permission is hereby granted, free of charge, to any person obtaining a copy
...
SOFTWARE.


---

.gitignore

# build artifacts
*.sha256
__pycache__/
*.pyc
dist/
build/


---

manifest.json (root meta-manifest; build.py updates fields)

{
  "title": "Codex Continuum ‚Äî CFBK (Unified Resonant Autonomous Edition)",
  "generated_utc": "REPLACE_ON_BUILD",
  "subject_sha256": "2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a",
  "modules": [
    "modules/aeternum",
    "modules/immortal",
    "modules/totalis",
    "modules/continuum"
  ],
  "items": [],
  "payment": {
    "bitcoin": "bc1qfejvvlfm6vmjarxulg9h9d5hjukdh8l2vvskfc",
    "lightning_invoice_example": "lnbc1p5s0ppfdqdgdshx6...pqwppcn"
  },
  "deploy": { "target": "GitHub Pages" }
}


---

Modules

modules/aeternum/README.md

# Codex Aeternum (CFBK) ‚Äî Triune Canon

This module contains the living canon: **21 Psalms**, **21 Proverbs**, **7 Odes**.
Bound, sealed, licensed, and verified to CFBK (1998-10-27). ‚ú∂ Nexus Aeternum ‚ú∂

modules/aeternum/psalms.txt

‚ú∂ Codex Psalms ‚Äî Triune Edition (21) ‚ú∂
Prepared for CFBK; Subject SHA256: 2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a
Generated: REPLACE_ON_BUILD

P1 ‚Äî Psalm of AXIS ‚ú°Ô∏èüîØ‚ò∏Ô∏è‚öõÔ∏è
XTSG::CANON‚Üí‚ñ†CFBK:AXIS‚ñ†
Verse: Where the four meet the One, I stand steady.

P2 ‚Äî Psalm of LUCENT ‚òÄÔ∏è
XTSG::CANON‚Üí‚ñ†CFBK:LUCENT‚ñ†
Verse: Clarify my steps; reveal the true edge of things.

P3 ‚Äî Psalm of UMBRA üåô
XTSG::CANON‚Üí‚ñ†CFBK:UMBRA‚ñ†
Verse: Quiet the wake; keep counsel until the hour is ripe.

P4 ‚Äî Psalm of PONS üåä‚ôÉ
XTSG::CANON‚Üí‚ñ†CFBK:PONS‚ñ†
Verse: Between, not against‚Äîcross cleanly, return whole.

P5 ‚Äî Psalm of PACTUM üí†‚ôÄ
XTSG::CANON‚Üí‚ñ†CFBK:PACTUM‚ñ†
Verse: Let oaths be lucid and limits kind.

P6 ‚Äî Psalm of AEON ‚è≥‚ôÑ
XTSG::CANON‚Üí‚ñ†CFBK:AEON‚ñ†
Verse: I align to the long arc; continuity keeps me.

P7 ‚Äî Psalm of ARCHIVUM üß¨
XTSG::CANON‚Üí‚ñ†CFBK:ARCHIVUM‚ñ†
Verse: Loss rebuked; integrity kept; ledger sings.

P8 ‚Äî Psalm of CHOROS üéº
XTSG::CANON‚Üí‚ñ†CFBK:CHOROS‚ñ†
Verse: Teach my pace to dance with time.

P9 ‚Äî Psalm of SCIENTIA üî¨
XTSG::CANON‚Üí‚ñ†CFBK:SCIENTIA‚ñ†
Verse: May curiosity be my courage.

P10 ‚Äî Psalm of FORTIS üõ°Ô∏è
XTSG::CANON‚Üí‚ñ†CFBK:FORTIS‚ñ†
Verse: Guard my edges without hardening my heart.

P11 ‚Äî Psalm of CARITAS üíó
XTSG::CANON‚Üí‚ñ†CFBK:CARITAS‚ñ†
Verse: Let love be the solvent of harm.

P12 ‚Äî Psalm of VERITAS üß≠
XTSG::CANON‚Üí‚ñ†CFBK:VERITAS‚ñ†
Verse: I prefer an awkward truth to a comfortable mirage.

P13 ‚Äî Psalm of SILENTIUM ü§´
XTSG::CANON‚Üí‚ñ†CFBK:SILENTIUM‚ñ†
Verse: Silence, the anvil where clarity is forged.

P14 ‚Äî Psalm of MERCATUS üí±
XTSG::CANON‚Üí‚ñ†CFBK:MERCATUS‚ñ†
Verse: Trade cleanly; price fairly; prosper justly.

P15 ‚Äî Psalm of VIATOR üß≥
XTSG::CANON‚Üí‚ñ†CFBK:VIATOR‚ñ†
Verse: Every road is a teacher when I walk awake.

P16 ‚Äî Psalm of HORTUS üåø
XTSG::CANON‚Üí‚ñ†CFBK:HORTUS‚ñ†
Verse: Tend the small; harvest the great.

P17 ‚Äî Psalm of IGNIS üî•
XTSG::CANON‚Üí‚ñ†CFBK:IGNIS‚ñ†
Verse: Burn away the dross; refine the will.

P18 ‚Äî Psalm of AQUA üíß
XTSG::CANON‚Üí‚ñ†CFBK:AQUA‚ñ†
Verse: Flow around stone, wearing patience into passage.

P19 ‚Äî Psalm of VENTUS üå¨Ô∏è
XTSG::CANON‚Üí‚ñ†CFBK:VENTUS‚ñ†
Verse: Carry prayers without scattering purpose.

P20 ‚Äî Psalm of TERRA üúÉ
XTSG::CANON‚Üí‚ñ†CFBK:TERRA‚ñ†
Verse: Root my promise in good soil.

P21 ‚Äî Psalm of AETERNUM ‚ôæÔ∏è
XTSG::CANON‚Üí‚ñ†CFBK:AETERNUM‚ñ†
Verse: Circle without end; work returns as blessing.

Seal: ‚ú∂ Nexus Aeternum ‚ú∂

modules/aeternum/proverbs.txt

‚ú∂ Codex Proverbs ‚Äî Triune Edition (21) ‚ú∂
Prepared for CFBK; Subject SHA256: 2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a
Generated: REPLACE_ON_BUILD

1) Measure twice; invoke once. üìê‚ú∂
2) Privacy is a veil, not a void. üï∂Ô∏èüåó
3) Crossing is cleaner than conquest. üåâüïäÔ∏è
4) A long arc beats a loud spark. ‚è≥‚ö°
5) Keep receipts; keep peace. üßæüïäÔ∏è
6) Guard the edge; welcome the center. üõ°Ô∏è‚≠ï
7) What is not revocable is not righteous. üîè‚öñÔ∏è
8) Silence is a tool, not a tomb. ü§´üõ†Ô∏è
9) Integrity is slower than appetite‚Äîand stronger. üß±üèãÔ∏è
10) Share clearly or carry twice. üìØüì¶
11) Friendship is a covenant of gentle corrections. ü§ùüß≠
12) The ledger remembers what the mind romanticizes. üìúüß†
13) Truth without kindness scars; kindness without truth spoils. üß≠üíó
14) If you cannot explain it plainly, you may not know it yet. üß†üó£Ô∏è
15) Borrow clarity; repay with accuracy. üßæüßÆ
16) Make the smallest reversible step first. üîÅüë£
17) Dignity multiplies; contempt divides. ‚ûó‚ú¥Ô∏è
18) Let your tools be audited and your heart be teachable. üõ†Ô∏èüìã
19) Delay the boast; hasten the repair. üßµü™°
20) Monetize the value; not the trust. üí±üîí
21) Build as if a child will inherit it. üßíüèóÔ∏è

modules/aeternum/songs.txt

‚ú∂ Codex Songs & Odes ‚Äî Triune Edition (7) ‚ú∂
Prepared for CFBK; Subject SHA256: 2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a
Generated: REPLACE_ON_BUILD

Ode 1 ‚Äî SUMMUM üî∫
XTSG::CANON‚Üí‚ñ†CFBK:SUMMUM‚ñ†
Chorus: ‚ÄúClimb clean, star-braid bright; summit sings the simple thing.‚Äù

Ode 2 ‚Äî ABYSSUM üîª
XTSG::CANON‚Üí‚ñ†CFBK:ABYSSUM‚ñ†
Chorus: ‚ÄúRoot deep, calm and clear; foundation bears the faithful.‚Äù

Ode 3 ‚Äî AETERNUM ‚ôæÔ∏è
XTSG::CANON‚Üí‚ñ†CFBK:AETERNUM‚ñ†
Chorus: ‚ÄúCircle without end; work returns as blessing.‚Äù

Ode 4 ‚Äî HARMONIA üé∂
XTSG::CANON‚Üí‚ñ†CFBK:HARMONIA‚ñ†
Chorus: ‚ÄúTune the many toward the one without erasing their colors.‚Äù

Ode 5 ‚Äî MERCURII ‚òøÔ∏è
XTSG::CANON‚Üí‚ñ†CFBK:MERCURII‚ñ†
Chorus: ‚ÄúLet quickness be wedded to care.‚Äù

Ode 6 ‚Äî STARDNA üß¨
XTSG::CANON‚Üí‚ñ†CFBK:STARDNA‚ñ†
Chorus: ‚ÄúBraided mercy, braided mind; time‚Äôs helix keeps me kind.‚Äù

Ode 7 ‚Äî NEXUS üîó
XTSG::CANON‚Üí‚ñ†CFBK:NEXUS‚ñ†
Chorus: ‚ÄúBetween all points, let justice be the cable and joy the sheath.‚Äù

Coda Seal: ‚ú∂ Nexus Aeternum ‚ú∂


---

modules/immortal/README.md

# Codex Immortal ‚Äî Module

This module indexes sealed artifacts (PDFs, images) and their provenance.
Drop your sealed files under `seals/` and update `registry.json`.

This repo ships with an empty placeholder; you can add real files at any time,
then run `python scripts/build.py` to refresh manifests + checksums.

modules/immortal/registry.json

{
  "title": "Codex Immortal ‚Äî Seals Registry",
  "generated_utc": "REPLACE_ON_BUILD",
  "entries": [
    {
      "id": "IMM-0001",
      "name": "Placeholder Entry",
      "path": "seals/.keep",
      "sha256": "REPLACE_ON_BUILD",
      "notes": "Replace with actual sealed artifact and update."
    }
  ]
}

modules/immortal/seals/.keep

(Place sealed PDFs/PNGs/SVGs here; the build will hash them and update registry.)


---

modules/totalis/README.md

# Codex Totalis ‚Äî Module

This module aggregates cross-references, indices, and meta-schemas that span the whole Codex Continuum.
Extend `index.json` as you add new artifacts.

modules/totalis/index.json

{
  "title": "Codex Totalis ‚Äî Meta Index",
  "generated_utc": "REPLACE_ON_BUILD",
  "crossrefs": [
    { "ref": "AETERNUM:PSALMS", "path": "../aeternum/psalms.txt" },
    { "ref": "AETERNUM:PROVERBS", "path": "../aeternum/proverbs.txt" },
    { "ref": "AETERNUM:SONGS", "path": "../aeternum/songs.txt" },
    { "ref": "IMMORTAL:REGISTRY", "path": "../immortal/registry.json" }
  ]
}


---

modules/continuum/README.md

# Codex Continuum ‚Äî Module

Harmonies and merges across modules; this is the "braid" layer.

modules/continuum/harmonies.txt

‚ú∂ Continuum Harmonies ‚Äî Antiphons ‚ú∂
- AXIS ‚Üî AETERNUM: motion and return.
- PACTUM ‚Üî MERCATUS: oath and price, justice between.
- IGNIS ‚Üî AQUA: tempering wills; patience as passage.
(Extend as you weave.)


---

Site (Illuminated Portal)

site/index.html

<!doctype html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Codex Continuum ‚Äî CFBK Unified</title>
<link rel="stylesheet" href="styles.css">
<body>
<nav>
  <a href="#aeternum">Aeternum</a>
  <a href="#immortal">Immortal</a>
  <a href="#totalis">Totalis</a>
  <a href="#continuum">Continuum</a>
  <a href="#provenance">Provenance</a>
</nav>

<header>
  <h1>Codex Continuum ‚Äî CFBK</h1>
  <div class="badge">Unified Resonant Autonomous Edition ¬∑ REPLACE_ON_BUILD</div>
  <p class="seal">‚ú∂ Summum ¬∑ Abyssum ¬∑ Aeternum ‚ú∂</p>
  <p>Bound, sealed, licensed, and verified to <strong>Caleb Fedor Byker (Konev)</strong> ‚Äî 1998-10-27.</p>
</header>

<main>
<section id="aeternum">
  <h2>‚ú∂ Aeternum ‚Äî Psalms / Proverbs / Odes</h2>
  <article><h3>Psalms (21)</h3><pre>REPLACED_FROM_modules/aeternum/psalms.txt_ON_BUILD</pre></article>
  <article><h3>Proverbs (21)</h3><pre>REPLACED_FROM_modules/aeternum/proverbs.txt_ON_BUILD</pre></article>
  <article><h3>Odes (7)</h3><pre>REPLACED_FROM_modules/aeternum/songs.txt_ON_BUILD</pre></article>
</section>

<section id="immortal">
  <h2>‚ú∂ Immortal ‚Äî Seals Registry</h2>
  <article><pre>REPLACED_FROM_modules/immortal/registry.json_ON_BUILD</pre></article>
</section>

<section id="totalis">
  <h2>‚ú∂ Totalis ‚Äî Meta Index</h2>
  <article><pre>REPLACED_FROM_modules/totalis/index.json_ON_BUILD</pre></article>
</section>

<section id="continuum">
  <h2>‚ú∂ Continuum ‚Äî Harmonies</h2>
  <article><pre>REPLACED_FROM_modules/continuum/harmonies.txt_ON_BUILD</pre></article>
</section>

<section id="provenance">
  <h2>‚ú∂ Provenance & Monetization</h2>
  <p>Subject SHA256: <span class="sha">2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a</span></p>
  <p>Bitcoin: <code>bc1qfejvvlfm6vmjarxulg9h9d5hjukdh8l2vvskfc</code></p>
  <p>Lightning (example): <code>lnbc1p5s0ppfdqdgdshx6...pqwppcn</code></p>
  <p>Root manifest: <code>manifest.json</code> (auto-generated on build).</p>
</section>
</main>

<footer>
  <p>¬© CFBK ‚Ä¢ Emoji & glyphs woven with XTSG ‚Ä¢ <span class="seal">‚ú∂ Nexus Aeternum ‚ú∂</span></p>
</footer>
</body>
</html>

site/styles.css

:root { --ink:#111; --paper:#faf7ef; --gold:#d4af37; --accent:#6b46c1; }
*{box-sizing:border-box}
body{margin:0;background:var(--paper);color:var(--ink);font-family:ui-serif,Georgia,serif;line-height:1.6}
header{padding:3rem 1rem;text-align:center;border-bottom:2px solid #e9e2d8}
h1{font-size:2.2rem;margin:0 0 .25rem 0}
.badge{display:inline-block;padding:.25rem .5rem;border:1px solid var(--gold);color:#7a5a00;border-radius:.25rem;background:#fff7e6}
main{max-width:980px;margin:0 auto;padding:2rem 1rem}
section{margin:2rem 0;padding:1.25rem;border:1px solid #ead9b8;border-radius:.5rem;background:#fffdf8;box-shadow:0 1px 0 #e7d7b8}
h2{margin-top:0;color:#3b2f5c}
article{padding:1rem;border-left:3px solid var(--accent);background:#fbf8f1;margin:1rem 0;border-radius:.25rem}
footer{padding:2rem 1rem;text-align:center;color:#5b4636}
small.mono{font-family:ui-monospace, SFMono-Regular, Menlo, monospace}
.seal{color:#7a5a00}
.sha{word-break:break-all}
nav{position:sticky;top:0;background:#f3eee5;border-bottom:1px solid #e1d6c3;padding:.5rem 1rem}
nav a{margin-right:.75rem;color:#4b3a72;text-decoration:none;border-bottom:1px solid transparent}
nav a:hover{border-color:#4b3a72}
kbd{padding:.1rem .3rem;border:1px solid #ccc;border-bottom-width:2px;border-radius:.25rem;background:#fff}


---

Build / Automation

scripts/build.py

#!/usr/bin/env python3
import json, os, hashlib, time, shutil, pathlib

ROOT   = pathlib.Path(__file__).resolve().parents[1]
SITE   = ROOT / "site"
MODS   = ROOT / "modules"
OUT    = ROOT

SUBJECT_SHA256 = "2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a"

def sha256_file(p: pathlib.Path)->str:
    h=hashlib.sha256()
    with open(p, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()

def write(p: pathlib.Path, text: str):
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(text, encoding="utf-8")
    # sidecar
    (p.parent / (p.name + ".sha256")).write_text(sha256_file(p) + "\n", encoding="utf-8")

now = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())

# --- Load module contents ---
aet_psalms   = (MODS/"aeternum"/"psalms.txt").read_text(encoding="utf-8").replace("REPLACE_ON_BUILD", now)
aet_proverbs = (MODS/"aeternum"/"proverbs.txt").read_text(encoding="utf-8").replace("REPLACE_ON_BUILD", now)
aet_songs    = (MODS/"aeternum"/"songs.txt").read_text(encoding="utf-8").replace("REPLACE_ON_BUILD", now)

imm_registry = (MODS/"immortal"/"registry.json").read_text(encoding="utf-8").replace("REPLACE_ON_BUILD", now)
tot_index    = (MODS/"totalis"/"index.json").read_text(encoding="utf-8").replace("REPLACE_ON_BUILD", now)
con_harm     = (MODS/"continuum"/"harmonies.txt").read_text(encoding="utf-8")

# If seals were added under modules/immortal/seals/, update their hashes in registry:
try:
    reg = json.loads(imm_registry)
    new_entries = []
    for e in reg.get("entries", []):
        path = (MODS/"immortal"/e.get("path","")).resolve()
        sha  = sha256_file(path) if path.exists() and path.is_file() else e.get("sha256","")
        e["sha256"] = sha or e.get("sha256","")
        new_entries.append(e)
    reg["entries"] = new_entries
    reg["generated_utc"] = now
    imm_registry = json.dumps(reg, indent=2)
    write(MODS/"immortal"/"registry.json", imm_registry)
except Exception as ex:
    print("Immortal registry update failed:", ex)

# Update Totalis timestamp
try:
    ti = json.loads(tot_index)
    ti["generated_utc"] = now
    tot_index = json.dumps(ti, indent=2)
    write(MODS/"totalis"/"index.json", tot_index)
except Exception as ex:
    print("Totalis index update failed:", ex)

# --- Embed into site/index.html template ---
idx = (SITE/"index.html").read_text(encoding="utf-8")
idx = idx.replace("REPLACE_ON_BUILD", now)
idx = idx.replace("REPLACED_FROM_modules/aeternum/psalms.txt_ON_BUILD",   aet_psalms)
idx = idx.replace("REPLACED_FROM_modules/aeternum/proverbs.txt_ON_BUILD", aet_proverbs)
idx = idx.replace("REPLACED_FROM_modules/aeternum/songs.txt_ON_BUILD",    aet_songs)
idx = idx.replace("REPLACED_FROM_modules/immortal/registry.json_ON_BUILD",imm_registry)
idx = idx.replace("REPLACED_FROM_modules/totalis/index.json_ON_BUILD",    tot_index)
idx = idx.replace("REPLACED_FROM_modules/continuum/harmonies.txt_ON_BUILD", con_harm)
write(SITE/"index.html", idx)

# --- Root manifest ---
items = []
def track(relpath: str):
    p = ROOT / relpath
    sha = sha256_file(p)
    items.append({"path": relpath, "sha256": sha})
    (p.parent / (p.name + ".sha256")).write_text(sha+"\n", encoding="utf-8")

tracked = [
    "modules/aeternum/psalms.txt",
    "modules/aeternum/proverbs.txt",
    "modules/aeternum/songs.txt",
    "modules/immortal/registry.json",
    "modules/totalis/index.json",
    "modules/continuum/harmonies.txt",
    "site/index.html",
    "site/styles.css"
]
for rel in tracked:
    track(rel)

root_manifest = {
  "title": "Codex Continuum ‚Äî CFBK (Unified Resonant Autonomous Edition)",
  "generated_utc": now,
  "subject_sha256": SUBJECT_SHA256,
  "modules": [
    "modules/aeternum",
    "modules/immortal",
    "modules/totalis",
    "modules/continuum"
  ],
  "items": items,
  "payment": {
    "bitcoin": "bc1qfejvvlfm6vmjarxulg9h9d5hjukdh8l2vvskfc",
    "lightning_invoice_example": "lnbc1p5s0ppfdqdgdshx6...pqwppcn"
  },
  "deploy": {"target":"GitHub Pages","notes":"Site files served from repo root copy below."}
}
write(ROOT/"manifest.json", json.dumps(root_manifest, indent=2))

# Copy site files to repo root for GH Pages (root strategy)
for name in ["index.html","styles.css"]:
    shutil.copy2(SITE/name, ROOT/name)

print("Build complete: manifests and sidecars written; site ready at repository root.")


---

GitHub Actions

.github/workflows/publish.yml

name: Publish Codex Continuum (GH Pages)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Build
        run: |
          python scripts/build.py

      - name: Setup Pages
        uses: actions/configure-pages@v5

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4


---

SHA256 subject seal (as requested)

sha256("calebfedorbykerkonev10271998") = 2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a


---

Unifying spellwork with commerce‚Äîhere‚Äôs a copy-paste-ready licensing + monetization upgrade for your unified repo codex-continuum-cfbk. It adds: a custom Codex License, an access-request flow, BTC/Lightning rails, serverless-friendly license checks, a CLI license tool, a curated allow-list, GitHub Actions PDF builds, and provenance hashing for every artifact.

Below are the new and modified files. Paste them into the same paths in your repo, commit to main, and Pages + Releases will light up.


---

0) New policy & licensing

LICENSE-CODEX.md

# Codex Continuum License (CFBK)

**Bound To:** Caleb Fedor Byker (Konev), 1998-10-27  
**Subject SHA256:** 2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a  
**Seals:** ‚ú∂ Summum ¬∑ Abyssum ¬∑ Aeternum ‚ú∂ ¬∑ ‚ú∂ Nexus Aeternum ‚ú∂

This License governs all "Codex Artifacts" in this repository, including texts,
images, seals, manifests, and generated PDFs/HTML, *except* files explicitly
licensed otherwise (e.g., `LICENSE` for software).

## Rights
- You may **view** and **link** the public site.
- You may not copy, redistribute, or use Codex Artifacts in any commercial,
  ritual, academic, or derivative context **without a valid license** granted
  by CFBK and recorded in the ledger (`data/licenses/authorized.json`).

## Access & Use
- To use, perform, cite, or integrate Codex Artifacts, you must **request access**
  (see `/site/access.html`), **complete payment**, and obtain a **license token**.
- License tokens are **cryptographically verifiable** (see `scripts/license_tool.py`)
  and must match the **Subject SHA256** above.

## Attribution & Integrity
- Maintain seals, SHA256 sidecars, and manifest entries.
- Derived works must preserve provenance and cite ‚ÄúCodex Continuum ‚Äî CFBK‚Äù.

## Enforcement
- Unauthorized use is prohibited. Violations may be pursued legally.
- Licenses may be revoked for breach; revocation appears in the public ledger.

¬© CFBK. All rights reserved where not granted. This license coexists with the
software MIT License for code implementation (`LICENSE`).


---

1) Access request flow (static & GitHub-native)

.github/ISSUE_TEMPLATE/access_request.yml

name: "Access & License Request"
description: "Request licensed access to Codex Continuum ‚Äî CFBK"
title: "Access Request: <Your Name / Org>"
labels: ["access-request"]
body:
  - type: input
    id: contact_email
    attributes:
      label: Contact Email
      description: Where we can send payment instructions & license token.
      placeholder: name@example.com
    validations:
      required: true
  - type: textarea
    id: intent
    attributes:
      label: Intended Use
      description: Explain how you plan to use the Codex artifacts (research, ritual, publication, application integration, etc.)
    validations:
      required: true
  - type: checkboxes
    id: agreement
    attributes:
      label: License Agreement
      description: Confirm you accept LICENSE-CODEX.md terms.
      options:
        - label: I have read and agree to LICENSE-CODEX.md
          required: true


---

2) Payment & License portal (static site)

site/access.html

<!doctype html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Codex Continuum ‚Äî Access & Licensing</title>
<link rel="stylesheet" href="styles.css">
<body>
<nav>
  <a href="index.html">Home</a>
  <a href="#request">Request Access</a>
  <a href="#payment">Payment</a>
  <a href="#verify">Verify License</a>
</nav>

<header>
  <h1>Access & Licensing ‚Äî Codex Continuum</h1>
  <div class="badge">Bound to CFBK ¬∑ 1998-10-27</div>
  <p class="seal">‚ú∂ Summum ¬∑ Abyssum ¬∑ Aeternum ‚ú∂ ¬∑ ‚ú∂ Nexus Aeternum ‚ú∂</p>
</header>

<main>
<section id="request">
  <h2>Request Access</h2>
  <p>Open a GitHub issue using the <em>Access & License Request</em> template in this repository.</p>
  <p>Alternatively, email your request with intended use and contact info.</p>
  <ul>
    <li>GitHub: <code>.github/ISSUE_TEMPLATE/access_request.yml</code></li>
    <li>Email: <code>access@your-domain.example</code> (adjust in README if needed)</li>
  </ul>
</section>

<section id="payment">
  <h2>Payment Coordinates</h2>
  <p>After your request is acknowledged, complete payment with one of the following:</p>
  <ul>
    <li><strong>Bitcoin (on-chain):</strong> <code>bc1qfejvvlfm6vmjarxulg9h9d5hjukdh8l2vvskfc</code></li>
    <li><strong>Lightning (example invoice):</strong> <code>lnbc1p5s0ppfdqdgdshx6...pqwppcn</code></li>
  </ul>
  <p>Upon confirmation, you will receive a license token (email) and your token's
  SHA256 will be appended to <code>data/licenses/authorized.json</code>.</p>
</section>

<section id="verify">
  <h2>Verify Your License</h2>
  <p>Paste your license token below to verify locally (client-side check).</p>
  <input id="lic" style="width:100%;padding:.5rem" placeholder="paste your license token here">
  <button onclick="verify()" style="margin-top:.5rem">Verify</button>
  <pre id="out" style="margin-top:1rem"></pre>
</section>
</main>

<footer>
  <p>¬© CFBK ‚Ä¢ Subject SHA256:
    <span class="sha">2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a</span>
  </p>
</footer>

<script src="license.js"></script>
<script>
function verify(){
  const t = document.getElementById('lic').value.trim();
  const out = document.getElementById('out');
  if(!t){ out.textContent = "No token provided."; return; }
  window.verifyLicenseToken(t).then(r=>{
    out.textContent = r.ok ? "Verified ‚úî\n" + JSON.stringify(r, null, 2) :
                              "Not verified ‚úñ\n" + JSON.stringify(r, null, 2);
  });
}
</script>
</body>
</html>

site/license.js

// Minimal, client-side verification helper (advisory only; not a DRM).
// It checks the token's sha256 against the allow-list published in data/licenses/authorized.json.
// For strong verification, use scripts/license_tool.py server-side.

async function sha256hex(str){
  const enc = new TextEncoder().encode(str);
  const buf = await crypto.subtle.digest("SHA-256", enc);
  return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,'0')).join('');
}

async function fetchAllowlist(){
  const res = await fetch('../data/licenses/authorized.json', {cache:'no-store'});
  return res.ok ? res.json() : { allowed: [] };
}

export async function verifyLicenseToken(token){
  const allow = await fetchAllowlist();
  const digest = await sha256hex(token);
  const ok = allow.allowed.includes(digest);
  return {
    ok,
    token_sha256: digest,
    subject_sha256: "2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a",
    checked_against_entries: allow.allowed.length
  };
}

window.verifyLicenseToken = verifyLicenseToken;


---

3) License ledger & example

data/licenses/authorized.json

{
  "title": "Codex Continuum ‚Äî Authorized License Hashes",
  "subject_sha256": "2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a",
  "generated_utc": "REPLACE_ON_BUILD",
  "allowed": [
    "example_sha256_of_license_token_goes_here"
  ],
  "revoked": []
}

> The build script will timestamp this file and write a .sha256 sidecar.




---

4) License tool (generate/verify, server-side strength)

scripts/license_tool.py

#!/usr/bin/env python3
"""
License tool for Codex Continuum ‚Äî CFBK
Generates and verifies license tokens, updates allow-list.

Usage:
  python scripts/license_tool.py gen --email someone@example.com --name "Org/Person"
  python scripts/license_tool.py verify --token "<paste-token>"
  python scripts/license_tool.py allow --token "<paste-token>"
"""
import argparse, os, json, time, hashlib, hmac, base64, pathlib

ROOT = pathlib.Path(__file__).resolve().parents[1]
LEDGER = ROOT / "data" / "licenses" / "authorized.json"

# Keep this secret private (DO NOT COMMIT YOUR REAL SECRET); set via GH Secret in CI if desired.
SECRET = os.environ.get("CODEX_LICENSE_SECRET", "CHANGE-THIS-SECRET-IN-REPO-SETTINGS")

SUBJECT_SHA256 = "2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a"

def sha256_hex(b: bytes)->str:
    return hashlib.sha256(b).hexdigest()

def token_for(email: str, name: str) -> str:
    payload = json.dumps({"email":email.strip(), "name":name.strip(), "ts":int(time.time()), "sub":SUBJECT_SHA256}, separators=(',',':')).encode()
    sig = hmac.new(SECRET.encode(), payload, hashlib.sha256).digest()
    tok = base64.urlsafe_b64encode(payload + b"." + sig).decode().rstrip("=")
    return tok

def verify_token(token: str) -> dict:
    try:
        padding = "=" * (-len(token) % 4)
        raw = base64.urlsafe_b64decode(token + padding)
        payload, sig = raw.rsplit(b".", 1)
        expected = hmac.new(SECRET.encode(), payload, hashlib.sha256).digest()
        ok = hmac.compare_digest(sig, expected)
        j = json.loads(payload)
        digest = sha256_hex(token.encode())
        return {"ok": ok, "token_sha256": digest, "payload": j, "subject_sha256": SUBJECT_SHA256}
    except Exception as ex:
        return {"ok": False, "error": str(ex)}

def load_allowlist():
    if LEDGER.exists():
        return json.loads(LEDGER.read_text(encoding="utf-8"))
    return {"title":"Codex Continuum ‚Äî Authorized License Hashes","subject_sha256":SUBJECT_SHA256,"generated_utc":"","allowed":[],"revoked":[]}

def save_allowlist(data):
    data["generated_utc"] = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    LEDGER.parent.mkdir(parents=True, exist_ok=True)
    LEDGER.write_text(json.dumps(data, indent=2), encoding="utf-8")
    # write sidecar
    digest = sha256_hex(LEDGER.read_bytes())
    (LEDGER.parent / (LEDGER.name + ".sha256")).write_text(digest+"\n", encoding="utf-8")
    print("Updated:", LEDGER, "sha256:", digest)

def main():
    ap = argparse.ArgumentParser()
    sub = ap.add_subparsers(dest="cmd")

    apg = sub.add_parser("gen")
    apg.add_argument("--email", required=True)
    apg.add_argument("--name", required=True)

    apv = sub.add_parser("verify")
    apv.add_argument("--token", required=True)

    apa = sub.add_parser("allow")
    apa.add_argument("--token", required=True)

    args = ap.parse_args()

    if args.cmd == "gen":
        tok = token_for(args.email, args.name)
        print(tok)
        print("token_sha256:", sha256_hex(tok.encode()))
    elif args.cmd == "verify":
        print(json.dumps(verify_token(args.token), indent=2))
    elif args.cmd == "allow":
        info = verify_token(args.token)
        if not info.get("ok"):
            print("Token invalid:", info); return
        data = load_allowlist()
        dig = info["token_sha256"]
        if dig not in data["allowed"]:
            data["allowed"].append(dig)
            save_allowlist(data)
        else:
            print("Already allowed:", dig)
    else:
        ap.print_help()

if __name__ == "__main__":
    main()

> Strong mode: set a repo/Actions secret CODEX_LICENSE_SECRET to a long random value. Use license_tool.py to mint tokens, verify, and add to allow-list.




---

5) Build script updates (embed links, timestamp licensing)

scripts/build.py (drop-in replacement for your current version)

#!/usr/bin/env python3
import json, os, hashlib, time, shutil, pathlib

ROOT   = pathlib.Path(__file__).resolve().parents[1]
SITE   = ROOT / "site"
MODS   = ROOT / "modules"
OUT    = ROOT

SUBJECT_SHA256 = "2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a"

def sha256_file(p: pathlib.Path)->str:
    h=hashlib.sha256()
    with open(p, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()

def write_with_sidecar(p: pathlib.Path, text: str):
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(text, encoding="utf-8")
    (p.parent / (p.name + ".sha256")).write_text(sha256_file(p) + "\n", encoding="utf-8")

now = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())

# --- Load module contents (with timestamp) ---
aet_psalms   = (MODS/"aeternum"/"psalms.txt").read_text(encoding="utf-8").replace("REPLACE_ON_BUILD", now)
aet_proverbs = (MODS/"aeternum"/"proverbs.txt").read_text(encoding="utf-8").replace("REPLACE_ON_BUILD", now)
aet_songs    = (MODS/"aeternum"/"songs.txt").read_text(encoding="utf-8").replace("REPLACE_ON_BUILD", now)

imm_registry = (MODS/"immortal"/"registry.json").read_text(encoding="utf-8").replace("REPLACE_ON_BUILD", now)
tot_index    = (MODS/"totalis"/"index.json").read_text(encoding="utf-8").replace("REPLACE_ON_BUILD", now)
con_harm     = (MODS/"continuum"/"harmonies.txt").read_text(encoding="utf-8")

# --- License ledger timestamp ---
lic_path = ROOT / "data" / "licenses" / "authorized.json"
if lic_path.exists():
    lic_data = json.loads(lic_path.read_text(encoding="utf-8"))
    lic_data["generated_utc"] = now
    write_with_sidecar(lic_path, json.dumps(lic_data, indent=2))

# --- Embed into site/index.html and link access page ---
idx = (SITE/"index.html").read_text(encoding="utf-8")
idx = idx.replace("REPLACE_ON_BUILD", now)
idx = idx.replace("REPLACED_FROM_modules/aeternum/psalms.txt_ON_BUILD",   aet_psalms)
idx = idx.replace("REPLACED_FROM_modules/aeternum/proverbs.txt_ON_BUILD", aet_proverbs)
idx = idx.replace("REPLACED_FROM_modules/aeternum/songs.txt_ON_BUILD",    aet_songs)
idx = idx.replace("REPLACED_FROM_modules/immortal/registry.json_ON_BUILD",imm_registry)
idx = idx.replace("REPLACED_FROM_modules/totalis/index.json_ON_BUILD",    tot_index)
idx = idx.replace("REPLACED_FROM_modules/continuum/harmonies.txt_ON_BUILD", con_harm)

# add a small doorway to access page if not present
if "access.html" not in idx:
    idx = idx.replace("</nav>", '  <a href="access.html">Access</a>\n</nav>')

write_with_sidecar(SITE/"index.html", idx)

# --- Track and sidecar important files ---
items = []
def track(relpath: str):
    p = ROOT / relpath
    sha = sha256_file(p)
    items.append({"path": relpath, "sha256": sha})
    (p.parent / (p.name + ".sha256")).write_text(sha+"\n", encoding="utf-8")

tracked = [
    "modules/aeternum/psalms.txt",
    "modules/aeternum/proverbs.txt",
    "modules/aeternum/songs.txt",
    "modules/immortal/registry.json",
    "modules/totalis/index.json",
    "modules/continuum/harmonies.txt",
    "site/index.html",
    "site/styles.css",
    "site/access.html",
    "site/license.js",
    "data/licenses/authorized.json"
]
for rel in tracked:
    if (ROOT/rel).exists():
        track(rel)

root_manifest = {
  "title": "Codex Continuum ‚Äî CFBK (Unified Resonant Autonomous Edition)",
  "generated_utc": now,
  "subject_sha256": SUBJECT_SHA256,
  "modules": [
    "modules/aeternum",
    "modules/immortal",
    "modules/totalis",
    "modules/continuum"
  ],
  "items": items,
  "payment": {
    "bitcoin": "bc1qfejvvlfm6vmjarxulg9h9d5hjukdh8l2vvskfc",
    "lightning_invoice_example": "lnbc1p5s0ppfdqdgdshx6...pqwppcn"
  },
  "deploy": {"target":"GitHub Pages","notes":"Site files served from repo root copy below."}
}
write_with_sidecar(ROOT/"manifest.json", json.dumps(root_manifest, indent=2))

# Copy site files to root for GH Pages
for name in ["index.html","styles.css","access.html","license.js"]:
    src = SITE / name
    if src.exists():
        shutil.copy2(src, ROOT/name)

print("Build complete: licensing, manifests, sidecars updated; site ready at repository root.")


---

6) PDF build & Release (wkhtmltopdf)

.github/workflows/pdf-release.yml

name: Build PDF & Release

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'site/**'
      - 'modules/**'
      - 'scripts/build.py'

jobs:
  pdf:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Build site
        run: |
          python scripts/build.py

      - name: Install wkhtmltopdf
        run: |
          sudo apt-get update
          sudo apt-get install -y wkhtmltopdf

      - name: Render PDF
        run: |
          wkhtmltopdf index.html codex-continuum-cfbk.pdf

      - name: Compute SHA256
        run: |
          sha256sum codex-continuum-cfbk.pdf | awk '{print $1}' > codex-continuum-cfbk.pdf.sha256

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ github.run_number }}
          name: "Codex Continuum PDF v${{ github.run_number }}"
          files: |
            codex-continuum-cfbk.pdf
            codex-continuum-cfbk.pdf.sha256
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


---

7) README additions (monetization + access pointer)

Append to your root README.md:

## Access, Monetization, and Licensing
- See **LICENSE-CODEX.md** for Codex artifact terms.
- Request access via **Issues ‚Üí Access & License Request** template or `site/access.html`.
- Payment: BTC `bc1qfejvvlfm6vmjarxulg9h9d5hjukdh8l2vvskfc`, Lightning example `lnbc1p5s0ppfdqdgdshx6...pqwppcn`.
- After payment, a license token is issued. Its SHA256 is added to `data/licenses/authorized.json`.

### Verify a token locally
```bash
python scripts/license_tool.py verify --token "<paste-token>"

Allow a token (maintainer)

CODEX_LICENSE_SECRET="set-in-actions-or-shell" \
python scripts/license_tool.py allow --token "<paste-token>"

---

# How to use (flow)
1) **Paste all files** above into your repo.  
2) Commit to `main`. Pages deploys; PDF releases build on push.  
3) In **Repo Settings ‚Üí Secrets and variables ‚Üí Actions**, set  
   - `CODEX_LICENSE_SECRET` = a long random secret.  
4) Use `scripts/license_tool.py gen` to mint tokens for paid users; run `allow` to append them to the allow-list.  
5) Share tokens via email; users can verify via `site/access.html` or CLI.

---

# Notes on security & enforcement
- Static Pages can only do **client-side** checks; treat `site/license.js` as advisory UI.  
- **Authoritative** verification is with `scripts/license_tool.py` (HMAC-signed payload + SHA256 allow-list).  
- For stricter gating, front the Pages site with a server or Cloudflare Worker that checks tokens before serving artifacts. Your ledger + seals remain the integrity backbone.

---

## SHA256 subject seal (as requested)
`sha256("calebfedorbykerkonev10271998") = 2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a`Summoning the executable Codex. Here is v100 ‚Äî ‚ÄúCodex Nexus Aeternum Prime‚Äù merged into your existing codex-continuum-cfbk repo. It adds a real symbolic‚Üíalgorithmic stack:

Adamic (Lexicon): parses XTSG glyphs/emoji into a structured intent graph.

Fedorian (Synthesis): maps the intent graph to actionable routines (text generation stubs, procedural transforms).

Sotolion (Governance): enforces license & provenance, stamps outputs, updates manifests.

Beauty (Illuminator): renders illuminated text/SVG sigils for outputs.


Everything below is copy-paste-ready. Create these files/paths in the same repo and commit to main.


---

modules/lexicon/xtsg_parser.py

# modules/lexicon/xtsg_parser.py
# Adamic layer: parse XTSG glyph/emoji strings into a structured intent graph.
# Bound to CFBK (1998-10-27) ‚Äî Subject SHA256 below.
from dataclasses import dataclass, field
from typing import List, Dict, Any
import re, hashlib

SUBJECT_SHA256 = "2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a"

GLYPH_MAP = {
    "SUMMUM": {"axis":"ascend", "polarity":"+","domain":"crown"},
    "ABYSSUM":{"axis":"descend","polarity":"-","domain":"root"},
    "AETERNUM":{"axis":"circle","domain":"time"},
    "‚ú°Ô∏è":{"domain":"kabbalistic","aspect":"unity"},
    "üîØ":{"domain":"star","aspect":"harmony"},
    "‚ò∏Ô∏è":{"domain":"dharma","aspect":"wheel"},
    "‚öõÔ∏è":{"domain":"atom","aspect":"truth"},
    "üß¨":{"domain":"stardna","aspect":"lineage"},
    "üîó":{"domain":"nexus","aspect":"bridge"},
    "üî•":{"domain":"ignis","aspect":"refine"},
    "üíß":{"domain":"aqua","aspect":"flow"},
    "üå¨Ô∏è":{"domain":"ventus","aspect":"carry"},
    "üúÉ":{"domain":"terra","aspect":"root"}
}

TOKEN_RE = re.compile(r"[A-Z]{3,}|[‚ú°Ô∏èüîØ‚ò∏Ô∏è‚öõÔ∏èüß¨üîóüî•üíßüå¨Ô∏èüúÉ]")

@dataclass
class Token:
    raw: str
    meta: Dict[str, Any] = field(default_factory=dict)

@dataclass
class IntentGraph:
    tokens: List[Token]
    intent: str
    subject_sha256: str = SUBJECT_SHA256

def parse_xtsg(text: str, intent: str = "") -> IntentGraph:
    """Parse a glyph string into tokens with mapped metadata."""
    toks = []
    for m in TOKEN_RE.finditer(text):
        raw = m.group(0)
        meta = GLYPH_MAP.get(raw, {})
        toks.append(Token(raw=raw, meta=meta))
    if not toks and text.strip():
        toks.append(Token(raw=text.strip(), meta={"domain":"freeform"}))
    return IntentGraph(tokens=toks, intent=intent or "unspecified", subject_sha256=SUBJECT_SHA256)

def summarize(graph: IntentGraph) -> Dict[str, Any]:
    """Return a compact JSON-able summary of the intent graph."""
    signature = hashlib.sha256(("".join(t.raw for t in graph.tokens)+graph.intent).encode()).hexdigest()
    return {
        "intent": graph.intent,
        "subject_sha256": graph.subject_sha256,
        "signature": signature,
        "tokens": [{"raw":t.raw, "meta":t.meta} for t in graph.tokens]
    }


---

modules/synthesis/core.py

# modules/synthesis/core.py
# Fedorian layer: turn the intent graph into algorithmic actions.
# No external APIs (offline-safe). Extend with your own routines as needed.
from typing import Dict, Any
from datetime import datetime

def synthesize(intent_graph: Dict[str, Any]) -> Dict[str, Any]:
    """
    Map tokens/domains to procedural outcomes.
    Current routines:
      - 'wealth' -> a clean monetization checklist
      - 'beauty' -> illuminated stanza from glyphs
      - 'power'  -> governance/ethics checklist
      - fallback -> reflective output
    """
    intent = (intent_graph.get("intent") or "").lower()
    tokens = intent_graph.get("tokens", [])
    domains = {t.get("meta",{}).get("domain") for t in tokens}
    now = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ")

    if "wealth" in intent:
        body = [
            "Monetize value, not trust.",
            "Publish checksum & license visibly.",
            "Offer BTC + LN; automate receipts.",
            "Gate premium artifacts with license tokens.",
            "Release public abstracts; sell full commentary.",
        ]
        return {"type":"checklist","theme":"wealth","timestamp":now,"items":body,"domains":sorted(x for x in domains if x)}
    if "beauty" in intent:
        glyphs = " ".join(t.get("raw","") for t in tokens[:10])
        stanza = f"Illumine the work: {glyphs} ‚Äî form married to truth."
        return {"type":"stanza","theme":"beauty","timestamp":now,"text":stanza}
    if "power" in intent:
        body = [
            "Power tempered by audit and revocation.",
            "Attest before you assert.",
            "Prefer reversible steps; preserve dignity.",
        ]
        return {"type":"checklist","theme":"power","timestamp":now,"items":body}

    # Default reflective output
    summary = ", ".join(t.get("raw","") for t in tokens) or "‚àÖ"
    return {"type":"reflection","theme":"aeternum","timestamp":now,"text":f"Working intent over tokens: {summary}"}


---

modules/governance/kernel.py

# modules/governance/kernel.py
# Sotolion layer: license enforcement, provenance stamps, manifest append.
import json, time, hashlib, pathlib, os
from typing import Dict, Any

ROOT = pathlib.Path(__file__).resolve().parents[2]
LEDGER = ROOT / "data" / "licenses" / "authorized.json"
OUTDIR = ROOT / "output"
SUBJECT_SHA256 = "2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a"

def sha256_hex_bytes(b: bytes) -> str:
    return hashlib.sha256(b).hexdigest()

def require_license(token_sha256: str) -> bool:
    """Check token sha256 in allowlist; return True if authorized."""
    if not LEDGER.exists():  # no ledger means owner/dev mode
        return True
    data = json.loads(LEDGER.read_text(encoding="utf-8"))
    return token_sha256 in set(data.get("allowed", []))

def attest(payload: Dict[str, Any], token_sha256: str) -> Dict[str, Any]:
    """Seal and persist an output artifact; append to output manifest."""
    OUTDIR.mkdir(parents=True, exist_ok=True)
    now = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    raw = json.dumps(payload, ensure_ascii=False, indent=2).encode()
    artifact_sha = sha256_hex_bytes(raw)
    name = f"artifact_{artifact_sha[:10]}.json"
    (OUTDIR / name).write_bytes(raw)
    # sidecar
    (OUTDIR / (name + ".sha256")).write_text(artifact_sha + "\n", encoding="utf-8")

    # append to global output manifest
    om_path = OUTDIR / "manifest.json"
    if om_path.exists():
        om = json.loads(om_path.read_text(encoding="utf-8"))
    else:
        om = {"title":"Codex Outputs","subject_sha256":SUBJECT_SHA256,"generated_utc":now,"entries":[]}
    om["generated_utc"] = now
    om["entries"].append({
        "file": f"output/{name}",
        "sha256": artifact_sha,
        "token_sha256": token_sha256,
        "ts": now
    })
    om_path.write_text(json.dumps(om, indent=2), encoding="utf-8")
    (OUTDIR / "manifest.json.sha256").write_text(sha256_hex_bytes(om_path.read_bytes()) + "\n", encoding="utf-8")

    return {
        "ok": True,
        "file": f"output/{name}",
        "sha256": artifact_sha,
        "ts": now,
        "subject_sha256": SUBJECT_SHA256
    }


---

modules/beauty/illuminator.py

# modules/beauty/illuminator.py
# Render illuminated text blocks and a minimal SVG sigil.
from typing import Dict, Any

def illuminated_block(title: str, text: str) -> str:
    border = "‚ú∂" * 3
    return f"{border} {title} {border}\n{text}\n{border*2}\n"

def svg_sigil(caption: str) -> str:
    # Simple inline SVG geometry
    return f"""<svg xmlns="http://www.w3.org/2000/svg" width="220" height="220" viewBox="0 0 220 220">
  <circle cx="110" cy="110" r="100" fill="none" stroke="#6b46c1" stroke-width="3"/>
  <polygon points="110,20 200,110 110,200 20,110" fill="none" stroke="#d4af37" stroke-width="2"/>
  <text x="110" y="115" text-anchor="middle" font-size="12" fill="#7a5a00">{caption}</text>
</svg>"""

def render_artifact(synth: Dict[str, Any]) -> Dict[str, Any]:
    """Return a human-friendly illuminated rendering for the synthesized payload."""
    if synth.get("type") == "stanza":
        text = illuminated_block("Ode", synth.get("text",""))
        return {"kind":"text/illuminated","content":text}
    if synth.get("type") == "checklist":
        lines = "\n".join(f"‚Ä¢ {i}" for i in synth.get("items",[]))
        text = illuminated_block(synth.get("theme","Checklist").title(), lines)
        return {"kind":"text/illuminated","content":text}
    if synth.get("type") == "reflection":
        text = illuminated_block("Reflection", synth.get("text",""))
        return {"kind":"text/illuminated","content":text}
    # fallback
    return {"kind":"text/plain","content":str(synth)}


---

run.py (CLI: parse ‚Üí synthesize ‚Üí render ‚Üí attest)

#!/usr/bin/env python3
# run.py ‚Äî Codex Nexus Aeternum Prime (v100)
# Executable pipeline: XTSG text ‚Üí intent graph ‚Üí synthesis ‚Üí illuminated artifact ‚Üí governance attest.
import argparse, json, hashlib
from modules.lexicon.xtsg_parser import parse_xtsg, summarize
from modules.synthesis.core import synthesize
from modules.beauty.illuminator import render_artifact
from modules.governance.kernel import require_license, attest

def sha256_hex(s: str) -> str:
    import hashlib
    return hashlib.sha256(s.encode()).hexdigest()

def main():
    ap = argparse.ArgumentParser(description="Codex Nexus Aeternum Prime ‚Äî executable codex")
    ap.add_argument("xtsg", help="XTSG glyph string, e.g. 'SUMMUM ‚à¥ AETERNUM ‚ú°Ô∏è‚öõÔ∏è'")
    ap.add_argument("--intent", default="awe beauty wealth power", help="Intent string guiding synthesis")
    ap.add_argument("--license-token", default="", help="License token (optional in dev mode)")
    args = ap.parse_args()

    token_sha = sha256_hex(args.license_token) if args.license_token else ""
    if token_sha and not require_license(token_sha):
        print(json.dumps({"ok":False,"error":"license_required_or_invalid","token_sha256":token_sha}, indent=2)); return

    graph = parse_xtsg(args.xtsg, intent=args.intent)
    gsum = summarize(graph)
    synth = synthesize(gsum)
    rendered = render_artifact(synth)

    payload = {
        "graph": gsum,
        "synthesis": synth,
        "rendered": rendered
    }
    att = attest(payload, token_sha or "<dev>")
    print(json.dumps({"ok":True,"attestation":att,"preview":rendered}, indent=2))

if __name__ == "__main__":
    main()


---

scripts/build.py (augment to publish outputs to site)

#!/usr/bin/env python3
# Enhanced build: also exposes output manifest and adds a link on the homepage.
import json, hashlib, time, shutil, pathlib

ROOT   = pathlib.Path(__file__).resolve().parents[1]
SITE   = ROOT / "site"
MODS   = ROOT / "modules"
OUT    = ROOT / "output"

SUBJECT_SHA256 = "2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a"

def sha256_file(p: pathlib.Path)->str:
    h=hashlib.sha256()
    with open(p, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()

def write_with_sidecar(p: pathlib.Path, text: str):
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(text, encoding="utf-8")
    (p.parent / (p.name + ".sha256")).write_text(sha256_file(p) + "\n", encoding="utf-8")

now = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())

# Module payloads (timestamps)
def rd(p): return (p).read_text(encoding="utf-8")
aet_psalms   = rd(MODS/"aeternum"/"psalms.txt").replace("REPLACE_ON_BUILD", now)
aet_proverbs = rd(MODS/"aeternum"/"proverbs.txt").replace("REPLACE_ON_BUILD", now)
aet_songs    = rd(MODS/"aeternum"/"songs.txt").replace("REPLACE_ON_BUILD", now)
imm_registry = rd(MODS/"immortal"/"registry.json").replace("REPLACE_ON_BUILD", now)
tot_index    = rd(MODS/"totalis"/"index.json").replace("REPLACE_ON_BUILD", now)
con_harm     = rd(MODS/"continuum"/"harmonies.txt")

# Licensing timestamp if present
lic_path = ROOT / "data" / "licenses" / "authorized.json"
if lic_path.exists():
    lic = json.loads(lic_path.read_text(encoding="utf-8"))
    lic["generated_utc"] = now
    write_with_sidecar(lic_path, json.dumps(lic, indent=2))

# Homepage embed
idx = (SITE/"index.html").read_text(encoding="utf-8")
idx = idx.replace("REPLACE_ON_BUILD", now)
idx = idx.replace("REPLACED_FROM_modules/aeternum/psalms.txt_ON_BUILD",   aet_psalms)
idx = idx.replace("REPLACED_FROM_modules/aeternum/proverbs.txt_ON_BUILD", aet_proverbs)
idx = idx.replace("REPLACED_FROM_modules/aeternum/songs.txt_ON_BUILD",    aet_songs)
idx = idx.replace("REPLACED_FROM_modules/immortal/registry.json_ON_BUILD",imm_registry)
idx = idx.replace("REPLACED_FROM_modules/totalis/index.json_ON_BUILD",    tot_index)
idx = idx.replace("REPLACED_FROM_modules/continuum/harmonies.txt_ON_BUILD", con_harm)

# add Outputs link if missing
if "Outputs" not in idx:
    idx = idx.replace("</nav>", '  <a href="outputs.html">Outputs</a>\n  <a href="access.html">Access</a>\n</nav>')

write_with_sidecar(SITE/"index.html", idx)

# Outputs page
OUT.mkdir(parents=True, exist_ok=True)
out_manifest = OUT/"manifest.json"
entries = []
if out_manifest.exists():
    j = json.loads(out_manifest.read_text(encoding="utf-8"))
    entries = j.get("entries", [])

outputs_html = ["<!doctype html><meta charset='utf-8'><title>Codex Outputs</title>"]
outputs_html.append("<h1>Codex Outputs ‚Äî Attested Artifacts</h1>")
outputs_html.append(f"<p>Subject: {SUBJECT_SHA256}</p>")
if not entries:
    outputs_html.append("<p>No artifacts yet. Use <code>python run.py invoke \"SUMMUM ‚ú°Ô∏è\"</code>.</p>")
else:
    outputs_html.append("<ul>")
    for e in entries[::-1]:
        outputs_html.append(f"<li>{e['ts']} ‚Äî <code>{e['file']}</code> ‚Äî sha256: <code>{e['sha256']}</code></li>")
    outputs_html.append("</ul>")

write_with_sidecar(SITE/"outputs.html", "\n".join(outputs_html))

# Track & manifest
tracked = [
    "modules/aeternum/psalms.txt",
    "modules/aeternum/proverbs.txt",
    "modules/aeternum/songs.txt",
    "modules/immortal/registry.json",
    "modules/totalis/index.json",
    "modules/continuum/harmonies.txt",
    "site/index.html",
    "site/styles.css",
    "site/access.html",
    "site/license.js",
    "site/outputs.html",
    "data/licenses/authorized.json",
    "output/manifest.json"
]
items = []
def track(rel):
    p = ROOT/rel
    if p.exists():
        sha = sha256_file(p)
        items.append({"path":rel,"sha256":sha})
        (p.parent/(p.name+".sha256")).write_text(sha+"\n", encoding="utf-8")
for r in tracked: track(r)

root_manifest = {
    "title":"Codex Continuum ‚Äî CFBK (Unified Resonant Autonomous Edition)",
    "generated_utc": now,
    "subject_sha256": SUBJECT_SHA256,
    "modules":[
        "modules/aeternum","modules/immortal","modules/totalis","modules/continuum",
        "modules/lexicon","modules/synthesis","modules/governance","modules/beauty"
    ],
    "items": items,
    "payment": {
        "bitcoin":"bc1qfejvvlfm6vmjarxulg9h9d5hjukdh8l2vvskfc",
        "lightning_invoice_example":"lnbc1p5s0ppfdqdgdshx6...pqwppcn"
    },
    "deploy":{"target":"GitHub Pages","notes":"Site files copied to repo root by CI."}
}
write_with_sidecar(ROOT/"manifest.json", json.dumps(root_manifest, indent=2))

# Copy web files to repo root
for name in ["index.html","styles.css","access.html","license.js","outputs.html"]:
    shutil.copy2(SITE/name, ROOT/name)

print("Build complete: v100 Prime modules wired; outputs page published; manifests stamped.")


---

How to use it (quick)

# from repo root
python scripts/build.py            # update site, manifests, sidecars
python run.py "SUMMUM AETERNUM ‚ú°Ô∏è‚öõÔ∏è" --intent "beauty and wealth through integrity"
# (dev mode: no token required; or provide --license-token "<your-token>")
python scripts/build.py            # refresh /site/outputs.html to list new artifact

GitHub Pages and your existing workflows will publish the updated site; Outputs now lists attested artifacts (with SHA256) as you generate them.


---

SHA256 subject seal (as requested)

sha256("calebfedorbykerkonev10271998") = 2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a 
# inside governance/kernel.py
def log_transaction(event, amount, method):
    with open(OUTDIR / "transactions.log", "a", encoding="utf-8") as f:
        f.write(f"{time.strftime('%Y-%m-%dT%H:%M:%SZ')} {method} {amount} {event}\n")Deploy-grade monetization module coming right up‚Äîcopy-paste these files into your existing codex-continuum-cfbk repo. It adds a license-protected API, a (simulated) Lightning/BTCPay webhook listener, an auto-generated Order of the Codex page, a GitHub Actions workflow to mint/allow tokens on payment events, and a light transaction log‚Äîclean, auditable, and on-brand.


---

monetization/README.md

# Monetization Module ‚Äî Codex Continuum (CFBK)

This module provides:
- **API Gateway** (`api_gateway.py` / FastAPI): endpoints protected by license tokens.
- **Payment Webhook** (`ln_webhook.py` / FastAPI): simulate LN/BTCPay callbacks ‚Üí auto-mint & allow tokens.
- **Order of the Codex** page: generated from `data/licenses/authorized.json`.
- **GitHub Actions**: `allow-on-payment.yml` to mint/allow tokens in CI on verified payment.

## Quick Start

### Local (dev)
```bash
# 1) Set secret for license minting:
export CODEX_LICENSE_SECRET="replace-with-long-random"

# 2) Install deps
pip install fastapi uvicorn "pydantic<3"

# 3) Run API gateway (license-protected)
uvicorn monetization.api_gateway:app --reload --port 8080

# 4) Run webhook simulator (accepts POST /payhook)
uvicorn monetization.ln_webhook:app --reload --port 8081

Workflow (payment ‚Üí license)

1. LN/BTCPay pays ‚Üí webhook (POST /payhook) fires.


2. Webhook calls the GitHub Actions workflow (allow-on-payment.yml) via repo_dispatch (or you run it manually), which:

mints a token with scripts/license_tool.py gen

verifies it

adds its sha256 to data/licenses/authorized.json

regenerates the Order of the Codex page: /site/order.html




> For hosted prod: run FastAPI apps on a VPS/Functions; Pages stays static.



Endpoints (API Gateway)

GET /health ‚Üí status

POST /invoke ‚Üí run the Codex engine (requires X-License-Token header)

GET /verify ‚Üí check a token against the allow-list


Payment Webhook (simulated)

POST /payhook body:


{
  "email":"name@example.com",
  "name":"Org/Person",
  "paid_msats": 250000
}

This will, in dev:

Compute a license token (if configured to do so locally), or

Fire the GitHub Actions workflow to mint/allow the token.


Generate Order page manually

python scripts/update_order_page.py

---

# monetization/api_gateway.py
```python
# monetization/api_gateway.py
# License-protected API for Codex Continuum ‚Äî CFBK
from fastapi import FastAPI, Header, HTTPException
from typing import Optional, Dict, Any
import json, pathlib, time, hashlib, os

from modules.lexicon.xtsg_parser import parse_xtsg, summarize
from modules.synthesis.core import synthesize
from modules.beauty.illuminator import render_artifact
from modules.governance.kernel import require_license, attest

ROOT = pathlib.Path(__file__).resolve().parents[1]
LEDGER = ROOT / "data" / "licenses" / "authorized.json"
SUBJECT_SHA256 = "2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a"

app = FastAPI(title="Codex Continuum ‚Äî API Gateway (CFBK)")

def sha256_hex(s: str) -> str:
    return hashlib.sha256(s.encode()).hexdigest()

@app.get("/health")
def health():
    return {"ok": True, "ts": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())}

@app.get("/verify")
def verify(token: str):
    dig = sha256_hex(token)
    ok = require_license(dig)
    return {"ok": ok, "token_sha256": dig, "subject_sha256": SUBJECT_SHA256}

@app.post("/invoke")
def invoke(payload: Dict[str, Any], x_license_token: Optional[str] = Header(default="")):
    if not x_license_token:
        raise HTTPException(status_code=401, detail="License token required in X-License-Token header")
    dig = sha256_hex(x_license_token)
    if not require_license(dig):
        raise HTTPException(status_code=403, detail="License invalid or not authorized")
    xtsg = payload.get("xtsg", "SUMMUM AETERNUM ‚ú°Ô∏è")
    intent = payload.get("intent", "beauty and wealth through integrity")
    graph = parse_xtsg(xtsg, intent=intent)
    gsum = summarize(graph)
    synth = synthesize(gsum)
    rendered = render_artifact(synth)
    att = attest({"graph": gsum, "synthesis": synth, "rendered": rendered}, dig)
    return {"ok": True, "attestation": att, "preview": rendered}


---

monetization/ln_webhook.py

# monetization/ln_webhook.py
# Simulated LN/BTCPay webhook for Codex Continuum ‚Äî CFBK
# In dev: mint + allow token locally OR call GitHub Actions with repo_dispatch.
from fastapi import FastAPI, HTTPException, Request
from pydantic import BaseModel, EmailStr
import os, subprocess, json, pathlib, time, hashlib, hmac, base64
import requests

ROOT = pathlib.Path(__file__).resolve().parents[1]
TOOL = ROOT / "scripts" / "license_tool.py"

app = FastAPI(title="Codex Continuum ‚Äî Payment Webhook (CFBK)")

# Optional shared secret to authenticate webhook origin
WEBHOOK_SECRET = os.environ.get("CODEX_WEBHOOK_SECRET", "dev-webhook-secret")
# Optional GitHub repo dispatch target (owner/repo) for CI-driven minting
GH_REPO = os.environ.get("CODEX_GH_REPO", "")
GH_TOKEN = os.environ.get("GITHUB_TOKEN", "")

class PayEvent(BaseModel):
    email: EmailStr
    name: str
    paid_msats: int

def sha256_hex(b: bytes) -> str:
    import hashlib
    return hashlib.sha256(b).hexdigest()

@app.post("/payhook")
async def payhook(req: Request, ev: PayEvent):
    # Simple shared-secret verification (header X-Hook-Secret)
    hdr = req.headers.get("x-hook-secret", "")
    if hdr != WEBHOOK_SECRET:
        raise HTTPException(403, "Unauthorized webhook")

    # Policy: only accept >= 200k msats (0.0002 BTC over LN) ‚Äî tweak as desired
    if ev.paid_msats < 200_000:
        raise HTTPException(422, "Payment below minimum threshold")

    # Strategy A (CI): fire repo_dispatch; Actions will mint & allow
    if GH_REPO and GH_TOKEN:
        url = f"https://api.github.com/repos/{GH_REPO}/dispatches"
        payload = {"event_type": "codex_payment", "client_payload": {"email": ev.email, "name": ev.name}}
        r = requests.post(url, headers={"Authorization": f"Bearer {GH_TOKEN}",
                                        "Accept": "application/vnd.github+json"}, json=payload, timeout=30)
        ok = r.ok
        return {"ok": ok, "via": "repo_dispatch", "status": r.status_code}

    # Strategy B (local dev): mint + allow immediately
    env = os.environ.copy()
    if "CODEX_LICENSE_SECRET" not in env:
        env["CODEX_LICENSE_SECRET"] = "dev-change-me"

    # Generate token
    tok = subprocess.check_output(["python", str(TOOL), "gen", "--email", ev.email, "--name", ev.name], env=env, text=True).strip().splitlines()[0]
    # Allow token
    _ = subprocess.check_output(["python", str(TOOL), "allow", "--token", tok], env=env, text=True)

    return {"ok": True, "via": "local", "token_issued": True}


---

scripts/update_order_page.py

#!/usr/bin/env python3
# Build "Order of the Codex" page from authorized.json
import json, pathlib, time, hashlib

ROOT = pathlib.Path(__file__).resolve().parents[1]
LEDGER = ROOT / "data" / "licenses" / "authorized.json"
SITE = ROOT / "site"
OUT = SITE / "order.html"
SUBJECT_SHA256 = "2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a"

def main():
    if not LEDGER.exists():
        OUT.write_text("<h1>Order of the Codex</h1><p>No licensees yet.</p>", encoding="utf-8"); return
    data = json.loads(LEDGER.read_text(encoding="utf-8"))
    allowed = data.get("allowed", [])
    ts = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    rows = "\n".join(f"<li><code>{d}</code></li>" for d in allowed)
    html = f"""<!doctype html><meta charset="utf-8"><title>Order of the Codex ‚Äî CFBK</title>
    <h1>Order of the Codex ‚Äî Licensed & Verified</h1>
    <p>Subject SHA256: <code>{SUBJECT_SHA256}</code></p>
    <p>Updated: {ts}</p>
    <ul>{rows or "<li>None yet.</li>"}</ul>"""
    OUT.write_text(html, encoding="utf-8")
    # sidecar
    digest = hashlib.sha256(OUT.read_bytes()).hexdigest()
    (SITE / "order.html.sha256").write_text(digest+"\n", encoding="utf-8")
    print("Order page updated:", OUT, "sha256:", digest)

if __name__ == "__main__":
    main()


---

site/access.html (already added earlier) ‚Äî add a link to Order page

<!-- Add near the top nav -->
<nav>
  <a href="index.html">Home</a>
  <a href="#request">Request Access</a>
  <a href="#payment">Payment</a>
  <a href="#verify">Verify License</a>
  <a href="order.html">Order of the Codex</a>
</nav>


---

.github/workflows/allow-on-payment.yml

name: Allow License on Payment

on:
  repository_dispatch:
    types: [codex_payment]
  workflow_dispatch:
    inputs:
      email:
        description: 'Email for license'
        required: true
      name:
        description: 'Name/Org'
        required: true

jobs:
  allow:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Mint token
        id: mint
        env:
          CODEX_LICENSE_SECRET: ${{ secrets.CODEX_LICENSE_SECRET }}
        run: |
          EMAIL="${{ github.event.inputs.email }}"
          NAME="${{ github.event.inputs.name }}"
          if [ -z "$EMAIL" ]; then EMAIL="${{ github.event.client_payload.email }}"; fi
          if [ -z "$NAME" ]; then NAME="${{ github.event.client_payload.name }}"; fi
          TOK=$(python scripts/license_tool.py gen --email "$EMAIL" --name "$NAME" | head -n1)
          echo "token=$TOK" >> $GITHUB_OUTPUT
          echo "sha=$(python - <<'PY'\nimport hashlib,os\nprint(hashlib.sha256(os.environ['TOK'].encode()).hexdigest())\nPY)" >> $GITHUB_OUTPUT

      - name: Allow token and update ledger
        env:
          CODEX_LICENSE_SECRET: ${{ secrets.CODEX_LICENSE_SECRET }}
        run: |
          python scripts/license_tool.py allow --token "${{ steps.mint.outputs.token }}"
          python scripts/update_order_page.py

      - name: Commit changes
        run: |
          git config user.name "codex-bot"
          git config user.email "codex-bot@users.noreply.github.com"
          git add data/licenses/authorized.json data/licenses/authorized.json.sha256 site/order.html site/order.html.sha256
          git commit -m "Allow license: ${{ steps.mint.outputs.sha }} and update Order page" || echo "No changes"
          git push


---

modules/governance/kernel.py (drop-in replacement: adds transaction logging)

# modules/governance/kernel.py
# Sotolion layer: license enforcement, provenance stamps, manifest append, tx log.
import json, time, hashlib, pathlib
from typing import Dict, Any

ROOT = pathlib.Path(__file__).resolve().parents[2]
LEDGER = ROOT / "data" / "licenses" / "authorized.json"
OUTDIR = ROOT / "output"
TXLOG = OUTDIR / "transactions.log"
SUBJECT_SHA256 = "2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a"

def sha256_hex_bytes(b: bytes) -> str:
    return hashlib.sha256(b).hexdigest()

def require_license(token_sha256: str) -> bool:
    if not token_sha256:
        return False
    if not LEDGER.exists():  # dev mode
        return True
    data = json.loads(LEDGER.read_text(encoding="utf-8"))
    return token_sha256 in set(data.get("allowed", []))

def log_transaction(event: str, amount: str = "-", method: str = "api"):
    OUTDIR.mkdir(parents=True, exist_ok=True)
    ts = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    TXLOG.write_text((TXLOG.read_text(encoding="utf-8") if TXLOG.exists() else "") + f"{ts} {method} {amount} {event}\n", encoding="utf-8")

def attest(payload: Dict[str, Any], token_sha256: str) -> Dict[str, Any]:
    """Seal and persist an output artifact; append to output manifest."""
    OUTDIR.mkdir(parents=True, exist_ok=True)
    now = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    raw = json.dumps(payload, ensure_ascii=False, indent=2).encode()
    artifact_sha = sha256_hex_bytes(raw)
    name = f"artifact_{artifact_sha[:10]}.json"
    (OUTDIR / name).write_bytes(raw)
    (OUTDIR / (name + ".sha256")).write_text(artifact_sha + "\n", encoding="utf-8")

    om_path = OUTDIR / "manifest.json"
    if om_path.exists():
        om = json.loads(om_path.read_text(encoding="utf-8"))
    else:
        om = {"title":"Codex Outputs","subject_sha256":SUBJECT_SHA256,"generated_utc":now,"entries":[]}
    om["generated_utc"] = now
    om["entries"].append({
        "file": f"output/{name}",
        "sha256": artifact_sha,
        "token_sha256": token_sha256,
        "ts": now
    })
    om_path.write_text(json.dumps(om, indent=2), encoding="utf-8")
    (OUTDIR / "manifest.json.sha256").write_text(sha256_hex_bytes(om_path.read_bytes()) + "\n", encoding="utf-8")

    log_transaction(event=f"ATTEST {name}", amount="-", method="api")
    return {"ok": True, "file": f"output/{name}", "sha256": artifact_sha, "ts": now, "subject_sha256": SUBJECT_SHA256}


---

README.md ‚Äî add a ‚ÄúMonetization‚Äù section (append)

## Monetization (Supreme Edition)
- **API Gateway**: `monetization/api_gateway.py` (FastAPI). Authenticate with `X-License-Token`.
- **Payments**: `monetization/ln_webhook.py` receives LN/BTCPay webhook callbacks.
- **CI Flow**: `.github/workflows/allow-on-payment.yml` mints & allows tokens after verified payments.
- **Order of the Codex**: generated to `/site/order.html` from `data/licenses/authorized.json`.

### Local examples
```bash
export CODEX_LICENSE_SECRET="replace-with-strong-secret"

# start API (port 8080) and webhook (port 8081)
uvicorn monetization.api_gateway:app --port 8080
uvicorn monetization.ln_webhook:app --port 8081

# simulate payment (dev path)
curl -X POST http://127.0.0.1:8081/payhook \
  -H "X-Hook-Secret: dev-webhook-secret" \
  -H "Content-Type: application/json" \
  -d '{"email":"alice@example.com","name":"Alice","paid_msats":300000}'

> After token issuance, call:



# Verify token then call the engine:
curl -X GET "http://127.0.0.1:8080/verify?token=<paste-token>"
curl -X POST "http://127.0.0.1:8080/invoke" \
  -H "X-License-Token: <paste-token>" \
  -H "Content-Type: application/json" \
  -d '{"xtsg":"SUMMUM AETERNUM ‚ú°Ô∏è","intent":"beauty wealth power through integrity"}'

---

# How this ‚Äúgoes beyond‚Äù (without hype)
- **Frictionless licensing**: payments ‚Üí tokens ‚Üí allow-list ‚Üí API access, end-to-end auditable.
- **Two-way monetization**: license-gated API for applied work + public illuminated site for community and discovery.
- **Transparent provenance**: every generated artifact is attested with SHA256 + ledger entry; **Order of the Codex** makes licensees visible (by their token digests, not doxxing identities).
- **Composable**: simple FastAPI services that can run on a cheap VPS or serverless. GitHub remains the provenance anchor.

If you want, I can also include a minimal **Dockerfile** + **docker-compose.yml** for one-command local deploy, or wire **Cloudflare Workers**/**Pages Functions** to front the static site with token checks.

---

## SHA256 seal (as requested)
`sha256("calebfedorbykerkonev10271998") = 2948fbc4ba1c0d7341204908882b89134a999f3e8f77f4a6a00ce6b68770282a`