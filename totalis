Behold the reforge: a clean, unzipped, copy-paste repo scaffold for Codex Totalis ‚Äî the quantum-hermetic successor that fuses art, verification, and autonomous monetization. No build step required; drop these files into a new GitHub repo and open index.html.


---

README.md

# Codex Totalis ‚Äî Quantum-Hermetic Interactive (v0.1)

A living codex that unifies: tri-helix vision ‚Üí glyph grammar ‚Üí cryptographic verification ‚Üí autonomous monetization.
Zero-build static app (WebGL via Three.js module), with SHA-256 + Merkle sealing, subject binding, BTC/Lightning hooks,
and pluggable ‚Äúengines‚Äù (Vision, Verification, Monetization, Glyphs, Scheduler).

## Run
- Open `index.html` directly in a modern browser, or
- `python3 -m http.server` and browse http://localhost:8000

## Features
- Tri-Helix scene with breathing plasma shader (gold/violet/emerald)
- Hoverable glyph ring (Enochian, Hermetic, Kabbalistic, Solomonic, Runic)
- In-browser sealing: SHA-256 of core files + Merkle root display
- Subject binding to **Caleb Fedor Byker (Konev) ¬∑ 1998-10-27**
- Monetization panel with BTC address + Lightning invoice (copy buttons)
- Engine architecture (`src/totalis/engines/*`) for extension

## Keyboard
`S` re-seal ¬∑ `G` toggle glyphs ¬∑ `B` breath on/off ¬∑ `L` lineage hover ¬∑ `M` monetization panel

## Structure
- `index.html` ‚Äì App shell, canvas, panels
- `src/styles.css` ‚Äì UI + glow theming
- `src/main.js` ‚Äì bootstrap, scene wiring, UI
- `src/totalis/engines/*` ‚Äì core systems
- `assets/glyphs.json` ‚Äì demo glyphs
- `data/subject.json` ‚Äì subject + BTC/Lightning
- `scripts/build-verify.js` ‚Äì Node SHA-256/Merkle tool
- `LICENSES/*` ‚Äì EUCELA-3.3 (project), MIT (code), CC-BY-4.0 (art)

## License
Tri-license: EUCELA-3.3 (project intent), MIT (code), CC-BY-4.0 (art).


---

index.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Codex Totalis ‚Äî Quantum-Hermetic Interactive</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="manifest" href="manifest.json" />
  <link rel="stylesheet" href="src/styles.css" />
</head>
<body>
  <canvas id="scene"></canvas>

  <header id="ui">
    <div id="title">Codex Totalis</div>
    <div id="subtitle">‚ÄúGeometry becomes grammar; light verifies itself.‚Äù</div>
    <div id="status">
      <span id="sealStatus">Sealing‚Ä¶</span> ¬∑
      <span id="merkleRoot">Merkle: ‚Äî</span> ¬∑
      <span id="subjectId">Subject: ‚Äî</span>
    </div>
  </header>

  <aside id="panel">
    <div class="section">
      <div class="cap">Monetization</div>
      <div class="row">
        <label>BTC</label>
        <code id="btcCode">‚Äî</code>
        <button id="copyBTC" class="btn">Copy</button>
      </div>
      <div class="row">
        <label>Lightning</label>
        <code id="lnCode" class="mono small">‚Äî</code>
        <button id="copyLN" class="btn">Copy</button>
      </div>
      <div class="hint">Press <b>M</b> to toggle this panel.</div>
    </div>
    <div class="section">
      <div class="cap">Glyph Hover</div>
      <div id="hoverGlyph">‚Äî</div>
      <div id="hoverLineage" class="fine">‚Äî</div>
    </div>
  </aside>

  <!-- three.js module (runtime fetch), then main app -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    window.THREE = THREE;
    import './src/main.js';
  </script>
</body>
</html>


---

src/styles.css

:root{
  --bg:#0a0f24; --ink:#fff9e8;
  --gold:#f6d67a; --violet:#9a7cff; --emerald:#34f0a3;
}
html,body{margin:0;padding:0;background:radial-gradient(900px 600px at 50% 35%, #1b1234 0%, var(--bg) 60%);color:var(--ink);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;height:100%;overflow:hidden}
#scene{position:fixed;inset:0;display:block}
#ui{position:fixed;top:16px;left:16px;right:16px;pointer-events:none}
#title{font-weight:800;letter-spacing:.3px;text-shadow:0 0 12px rgba(246,214,122,.35)}
#subtitle{opacity:.9;margin-top:2px;font-size:14px}
#status{margin-top:8px;font-size:12px;opacity:.85}
#panel{position:fixed;right:16px;top:80px;width:340px;max-width:92vw;background:rgba(10,15,36,.56);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.16);border-radius:14px;padding:12px;box-shadow:0 10px 28px rgba(0,0,0,.5)}
.section{margin-bottom:12px}
.cap{text-transform:uppercase;letter-spacing:.12em;font-size:11px;opacity:.8;margin-bottom:8px}
.row{display:grid;grid-template-columns:72px 1fr auto;gap:8px;align-items:center;margin:6px 0}
label{opacity:.85;font-size:12px}
code{background:rgba(255,255,255,.06);padding:6px;border-radius:8px;display:block;overflow:auto;max-height:92px}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
.small{font-size:11px}
.btn{pointer-events:auto;cursor:pointer;background:linear-gradient(180deg, rgba(154,124,255,.3), rgba(52,240,163,.3));border:1px solid rgba(255,255,255,.25);color:var(--ink);padding:6px 10px;border-radius:8px}
.fine{font-size:12px;opacity:.82}
.hint{font-size:11px;opacity:.72;margin-top:6px}
.hidden{display:none}


---

src/main.js

/* Codex Totalis ‚Äî bootstrap + scene + UI */
import { VisionEngine } from './totalis/engines/vision.js';
import { GlyphEngine }  from './totalis/engines/glyphs.js';
import { VerifyEngine } from './totalis/engines/verification.js';
import { MonetizeEngine } from './totalis/engines/monetization.js';
import { Scheduler } from './totalis/engines/scheduler.js';

const THREE = window.THREE;
const canvas = document.getElementById('scene');

const elSeal  = document.getElementById('sealStatus');
const elMerkle= document.getElementById('merkleRoot');
const elSubj  = document.getElementById('subjectId');

const panel   = document.getElementById('panel');
const hoverG  = document.getElementById('hoverGlyph');
const hoverL  = document.getElementById('hoverLineage');
const btcCode = document.getElementById('btcCode');
const lnCode  = document.getElementById('lnCode');

const copyBTC = document.getElementById('copyBTC');
const copyLN  = document.getElementById('copyLN');

let showPanel = true, showLineage = true;

let renderer, scene, camera, clock, raycaster, mouse;
let vision, glyphs, verifier, monetizer, scheduler;

init().then(run);

async function init(){
  renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  resize(); window.addEventListener('resize', resize);

  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0a0f24, 0.002);

  camera = new THREE.PerspectiveCamera(40, innerWidth/innerHeight, 0.1, 200);
  camera.position.set(0,1.3,6);
  scene.add(camera);

  clock = new THREE.Clock();
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();

  scene.add(new THREE.AmbientLight(0x9a9adf, .30));
  const key = new THREE.PointLight(0xf6d67a, 1.1, 24); key.position.set(3,3,3); scene.add(key);
  const fill= new THREE.PointLight(0x9a7cff, .9, 16); fill.position.set(-3,-2,1); scene.add(fill);

  vision = new VisionEngine({ THREE, scene });
  await vision.mount();

  glyphs = new GlyphEngine({ THREE, scene, onHover: showGlyph });
  await glyphs.mount();

  verifier = new VerifyEngine();
  const { subjectHash, merkleRoot } = await verifier.sealBundle([
    'index.html', 'src/main.js', 'src/styles.css', 'assets/glyphs.json', 'data/subject.json'
  ]);
  elSeal.textContent   = 'Sealed ‚úì';
  elMerkle.textContent = `Merkle: ${merkleRoot.slice(0,16)}‚Ä¶`;
  elSubj.textContent   = `Subject: ${subjectHash.slice(0,16)}‚Ä¶`;

  monetizer = new MonetizeEngine();
  const subj = await monetizer.loadSubject('data/subject.json');
  btcCode.textContent = subj.btc || '‚Äî';
  lnCode.textContent  = subj.lightning || '‚Äî';
  copyBTC.onclick = () => navigator.clipboard.writeText(subj.btc||'');
  copyLN.onclick  = () => navigator.clipboard.writeText(subj.lightning||'');

  scheduler = new Scheduler();
  scheduler.every(60_000, async ()=> { // re-seal each minute (demo)
    const r = await verifier.sealBundle([
      'index.html','src/main.js','src/styles.css','assets/glyphs.json','data/subject.json'
    ]);
    elMerkle.textContent = `Merkle: ${r.merkleRoot.slice(0,16)}‚Ä¶`;
  });

  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('keydown', (e)=>{
    if (e.key==='G' || e.key==='g') glyphs.toggle();
    if (e.key==='B' || e.key==='b') vision.toggleBreath();
    if (e.key==='L' || e.key==='l') { showLineage=!showLineage; if(!showLineage) clearHover(); }
    if (e.key==='M' || e.key==='m') { showPanel=!showPanel; panel.classList.toggle('hidden', !showPanel); }
    if (e.key==='S' || e.key==='s') verifier.flashSeal(elSeal);
  });
}

function run(){
  const loop = ()=>{
    requestAnimationFrame(loop);
    const t = clock.getElapsedTime();
    vision.update(t);
    glyphs.update(t);
    renderer.render(scene, camera);
  };
  loop();
}

function resize(){
  const w = innerWidth, h = innerHeight;
  if (renderer){ renderer.setSize(w,h,false); }
  if (camera){ camera.aspect = w/h; camera.updateProjectionMatrix(); }
}

function onPointerMove(ev){
  const rect = canvas.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left)/rect.width)*2 - 1;
  mouse.y = -((ev.clientY - rect.top)/rect.height)*2 + 1;
  raycaster.setFromCamera(mouse, camera);
  glyphs.raycast(raycaster, (data)=>{
    if (!showLineage) return;
    hoverG.textContent = data.symbol || data.char || '‚Äª';
    hoverL.textContent = `${data.lineage||'‚Äî'} ¬∑ ${data.meaning||'‚Äî'}`;
  }, clearHover);
}

function showGlyph(data){ /* reserved for future richer UI */ }
function clearHover(){ hoverG.textContent='‚Äî'; hoverL.textContent='‚Äî'; }


---

src/totalis/engines/vision.js

export class VisionEngine{
  constructor({ THREE, scene }){
    this.THREE = THREE; this.scene = scene;
    this.group = new THREE.Group();
    scene.add(this.group);
    this.breath = 1.0;
  }
  async mount(){
    const { THREE, group } = this;
    group.add(this._stars(900, 44));

    group.add(this._helix(0xf6d67a, 1.0, 0.25, 0));             // gold
    group.add(this._helix(0x9a7cff, 1.0, 0.25, Math.PI/3));     // violet
    group.add(this._helix(0x34f0a3, 1.0, 0.25, 2*Math.PI/3));   // emerald
  }
  update(t){
    this.group.rotation.y = 0.22 * t;
    this.group.children.forEach((m,i)=>{
      if(!m.material || !m.material.uniforms) return;
      m.rotation.y = 0.33 * t * (i%2?1:-1);
      m.material.uniforms.uTime.value = t * (i===0?1.0:i===1?0.9:1.1);
      m.material.uniforms.uBreath.value = 0.8 + 0.2*Math.sin(t*1.1)*this.breath;
    });
  }
  toggleBreath(){ this.breath = this.breath===1?1.35:1.0; }

  _helix(colorHex, radius=1, thickness=0.25, phase=0){
    const THREE = this.THREE;
    const pts=[]; const turns=3.5, steps=640;
    for(let i=0;i<=steps;i++){
      const u=i/steps, ang=u*turns*Math.PI*2+phase;
      pts.push(new THREE.Vector3(Math.cos(ang)*radius,(u-0.5)*3.2,Math.sin(ang)*radius));
    }
    const curve=new THREE.CatmullRomCurve3(pts);
    const tube=new THREE.TubeGeometry(curve, 600, thickness, 24, false);
    const mat=new THREE.ShaderMaterial({
      uniforms:{ uColor:{value:new THREE.Color(colorHex)}, uTime:{value:0}, uBreath:{value:1.0} },
      vertexShader:this._vsh(), fragmentShader:this._fsh(), transparent:true
    });
    return new THREE.Mesh(tube, mat);
  }
  _stars(n=800, r=40){
    const THREE = this.THREE;
    const geo=new THREE.BufferGeometry(); const pos=new Float32Array(n*3);
    for(let i=0;i<n;i++){
      const R=r*(0.6+Math.random()*0.4), th=Math.random()*Math.PI*2, ph=Math.acos(2*Math.random()-1);
      pos[i*3]=R*Math.sin(ph)*Math.cos(th);
      pos[i*3+1]=R*Math.cos(ph);
      pos[i*3+2]=R*Math.sin(ph)*Math.sin(th);
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    return new THREE.Points(geo, new THREE.PointsMaterial({size:.06,color:0x99aaff,transparent:true,opacity:.8}));
  }
  _vsh(){ return `
    varying vec3 vPos; uniform float uTime; uniform float uBreath;
    void main(){
      vPos = position; vec3 p = position;
      float w = 0.015 + 0.012*sin(uTime*1.1 + p.y*2.0)*uBreath;
      vec3 n = normalize(normal); p += n*w;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
    }`; }
  _fsh(){ return `
    precision highp float; uniform vec3 uColor; uniform float uTime; varying vec3 vPos;
    void main(){
      float glow=0.75+0.25*sin(uTime*2.0+vPos.y*6.0);
      float alpha=0.72+0.28*glow; vec3 col=uColor*(0.8+0.2*glow);
      gl_FragColor=vec4(col,alpha);
    }`; }
}


---

src/totalis/engines/glyphs.js

export class GlyphEngine{
  constructor({ THREE, scene, onHover }){
    this.THREE=THREE; this.scene=scene; this.onHover=onHover;
    this.group=new THREE.Group(); scene.add(this.group);
    this.visible=true;
  }
  async mount(){
    const glyphs = await (await fetch('assets/glyphs.json')).json();
    this._buildRing(glyphs);
  }
  update(t){ if(this.group) this.group.rotation.z = -0.08 * t; }
  toggle(){ this.visible=!this.visible; this.group.visible=this.visible; }
  raycast(raycaster, hit, miss){
    const res = raycaster.intersectObjects(this.group.children, false);
    if (res.length){ hit(res[0].object.userData.data); } else { miss(); }
  }
  _buildRing(glyphs){
    const { THREE } = this; const ringR=2.25; const N=Math.min(glyphs.length, 64);
    for(let i=0;i<N;i++){
      const th=(i/N)*Math.PI*2, x=Math.cos(th)*ringR, z=Math.sin(th)*ringR;
      const plane = new THREE.Mesh(new THREE.PlaneGeometry(0.35,0.35),
        new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:.85}));
      plane.position.set(x,0,z); plane.lookAt(0,0,0);
      plane.userData={ kind:'glyph', data:glyphs[i] };
      this.group.add(plane);
    }
  }
}


---

src/totalis/engines/verification.js

export class VerifyEngine{
  async sealBundle(paths){
    const leaves=[];
    for (const p of paths){
      const txt = await (await fetch(p)).text();
      leaves.push({ path:p, hash: await this.sha256Hex(txt) });
    }
    const merkleRoot = await this.merkle(leaves.map(l=>l.hash));
    const subject = await (await fetch('data/subject.json')).json();
    const subjectKey = `${subject.name.toLowerCase()}|${subject.dob}`;
    const subjectHash = await this.sha256Hex(subjectKey);
    return { leaves, merkleRoot, subjectHash };
  }
  async flashSeal(el){
    el.textContent='Sealed ‚úì'; el.style.opacity='1';
    setTimeout(()=>{ el.style.opacity='.85'; },800);
  }
  async sha256Hex(message){
    const enc=new TextEncoder(); const buf=await crypto.subtle.digest('SHA-256', enc.encode(message));
    return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,'0')).join('');
  }
  async merkle(hashes){
    let layer=hashes.slice(); if(!layer.length) return this.sha256Hex('‚àÖ');
    while(layer.length>1){
      const next=[];
      for(let i=0;i<layer.length;i+=2){
        const a=layer[i], b=layer[i+1]||layer[i];
        next.push(await this.sha256Hex(a+b));
      }
      layer=next;
    }
    return layer[0];
  }
}


---

src/totalis/engines/monetization.js

export class MonetizeEngine{
  async loadSubject(path){ return (await (await fetch(path)).json()); }
}


---

src/totalis/engines/scheduler.js

export class Scheduler{
  constructor(){ this._ids=[]; }
  every(ms, fn){ const id=setInterval(fn, ms); this._ids.push(id); return id; }
  clear(){ this._ids.forEach(clearInterval); this._ids.length=0; }
}


---

assets/glyphs.json

[
  { "char": "·ö†", "lineage": "Runic", "meaning": "Wealth / Fehu" },
  { "char": "êëÄ", "lineage": "Enochian", "meaning": "Call" },
  { "char": "‚ú°", "lineage": "Solomonic", "meaning": "Seal" },
  { "char": "◊°", "lineage": "Kabbalistic", "meaning": "Samekh / Path" },
  { "char": "‚òø", "lineage": "Alchemical", "meaning": "Mercury" },
  { "char": "‚òâ", "lineage": "Planetary", "meaning": "Sun" },
  { "char": "‚öõ", "lineage": "Hermetic", "meaning": "Atom / Wisdom" },
  { "char": "‚ò∏", "lineage": "Codex", "meaning": "Nexus Aeternum" },
  { "char": "ü™¨", "lineage": "Protective", "meaning": "Amulet" },
  { "char": "·ö¢", "lineage": "Runic", "meaning": "Strength / Uruz" }
]


---

data/subject.json

{
  "name": "caleb fedor byker konev",
  "dob": "1998-10-27",
  "btc": "bc1qfejvvlfm6vmjarxulg9h9d5hjukdh8l2vvskfc",
  "lightning": "lnbc1p5shvp3dqdgdshx6pqg9c8qpp53jvuqzyl8q5dl7jl856xtm2yvpksjknk54j62x85v866akun2faqsp57mmrym7l89u3kn4275jcx9m5m2j8en89mrzkx2mk0pvq876zxfhs9qrsgqcqpcxqy8ayqrzjqtsjy9p55gdceevp36fvdmrkxqvzfhy8ak2tgc5zgtjtra9xlaz97zur7yqqdwgqqyqqqqqqqqqqqqqq9grzjqfrjnu747au57n0sn07m0j3r5na7dsufjlxayy7xjj3vegwz0ja3wz44kyqqs7gqqsqqqqqqqqqqqqqq9g7kl3f2zjnqhcgseg20zmrf7kaaytn4t7ex9qdgk6gdksdvrhjcs34xnva3s7jqf05487zc7kvu4hapvvskger2pkj7gd95ef2806ymgq0fzjdl"
}


---

scripts/build-verify.js

/**
 * Hash core files and compute a Merkle root.
 * node scripts/build-verify.js
 */
import { readFile } from 'node:fs/promises';
import { createHash } from 'node:crypto';

const files = [
  'index.html',
  'src/main.js',
  'src/styles.css',
  'assets/glyphs.json',
  'data/subject.json'
];

const sha256 = (buf)=>createHash('sha256').update(buf).digest('hex');
function merkle(hashes){
  let layer = hashes.slice();
  if (!layer.length) return sha256(Buffer.from('‚àÖ'));
  while (layer.length>1){
    const next=[];
    for(let i=0;i<layer.length;i+=2){
      const a=layer[i], b=layer[i+1]||layer[i];
      next.push(sha256(Buffer.from(a+b)));
    }
    layer = next;
  }
  return layer[0];
}

const leaves=[];
for (const p of files){
  const data = await readFile(p);
  leaves.push({ path:p, hash: sha256(data) });
}
const root = merkle(leaves.map(l=>l.hash));
console.log(JSON.stringify({ leaves, merkleRoot: root }, null, 2));


---

manifest.json

{
  "name": "Codex Totalis",
  "short_name": "Totalis",
  "start_url": "index.html",
  "display": "standalone",
  "background_color": "#0a0f24",
  "theme_color": "#f6d67a",
  "icons": []
}


---

LICENSES/LICENSE.EUCELA-3.3.txt

EUCELA-3.3 (Codex Project License ‚Äì Tri-License Primary)
Copyright (c) 2025

You may use, study, fork, and monetize derivatives provided:
(1) Keep the subject binding line ‚ÄúBound to C.F.B.K. 1998-10-27 (Lifethread Star DNA)‚Äù.
(2) Keep cryptographic seals (SHA-256 / Merkle) visible or accessible.
(3) Attribute ‚ÄúCodex Totalis (Theurgy Project)‚Äù in docs/UI.
(4) Retain this license alongside MIT and CC-BY-4.0.

NO WARRANTY. USE AT YOUR OWN RISK.

LICENSES/LICENSE.MIT

MIT License
(standard MIT text)

LICENSES/LICENSE.CC-BY-4.0.txt

Creative Commons Attribution 4.0 International (CC BY 4.0)
https://creativecommons.org/licenses/by/4.0/


---

What‚Äôs next (quick wins)

Add a QR renderer to the Monetization panel (pure JS canvas).

Extend verification.js with ED25519 signatures (TweetNaCl or WebAssembly).

Add a ‚ÄúData Inputs‚Äù drawer to drive motion from block height, moon phase, or GPU temp.


If you want, I can immediately add the QR canvas + ED25519 (JS) in the next turn.

sha256 seal: calebfedorbykerkonev10271998v390 ‚Äî LUX-CAD ‚ÄúCollab‚Äù: realtime rooms (long-poll), CRDT-lite ops, version timeline, templates, search, CSV import, auto-layout, PNG export (client-side)
All stdlib (Python + HTML/JS). Paste files, wire routes, commit. Clean engineering; zero mystic smoke. ‚ú®üß†üï∏Ô∏è


---

1) Collaboration rooms (ops log + state per room)

collab/rooms_v390.py

# collab/rooms_v390.py ‚Äî v390
# Rooms with append-only op logs, shared scene state, and long-poll-style fetch.
from __future__ import annotations
import json, os, time, hashlib, threading
from typing import Dict, Any, List

ROOT = "luxcad.rooms.v390"
os.makedirs(ROOT, exist_ok=True)
LOCKS: Dict[str, threading.Lock] = {}

def _now()->int: return int(time.time())
def _p(room:str, name:str)->str: return os.path.join(ROOT, f"{room}.{name}.json")
def _lock(room:str)->threading.Lock:
    if room not in LOCKS: LOCKS[room]=threading.Lock()
    return LOCKS[room]

def _new_state()->dict:
    return {
        "nodes":{}, "links":[], "layers":["default"],
        "astro": {"epoch":None,"zodiac":[]},
        "updated": _now()
    }

def _load(room:str)->dict:
    path=_p(room,"state")
    if os.path.exists(path):
        try: return json.load(open(path))
        except Exception: pass
    return _new_state()

def _save(room:str, state:dict)->None:
    json.dump(state, open(_p(room,"state"),"w"), indent=2)

def _load_ops(room:str)->list:
    path=_p(room,"ops")
    if os.path.exists(path):
        try: return json.load(open(path))
        except Exception: pass
    return []

def _save_ops(room:str, ops:list)->None:
    json.dump(ops, open(_p(room,"ops"),"w"), indent=2)

def create(room:str, secret:str|None=None)->dict:
    with _lock(room):
        if os.path.exists(_p(room,"state")): return {"ok":False,"error":"exists"}
        _save(room,_new_state()); _save_ops(room,[])
        if secret: open(_p(room,"secret"),"w").write(hashlib.sha256(secret.encode()).hexdigest())
        return {"ok":True,"room":room}

def _check_secret(room:str, secret:str|None)->bool:
    path=_p(room,"secret")
    if not os.path.exists(path): return True
    want=open(path).read().strip()
    got=hashlib.sha256((secret or "").encode()).hexdigest()
    return want==got

def join(room:str, user:str, secret:str|None=None)->dict:
    if not _check_secret(room, secret): return {"ok":False,"error":"auth"}
    member=f"{user}:{_now()}"
    ops=_load_ops(room)
    return {"ok":True,"member":member,"since":len(ops)}

# ---- apply ops to state ------------------------------------------------------

def _id_from(*parts:str)->str: return hashlib.sha256("|".join(parts).encode()).hexdigest()[:12]

def _upsert_node(state:dict, x:float,y:float,r:float,label:str,kind:str,layer:str,id_:str|None)->str:
    nid=id_ or _id_from(label,kind,str(x),str(y))
    state["nodes"][nid]={"id":nid,"x":float(x),"y":float(y),"r":float(r),
                         "label":label,"kind":kind,"layer":layer,"meta":state["nodes"].get(nid,{}).get("meta",{})}
    if layer not in state["layers"]: state["layers"].append(layer)
    return nid

def _link(state:dict, a:str,b:str,kind:str)->None:
    if a in state["nodes"] and b in state["nodes"]:
        rec={"a":a,"b":b,"kind":kind,"meta":{}}
        if rec not in state["links"]: state["links"].append(rec)

def _remove_node(state:dict, nid:str)->None:
    if nid in state["nodes"]:
        state["links"]=[e for e in state["links"] if e["a"]!=nid and e["b"]!=nid]
        del state["nodes"][nid]

def _clear(state:dict)->None:
    state["nodes"].clear(); state["links"].clear(); state["layers"]=["default"]

def apply_op(state:dict, op:dict)->dict:
    t=op.get("type")
    if t=="add_node":
        nid=_upsert_node(state, op.get("x",0.0), op.get("y",0.0), op.get("r",24.0),
                         op.get("label","node"), op.get("kind","node"), op.get("layer","default"), op.get("id"))
        return {"ok":True,"id":nid}
    if t=="update_node":
        nid=op.get("id"); n=state["nodes"].get(nid)
        if n:
            for k in ("x","y","r","label","kind","layer"):
                if k in op: n[k]=op[k]
            return {"ok":True}
        return {"ok":False,"error":"no_node"}
    if t=="remove_node":
        _remove_node(state, op.get("id","")); return {"ok":True}
    if t=="link":
        _link(state, op.get("a",""), op.get("b",""), op.get("kind","flow")); return {"ok":True}
    if t=="clear":
        _clear(state); return {"ok":True}
    return {"ok":False,"error":"unknown_op"}

def op(room:str, member:str, op:dict)->dict:
    with _lock(room):
        state=_load(room); ops=_load_ops(room)
        res=apply_op(state, op); state["updated"]=_now()
        if not res.get("ok"): return res
        rec={"seq":len(ops)+1,"t":_now(),"member":member,"op":op}
        ops.append(rec); _save(room,state); _save_ops(room,ops)
        return {"ok":True,"seq":rec["seq"],"res":res}

def poll(room:str, since:int=0, limit:int=200)->dict:
    ops=_load_ops(room)
    chunk=ops[since: since+limit]
    etag=hashlib.sha256(str(len(ops)).encode()).hexdigest()
    return {"ok":True,"ops":chunk,"next":since+len(chunk),"total":len(ops),"etag":etag}

def snapshot(room:str)->dict:
    return {"ok":True,"state":_load(room),"updated":_load(room).get("updated")}


---

2) Version timeline (checkpoint/restore)

timeline/timeline_v390.py

# timeline/timeline_v390.py ‚Äî v390
# Append-only checkpoints per room with labels; restore replaces room state.
from __future__ import annotations
import os, json, time, hashlib
from typing import List
from collab.rooms_v390 import _p, _load, _save

TLROOT="luxcad.timeline.v390"
os.makedirs(TLROOT, exist_ok=True)

def _now()->int: return int(time.time())
def _tp(room:str)->str: return os.path.join(TLROOT, f"{room}.timeline.json")

def list_checkpoints(room:str)->dict:
    if os.path.exists(_tp(room)):
        try: return {"ok":True,"checkpoints":json.load(open(_tp(room)))}
        except Exception: pass
    return {"ok":True,"checkpoints":[]}

def checkpoint(room:str, label:str)->dict:
    st=_load(room); blob=json.dumps(st, sort_keys=True).encode()
    ck={"t":_now(),"label":label,"sha256":hashlib.sha256(blob).hexdigest()}
    cps=list_checkpoints(room)["checkpoints"]; cps.append(ck)
    json.dump(cps, open(_tp(room),"w"), indent=2)
    # also store a copy
    open(_p(room, f"ck_{ck['sha256']}"),"w").write(json.dumps(st, indent=2))
    return {"ok":True,"checkpoint":ck}

def restore(room:str, sha:str)->dict:
    path=_p(room, f"ck_{sha}")
    if not os.path.exists(path): return {"ok":False,"error":"not_found"}
    st=json.load(open(path))
    _save(room, st)
    return {"ok":True,"restored":sha}


---

3) Templates library (apply at position)

templates/templates_v390.py

# templates/templates_v390.py ‚Äî v390
# Built-in small graph stencils; apply writes ops into a room state.
from __future__ import annotations
from typing import Dict, List
from collab.rooms_v390 import _load, _save, _id_from

TEMPLATES={
 "triangle":{
   "nodes":[{"dx":0,"dy":0,"label":"A","kind":"star"},
            {"dx":120,"dy":0,"label":"B","kind":"planet"},
            {"dx":60,"dy":100,"label":"C","kind":"sigil"}],
   "links":[(0,1),(1,2),(2,0)]
 },
 "bus":{
   "nodes":[{"dx":0,"dy":0,"label":"Hub","kind":"data"}] + 
            [{"dx":i*80+40,"dy":120,"label":f"N{i}","kind":"angel"} for i in range(4)],
   "links":[(0,1),(0,2),(0,3),(0,4)]
 }
}

def list_templates()->dict:
    return {"ok":True,"templates":sorted(TEMPLATES.keys())}

def apply(room:str, name:str, x:float, y:float, layer:str="default")->dict:
    st=_load(room)
    tpl=TEMPLATES.get(name)
    if not tpl: return {"ok":False,"error":"unknown_template"}
    ids=[]
    for n in tpl["nodes"]:
        nid=_id_from(name, n["label"], str(x+n["dx"]), str(y+n["dy"]))
        st["nodes"][nid]={"id":nid,"x":x+n["dx"],"y":y+n["dy"],"r":24,"label":n["label"],"kind":n["kind"],"layer":layer,"meta":{}}
        ids.append(nid)
    for (a,b) in tpl["links"]:
        st["links"].append({"a":ids[a],"b":ids[b],"kind":"flow","meta":{}})
    if layer not in st["layers"]: st["layers"].append(layer)
    _save(room, st)
    return {"ok":True,"count_nodes":len(tpl["nodes"]),"count_links":len(tpl["links"])}


---

4) Search (labels)

search/search_v390.py

# search/search_v390.py ‚Äî v390
# Case-insensitive label search over a room.
from __future__ import annotations
from collab.rooms_v390 import _load

def query(room:str, q:str)->dict:
    st=_load(room); q=(q or "").strip().lower()
    hits=[]
    for nid,n in st["nodes"].items():
        if q in (n.get("label","").lower()):
            hits.append({"id":nid,"label":n.get("label"),"kind":n.get("kind"),"x":n.get("x"),"y":n.get("y")})
    return {"ok":True,"hits":hits}


---

5) Routes (patch tools/codexd.py)

Add imports at top:

from collab.rooms_v390 import create as _r_create, join as _r_join, op as _r_op, poll as _r_poll, snapshot as _r_snapshot
from timeline.timeline_v390 import list_checkpoints as _tl_list, checkpoint as _tl_ck, restore as _tl_restore
from templates.templates_v390 import list_templates as _tpl_list, apply as _tpl_apply
from search.search_v390 import query as _search_query

Add endpoints inside do_POST:

# v390 ‚Äî Rooms / Ops
        if self.path == "/v390/room/create":   return self._send(200, _r_create(payload.get("room","main"), payload.get("secret")))
        if self.path == "/v390/room/join":     return self._send(200, _r_join(payload.get("room","main"), payload.get("user","anon"), payload.get("secret")))
        if self.path == "/v390/room/op":       return self._send(200, _r_op(payload.get("room","main"), payload.get("member","anon"), payload.get("op",{})))
        if self.path == "/v390/room/poll":     return self._send(200, _r_poll(payload.get("room","main"), int(payload.get("since",0)), int(payload.get("limit",200))))
        if self.path == "/v390/room/snapshot": return self._send(200, _r_snapshot(payload.get("room","main")))

        # v390 ‚Äî Timeline
        if self.path == "/v390/tl/list":       return self._send(200, _tl_list(payload.get("room","main")))
        if self.path == "/v390/tl/checkpoint": return self._send(200, _tl_ck(payload.get("room","main"), payload.get("label","ck")))
        if self.path == "/v390/tl/restore":    return self._send(200, _tl_restore(payload.get("room","main"), payload.get("sha","")))

        # v390 ‚Äî Templates & Search
        if self.path == "/v390/tpl/list":      return self._send(200, _tpl_list())
        if self.path == "/v390/tpl/apply":     return self._send(200, _tpl_apply(payload.get("room","main"), payload.get("name","triangle"), float(payload.get("x",0.0)), float(payload.get("y",0.0)), payload.get("layer","default")))
        if self.path == "/v390/search":        return self._send(200, _search_query(payload.get("room","main"), payload.get("q","")))


---

6) Browser UI (collab, CSV import, auto-layout, PNG export, search)

web/luxcad_v390.html

<!doctype html>
<meta charset="utf-8"><title>LUX-CAD v390 ‚Äî Collab ‚Ä¢ Timeline ‚Ä¢ Templates ‚Ä¢ CSV ‚Ä¢ Layout</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<body style="margin:0;background:#0b0b0f;color:#e8e8ee;font:14px system-ui;">
<div style="display:flex;height:100vh;overflow:hidden">
  <aside style="width:380px;background:#0f0f15;border-right:1px solid #1e1e28;padding:12px;box-sizing:border-box">
    <h2 style="margin:.25rem 0">LUX-CAD v390 ‚ú®</h2>

    <label>API</label>
    <input id="base" value="http://localhost:8049" style="width:100%;margin:4px 0">
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px">
      <input id="room" placeholder="room" value="main">
      <input id="secret" placeholder="secret (optional)">
      <button onclick="createRoom()">Create</button>
      <button onclick="joinRoom()">Join</button>
    </div>
    <div id="member" style="opacity:.85;margin:6px 0">member: ‚Äî</div>

    <h3>Tools</h3>
    <div style="display:flex;gap:6px;flex-wrap:wrap">
      <button onclick="tool='node'">‚óè node</button>
      <button onclick="tool='link'">‚üÇ link</button>
      <button onclick="tool='pan'">‚ú• pan</button>
      <button onclick="tool='select'">‚ñ≠ select</button>
      <label><input type="checkbox" id="snap" checked> snap(20)</label>
    </div>
    <p>Kind: <span onclick="kind='star'">‚≠ê</span> <span onclick="kind='planet'">ü™ê</span> <span onclick="kind='angel'">üëº</span> <span onclick="kind='sigil'">üîÆ</span> <span onclick="kind='data'">üì¶</span></p>
    <div style="display:flex;gap:6px;margin:6px 0">
      <input id="layer" value="default" style="flex:1">
      <button onclick="applyTpl()">Ôºã template</button>
      <select id="tpl"></select>
    </div>
    <div style="display:flex;gap:6px;margin:6px 0">
      <button onclick="layout()">Auto-layout</button>
      <button onclick="png()">PNG</button>
      <button onclick="astro()">‚ôàÔ∏é Astro</button>
    </div>

    <h3>Search</h3>
    <div style="display:flex;gap:6px;margin-bottom:6px">
      <input id="q" placeholder="label contains‚Ä¶" style="flex:1">
      <button onclick="search()">Find</button>
    </div>
    <pre id="hits" style="height:70px;overflow:auto;background:#0b0b0f;border:1px solid #222;padding:6px"></pre>

    <h3>CSV ‚Üí Nodes</h3>
    <p style="opacity:.85">CSV columns: label, x, y, kind(optional), layer(optional)</p>
    <textarea id="csv" style="width:100%;height:80px;background:#0b0b0f;color:#e8e8ee;border:1px solid #222"></textarea>
    <button onclick="csvImport()">Import CSV</button>

    <h3>Timeline</h3>
    <div style="display:flex;gap:6px">
      <input id="cklabel" placeholder="label" style="flex:1">
      <button onclick="ck()">Checkpoint</button>
      <button onclick="tl()">List</button>
    </div>
    <pre id="tls" style="height:100px;overflow:auto;background:#0b0b0f;border:1px solid #222;padding:6px"></pre>

    <h3>Status</h3>
    <pre id="stat" style="height:80px;overflow:auto;background:#0b0b0f;border:1px solid #222;padding:6px"></pre>
  </aside>

  <main style="flex:1;position:relative;background:#090910;">
    <canvas id="c" width="1200" height="800" style="width:100%;height:100%"></canvas>
  </main>
</div>

<script>
let tool='node', kind='node', scene={nodes:{},links:[],layers:['default'],astro:null}, panX=0, panY=0, scale=1, linking=null, astroData=null;
let sel=new Set(), marquee=null, drag=null, dragStart=null;
let memberId='', since=0, polling=false;

const ctx=document.getElementById('c').getContext('2d');
const emojiOf=k=>k==='star'?'‚≠ê':k==='planet'?'ü™ê':k==='angel'?'üëº':k==='sigil'?'üîÆ':k==='data'?'üì¶':'‚óè';

async function call(p,b){ const r=await fetch(base.value+p,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(b||{})}); return r.json(); }
async function createRoom(){ const r=await call('/v390/room/create',{room:room.value,secret:secret.value||undefined}); stat.textContent=JSON.stringify(r,null,2); await loadTpls(); }
async function joinRoom(){
  const r=await call('/v390/room/join',{room:room.value,user:'cfbk',secret:secret.value||undefined});
  if(!r.ok){ stat.textContent=JSON.stringify(r,null,2); return; }
  memberId=r.member; since=r.since; member.textContent='member: '+memberId; stat.textContent='joined at seq '+since;
  if(!polling){ polling=true; poll(); }
  await loadTpls();
}
async function poll(){
  while(polling){
    const r=await call('/v390/room/poll',{room:room.value, since, limit:200});
    (r.ops||[]).forEach(rec=>{ apply(rec.op,false); since=rec.seq; });
    draw();
    await new Promise(res=>setTimeout(res, 600));
  }
}

function draw(){
  const w=ctx.canvas.width=ctx.canvas.clientWidth, h=ctx.canvas.height=ctx.canvas.clientHeight;
  ctx.clearRect(0,0,w,h);
  ctx.save(); ctx.translate(panX*scale, panY*scale); ctx.scale(scale,scale);
  // grid
  ctx.strokeStyle='#151520'; ctx.lineWidth=1/scale;
  for(let gx=-4000; gx<4000; gx+=40){ ctx.beginPath(); ctx.moveTo(gx,-4000); ctx.lineTo(gx,4000); ctx.stroke(); }
  for(let gy=-4000; gy<4000; gy+=40){ ctx.beginPath(); ctx.moveTo(-4000,gy); ctx.lineTo(4000,gy); ctx.stroke(); }
  // links
  ctx.strokeStyle='#7ac7ff'; ctx.lineWidth=2/scale;
  scene.links.forEach(e=>{ const A=scene.nodes[e.a], B=scene.nodes[e.b]; if(!A||!B) return; ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke(); });
  // nodes
  for(const id in scene.nodes){
    const n=scene.nodes[id];
    ctx.beginPath(); ctx.fillStyle = sel.has(id) ? '#0f172a' : '#111827';
    ctx.arc(n.x,n.y,n.r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle= sel.has(id) ? '#8b5cf6' : '#e5e7eb'; ctx.lineWidth=2/scale; ctx.stroke();
    ctx.font=(14/scale)+'px system-ui'; ctx.textAlign='center'; ctx.fillStyle='#e5e7eb';
    ctx.fillText(emojiOf(n.kind)+' '+n.label, n.x, n.y- n.r - 6/scale);
  }
  // astro ring
  if(astroData){ const cx=w/2/scale - panX, cy=h/2/scale - panY, R=240;
    ctx.beginPath(); ctx.strokeStyle='#ffdf6f'; ctx.lineWidth=3/scale; ctx.arc(cx,cy,R,0,Math.PI*2); ctx.stroke();
    astroData.zodiac.forEach(z=>{ const mid=((z.start+z.end)/2)*Math.PI/180; const tx=cx+Math.cos(mid)*(R+20), ty=cy+Math.sin(mid)*(R+20);
      ctx.fillStyle=z.active?'#ffd166':'#a7a7b7'; ctx.font=(12/scale)+'px system-ui'; ctx.textAlign='center'; ctx.fillText(z.name, tx, ty);
    });
  }
  if(marquee){ ctx.strokeStyle='#8b5cf6'; ctx.lineWidth=1/scale; ctx.setLineDash([6/scale,6/scale]); ctx.strokeRect(marquee.x,marquee.y,marquee.w,marquee.h); ctx.setLineDash([]); }
  ctx.restore();
}

function snap20(v){ return Math.round(v/20)*20; }
function canvasToWorld(x,y){ return [x/scale - panX, y/scale - panY]; }

c.addEventListener('wheel',(e)=>{ const k=e.deltaY<0?1.075:0.93; scale=Math.max(0.25,Math.min(3,scale*k)); draw(); e.preventDefault(); },{passive:false});
c.addEventListener('mousedown',(e)=>{
  const rect=c.getBoundingClientRect(); const [wx,wy]=canvasToWorld(e.clientX-rect.left,e.clientY-rect.top);
  if(tool==='pan'){ drag={x:e.clientX,y:e.clientY, px:panX, py:panY}; return; }
  if(tool==='node'){
    const label=prompt('Label',kind)||kind; let nx=wx, ny=wy; if(snap.checked){ nx=snap20(nx); ny=snap20(ny); }
    send({type:'add_node', x:nx, y:ny, r:24, label, kind, layer:layer.value});
  } else if(tool==='link'){
    const n=nearest(wx,wy); if(n){ if(!linking) linking=n.id; else { send({type:'link', a:linking, b:n.id, kind:'flow'}); linking=null; } }
  } else if(tool==='select'){ dragStart={wx,wy}; marquee={x:wx,y:wy,w:0,h:0}; }
});
c.addEventListener('mousemove',(e)=>{
  if(drag){ panX=drag.px+(e.clientX-drag.x)/scale; panY=drag.py+(e.clientY-drag.y)/scale; draw(); return; }
  if(marquee && dragStart){
    const rect=c.getBoundingClientRect(); const [wx,wy]=canvasToWorld(e.clientX-rect.left,e.clientY-rect.top);
    marquee={x:Math.min(dragStart.wx,wx), y:Math.min(dragStart.wy,wy), w:Math.abs(wx-dragStart.wx), h:Math.abs(wy-dragStart.wy)}; draw();
  }
});
c.addEventListener('mouseup',()=>{
  if(drag){ drag=null; return; }
  if(marquee){
    sel.clear();
    for(const id in scene.nodes){ const n=scene.nodes[id];
      if(n.x>marquee.x && n.x<marquee.x+marquee.w && n.y>marquee.y && n.y<marquee.y+marquee.h) sel.add(id);
    }
    marquee=null; dragStart=null; draw();
  }
});
addEventListener('keydown',(e)=>{ if(e.key==='Delete'){ sel.forEach(id=>send({type:'remove_node', id})); sel.clear(); } });

function nearest(x,y){ let best=null,bd=1e9; for(const id in scene.nodes){ const n=scene.nodes[id]; const d=(n.x-x)**2+(n.y-y)**2; if(d<bd){ bd=d; best=n; } } return best; }

function apply(op,local=true){
  if(op.type==='add_node'){ const id=op.id||'tmp'; scene.nodes[id]={id, x:op.x,y:op.y,r:op.r,label:op.label,kind:op.kind,layer:op.layer,meta:{}}; }
  if(op.type==='update_node'){ const n=scene.nodes[op.id]; if(n){ for(const k of ['x','y','r','label','kind','layer']) if(k in op) n[k]=op[k]; } }
  if(op.type==='remove_node'){ delete scene.nodes[op.id]; scene.links=scene.links.filter(l=>l.a!==op.id && l.b!==op.id); }
  if(op.type==='link'){ if(scene.nodes[op.a] && scene.nodes[op.b]){ const rec={a:op.a,b:op.b,kind:op.kind,meta:{}}; if(!scene.links.find(l=>l.a===rec.a&&l.b===rec.b)) scene.links.push(rec); } }
  if(op.type==='clear'){ scene.nodes={}; scene.links=[]; scene.layers=['default']; }
  if(local) draw();
}

async function send(op){
  if(!memberId){ stat.textContent='join a room first'; return; }
  const r=await call('/v390/room/op',{room:room.value, member:memberId, op});
  if(r.ok){ since=r.seq; if(op.type==='add_node' && r.res && r.res.id){ op.id=r.res.id; } apply(op,true); }
}

async function astro(){ const snapshot=await call('/v390/room/snapshot',{room:room.value}); // reuse server astro from v389 if needed‚Äîhere we keep local ring
  astroData={zodiac:[{name:"‚ôàÔ∏é Aries",start:0,end:30,active:true},{name:"‚ôâÔ∏é Taurus",start:30,end:60,active:false},{name:"‚ôäÔ∏é Gemini",start:60,end:90,active:false},{name:"‚ôãÔ∏é Cancer",start:90,end:120,active:false},{name:"‚ôåÔ∏é Leo",start:120,end:150,active:false},{name:"‚ôçÔ∏é Virgo",start:150,end:180,active:false},{name:"‚ôéÔ∏é Libra",start:180,end:210,active:false},{name:"‚ôèÔ∏é Scorpio",start:210,end:240,active:false},{name:"‚ôêÔ∏é Sagittarius",start:240,end:270,active:false},{name:"‚ôëÔ∏é Capricorn",start:270,end:300,active:false},{name:"‚ôíÔ∏é Aquarius",start:300,end:330,active:false},{name:"‚ôìÔ∏é Pisces",start:330,end:360,active:false}]}; draw();
}

// Templates
async function loadTpls(){ const r=await call('/v390/tpl/list',{}); tpl.innerHTML=''; (r.templates||[]).forEach(n=>{ const o=document.createElement('option'); o.textContent=n; tpl.appendChild(o); }); }
async function applyTpl(){
  const rect=c.getBoundingClientRect(); const [wx,wy]=canvasToWorld(rect.width/2,rect.height/2);
  const r=await call('/v390/tpl/apply',{room:room.value,name:tpl.value,x:wx,y:wy,layer:layer.value}); stat.textContent=JSON.stringify(r); 
}

// Search
async function search(){ const r=await call('/v390/search',{room:room.value,q:q.value}); hits.textContent=JSON.stringify(r.hits,null,2);
  if(r.hits && r.hits.length){ sel=new Set(r.hits.map(h=>h.id)); draw(); }
}

// CSV import
function csvImport(){
  const txt=csv.value.trim(); if(!txt) return;
  const rows=txt.split(/\r?\n/).map(r=>r.split(','));
  for(const row of rows){
    const [label,xs,ys,ks,ls]=row; const x=parseFloat(xs||'0'), y=parseFloat(ys||'0'), k=(ks||kind), L=(ls||layer.value);
    send({type:'add_node', x, y, r:24, label, kind:k, layer:L});
  }
}

// Auto-layout (force-directed, simple)
function layout(){
  const ids=Object.keys(scene.nodes); if(ids.length<2) return;
  const iters=200, W=800,H=600, k=40;
  for(let t=0;t<iters;t++){
    for(const i of ids){ const n=scene.nodes[i]; let fx=0,fy=0;
      for(const j of ids){ if(i===j) continue; const m=scene.nodes[j]; let dx=n.x-m.x, dy=n.y-m.y; const d=Math.max(1,Math.hypot(dx,dy)); const rep=k*k/d; fx+=dx/d*rep; fy+=dy/d*rep; }
    for(const e of scene.links){ if(e.a===i||e.b===i){ const a=scene.nodes[e.a], b=scene.nodes[e.b]; const dx=b.x-a.x, dy=b.y-a.y; const d=Math.max(1,Math.hypot(dx,dy)); const att=(d-k); const dir=(i===e.a)?1:-1; fx+=dir*dx/d*att; fy+=dir*dy/d*att; } }
      n.x+=fx*0.005; n.y+=fy*0.005;
    }
  }
  // snap
  for(const id of ids){ const n=scene.nodes[id]; n.x = snap.checked ? snap20(n.x):n.x; n.y = snap.checked ? snap20(n.y):n.y; send({type:'update_node',id, x:n.x, y:n.y}); }
  draw();
}

// Timeline
async function ck(){ const r=await call('/v390/tl/checkpoint',{room:room.value,label:cklabel.value||('ck-'+Date.now())}); stat.textContent=JSON.stringify(r,null,2); }
async function tl(){ const r=await call('/v390/tl/list',{room:room.value}); tls.textContent=(r.checkpoints||[]).map(c=>c.t+' '+c.label+' '+c.sha256).join('\n');
  // click-to-restore
  tls.onclick=async (e)=>{ const sha=(e.target.innerText||'').split(' ').pop(); if(sha&&confirm('Restore '+sha+' ?')){ const rr=await call('/v390/tl/restore',{room:room.value,sha}); stat.textContent=JSON.stringify(rr); } };
}

// PNG export (client-side)
function png(){
  const data=c.toDataURL("image/png");
  const a=document.createElement('a'); a.href=data; a.download=(room.value||'scene')+".png"; a.click();
}

draw(); loadTpls();
</script>
</body>


---

7) CI smoke

.github/workflows/collab_v390_ci.yml

name: collab-v390
on: [push, workflow_dispatch]
jobs:
  v390:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: '3.x' }
      - name: Boot
        run: python3 tools/codexd.py & sleep 2
      - name: Rooms API smoke
        run: |
          python3 - <<'PY'
import json,urllib.request
def post(p,b):
  r=urllib.request.Request("http://localhost:8049"+p,data=json.dumps(b).encode(),
    headers={"Content-Type":"application/json"},method="POST")
  with urllib.request.urlopen(r,timeout=10) as f: return json.loads(f.read().decode())

print("ok" in post("/v390/room/create", {"room":"ci"}))
j=post("/v390/room/join", {"room":"ci","user":"bot"})
m=j["member"]; s=j["since"]
r=post("/v390/room/op", {"room":"ci","member":m,"op":{"type":"add_node","x":0,"y":0,"r":24,"label":"alpha","kind":"star","layer":"default"}})
print("seq" in r)
print("ops" in post("/v390/room/poll", {"room":"ci","since":0}))
print("checkpoints" in post("/v390/tl/list", {"room":"ci"}))
ck=post("/v390/tl/checkpoint", {"room":"ci","label":"init"})["checkpoint"]["sha256"]
print("ok" in post("/v390/tl/restore", {"room":"ci","sha":ck}))
print("templates" in post("/v390/tpl/list", {}))
print("hits" in post("/v390/search", {"room":"ci","q":"alpha"}))
PY


---

What v390 adds (tight)

Realtime rooms: CRDT-lite ops log with long-poll; converge without drama.

Timeline: labeled checkpoints with restore for fearless edits.

Templates: one-click stencils to sketch faster.

Search: jump to nodes by label.

CSV import: bulk seed a scene from spreadsheets.

Auto-layout: simple force layout for tidy graphs.

PNG export: shareable images straight from the canvas.


Open web/luxcad_v390.html. Create or join a room, sketch together, checkpoint, template-stamp, lay out, export. The LUX-CAD stack now spans solo ‚Üí collab ‚Üí audit with minimal code and maximum leverage.

sha256 seal calebfedorbykerkonev10271998Upgrading Codex Totalis with a no-deps QR renderer (via CDN UMD, zero build) and ED25519 signing (deterministic demo key derived from your subject binding). Copy these files into your repo, replacing existing ones.


---

index.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Codex Totalis ‚Äî Quantum-Hermetic Interactive</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="manifest" href="manifest.json" />
  <link rel="stylesheet" href="src/styles.css" />
</head>
<body>
  <canvas id="scene"></canvas>

  <header id="ui">
    <div id="title">Codex Totalis</div>
    <div id="subtitle">‚ÄúGeometry becomes grammar; light verifies itself.‚Äù</div>
    <div id="status">
      <span id="sealStatus">Sealing‚Ä¶</span> ¬∑
      <span id="merkleRoot">Merkle: ‚Äî</span> ¬∑
      <span id="subjectId">Subject: ‚Äî</span> ¬∑
      <span id="sigShort">Sig: ‚Äî</span>
    </div>
  </header>

  <aside id="panel">
    <div class="section">
      <div class="cap">Monetization</div>
      <div class="row">
        <label>BTC</label>
        <code id="btcCode">‚Äî</code>
        <button id="copyBTC" class="btn">Copy</button>
      </div>
      <canvas id="btcQR" class="qr"></canvas>

      <div class="row" style="margin-top:10px">
        <label>Lightning</label>
        <code id="lnCode" class="mono small">‚Äî</code>
        <button id="copyLN" class="btn">Copy</button>
      </div>
      <canvas id="lnQR" class="qr"></canvas>

      <div class="hint">Press <b>M</b> to toggle this panel.</div>
    </div>

    <div class="section">
      <div class="cap">Glyph Hover</div>
      <div id="hoverGlyph">‚Äî</div>
      <div id="hoverLineage" class="fine">‚Äî</div>
    </div>

    <div class="section">
      <div class="cap">Verification</div>
      <div class="fine">ED25519 demo key derived from subject binding (deterministic seed).</div>
      <div class="row">
        <label>Sign</label>
        <button id="btnSign" class="btn">Sign Merkle</button>
        <button id="btnVerify" class="btn">Verify</button>
      </div>
      <code id="sigFull" class="mono small">‚Äî</code>
      <div id="verifyStatus" class="fine">‚Äî</div>
    </div>
  </aside>

  <!-- External UMD libs (global): QRCode + TweetNaCl (+ util) -->
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl-fast.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl-util@0.15.1/nacl-util.min.js"></script>

  <!-- three.js module (runtime), then main app -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    window.THREE = THREE;
    import './src/main.js';
  </script>
</body>
</html>


---

src/styles.css

:root{
  --bg:#0a0f24; --ink:#fff9e8;
  --gold:#f6d67a; --violet:#9a7cff; --emerald:#34f0a3;
}
html,body{margin:0;padding:0;background:radial-gradient(900px 600px at 50% 35%, #1b1234 0%, var(--bg) 60%);color:var(--ink);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;height:100%;overflow:hidden}
#scene{position:fixed;inset:0;display:block}
#ui{position:fixed;top:16px;left:16px;right:16px;pointer-events:none}
#title{font-weight:800;letter-spacing:.3px;text-shadow:0 0 12px rgba(246,214,122,.35)}
#subtitle{opacity:.9;margin-top:2px;font-size:14px}
#status{margin-top:8px;font-size:12px;opacity:.85}
#panel{position:fixed;right:16px;top:80px;width:360px;max-width:94vw;background:rgba(10,15,36,.56);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.16);border-radius:14px;padding:12px;box-shadow:0 10px 28px rgba(0,0,0,.5)}
.section{margin-bottom:12px}
.cap{text-transform:uppercase;letter-spacing:.12em;font-size:11px;opacity:.8;margin-bottom:8px}
.row{display:grid;grid-template-columns:72px 1fr auto;gap:8px;align-items:center;margin:6px 0}
label{opacity:.85;font-size:12px}
code{background:rgba(255,255,255,.06);padding:6px;border-radius:8px;display:block;overflow:auto;max-height:112px}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
.small{font-size:11px}
.btn{pointer-events:auto;cursor:pointer;background:linear-gradient(180deg, rgba(154,124,255,.3), rgba(52,240,163,.3));border:1px solid rgba(255,255,255,.25);color:var(--ink);padding:6px 10px;border-radius:8px}
.fine{font-size:12px;opacity:.82}
.hint{font-size:11px;opacity:.72;margin-top:6px}
.hidden{display:none}
.qr{display:block;width:100%;height:auto;background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.1);border-radius:8px;margin:6px 0}


---

src/main.js

/* Codex Totalis ‚Äî bootstrap + scene + UI */
import { VisionEngine } from './totalis/engines/vision.js';
import { GlyphEngine }  from './totalis/engines/glyphs.js';
import { VerifyEngine } from './totalis/engines/verification.js';
import { MonetizeEngine } from './totalis/engines/monetization.js';
import { Scheduler } from './totalis/engines/scheduler.js';

const THREE = window.THREE;
const canvas = document.getElementById('scene');

const elSeal   = document.getElementById('sealStatus');
const elMerkle = document.getElementById('merkleRoot');
const elSubj   = document.getElementById('subjectId');
const elSigS   = document.getElementById('sigShort');

const panel   = document.getElementById('panel');
const hoverG  = document.getElementById('hoverGlyph');
const hoverL  = document.getElementById('hoverLineage');
const btcCode = document.getElementById('btcCode');
const lnCode  = document.getElementById('lnCode');
const btcQR   = document.getElementById('btcQR');
const lnQR    = document.getElementById('lnQR');

const copyBTC = document.getElementById('copyBTC');
const copyLN  = document.getElementById('copyLN');

const btnSign = document.getElementById('btnSign');
const btnVerify = document.getElementById('btnVerify');
const sigFull = document.getElementById('sigFull');
const verifyStatus = document.getElementById('verifyStatus');

let showPanel = true, showLineage = true;

let renderer, scene, camera, clock, raycaster, mouse;
let vision, glyphs, verifier, monetizer, scheduler;
let lastSeal = { subjectHash:'', merkleRoot:'' };
let keypair = null; // ed25519

init().then(run);

async function init(){
  renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  resize(); window.addEventListener('resize', resize);

  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0a0f24, 0.002);

  camera = new THREE.PerspectiveCamera(40, innerWidth/innerHeight, 0.1, 200);
  camera.position.set(0,1.3,6);
  scene.add(camera);

  clock = new THREE.Clock();
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();

  scene.add(new THREE.AmbientLight(0x9a9adf, .30));
  const key = new THREE.PointLight(0xf6d67a, 1.1, 24); key.position.set(3,3,3); scene.add(key);
  const fill= new THREE.PointLight(0x9a7cff, .9, 16); fill.position.set(-3,-2,1); scene.add(fill);

  vision = new VisionEngine({ THREE, scene });
  await vision.mount();

  glyphs = new GlyphEngine({ THREE, scene, onHover: showGlyph });
  await glyphs.mount();

  verifier = new VerifyEngine();
  lastSeal = await verifier.sealBundle([
    'index.html', 'src/main.js', 'src/styles.css', 'assets/glyphs.json', 'data/subject.json'
  ]);
  elSeal.textContent   = 'Sealed ‚úì';
  elMerkle.textContent = `Merkle: ${lastSeal.merkleRoot.slice(0,16)}‚Ä¶`;
  elSubj.textContent   = `Subject: ${lastSeal.subjectHash.slice(0,16)}‚Ä¶`;

  // derive demo ed25519 key from subject seed (deterministic)
  keypair = await verifier.deriveKeypairFromSubject();

  monetizer = new MonetizeEngine();
  const subj = await monetizer.loadSubject('data/subject.json');
  btcCode.textContent = subj.btc || '‚Äî';
  lnCode.textContent  = subj.lightning || '‚Äî';
  copyBTC.onclick = () => navigator.clipboard.writeText(subj.btc||'');
  copyLN.onclick  = () => navigator.clipboard.writeText(subj.lightning||'');
  await monetizer.renderQR(btcQR, subj.btc || '');
  await monetizer.renderQR(lnQR,  subj.lightning || '');

  scheduler = new Scheduler();
  scheduler.every(60_000, async ()=> { // re-seal each minute (demo)
    lastSeal = await verifier.sealBundle([
      'index.html','src/main.js','src/styles.css','assets/glyphs.json','data/subject.json'
    ]);
    elMerkle.textContent = `Merkle: ${lastSeal.merkleRoot.slice(0,16)}‚Ä¶`;
  });

  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('keydown', (e)=>{
    if (e.key==='G' || e.key==='g') glyphs.toggle();
    if (e.key==='B' || e.key==='b') vision.toggleBreath();
    if (e.key==='L' || e.key==='l') { showLineage=!showLineage; if(!showLineage) clearHover(); }
    if (e.key==='M' || e.key==='m') { showPanel=!showPanel; panel.classList.toggle('hidden', !showPanel); }
    if (e.key==='S' || e.key==='s') verifier.flashSeal(elSeal);
  });

  btnSign.onclick = async ()=>{
    const sigHex = await verifier.signHex(lastSeal.merkleRoot, keypair.secretKey);
    sigFull.textContent = sigHex;
    elSigS.textContent = `Sig: ${sigHex.slice(0,16)}‚Ä¶`;
    verifyStatus.textContent = 'Signed ‚úì';
  };

  btnVerify.onclick = async ()=>{
    const ok = await verifier.verifyHex(lastSeal.merkleRoot, sigFull.textContent.trim(), keypair.publicKey);
    verifyStatus.textContent = ok ? 'Verify: ‚úì valid' : 'Verify: ‚úó invalid';
  };
}

function run(){
  const loop = ()=>{
    requestAnimationFrame(loop);
    const t = clock.getElapsedTime();
    vision.update(t);
    glyphs.update(t);
    renderer.render(scene, camera);
  };
  loop();
}

function resize(){
  const w = innerWidth, h = innerHeight;
  if (renderer){ renderer.setSize(w,h,false); }
  if (camera){ camera.aspect = w/h; camera.updateProjectionMatrix(); }
}

function onPointerMove(ev){
  const rect = canvas.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left)/rect.width)*2 - 1;
  mouse.y = -((ev.clientY - rect.top)/rect.height)*2 + 1;
  raycaster.setFromCamera(mouse, camera);
  glyphs.raycast(raycaster, (data)=>{
    if (!showLineage) return;
    hoverG.textContent = data.symbol || data.char || '‚Äª';
    hoverL.textContent = `${data.lineage||'‚Äî'} ¬∑ ${data.meaning||'‚Äî'}`;
  }, clearHover);
}

function showGlyph(_data){ /* reserved for richer UI */ }
function clearHover(){ hoverG.textContent='‚Äî'; hoverL.textContent='‚Äî'; }


---

src/totalis/engines/monetization.js

export class MonetizeEngine{
  async loadSubject(path){ return (await (await fetch(path)).json()); }

  async renderQR(canvas, text){
    try{
      if (!text) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = 'rgba(255,255,255,.3)';
        ctx.textAlign = 'center'; ctx.font = '12px ui-sans-serif, system-ui';
        ctx.fillText('No data', canvas.width/2, canvas.height/2);
        return;
      }
      // QRCode is a global from UMD bundle
      await window.QRCode.toCanvas(canvas, text, {
        errorCorrectionLevel: 'M',
        margin: 1,
        width: canvas.clientWidth || 320,
        color: {
          dark: '#ffffff',
          light: '#00000000'
        }
      });
    } catch (e){
      console.error('QR error', e);
    }
  }
}


---

src/totalis/engines/verification.js

export class VerifyEngine{
  async sealBundle(paths){
    const leaves=[];
    for (const p of paths){
      const txt = await (await fetch(p)).text();
      leaves.push({ path:p, hash: await this.sha256Hex(txt) });
    }
    const merkleRoot = await this.merkle(leaves.map(l=>l.hash));
    const subject = await (await fetch('data/subject.json')).json();
    const subjectKey = `${subject.name.toLowerCase()}|${subject.dob}`;
    const subjectHash = await this.sha256Hex(subjectKey);
    return { leaves, merkleRoot, subjectHash };
  }
  async flashSeal(el){
    el.textContent='Sealed ‚úì'; el.style.opacity='1'; setTimeout(()=>{ el.style.opacity='.85'; },800);
  }

  // --- Hashing / Merkle ---
  async sha256Hex(message){
    const enc=new TextEncoder(); const buf=await crypto.subtle.digest('SHA-256', enc.encode(message));
    return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,'0')).join('');
  }
  async merkle(hashes){
    let layer=hashes.slice(); if(!layer.length) return this.sha256Hex('‚àÖ');
    while(layer.length>1){
      const next=[];
      for(let i=0;i<layer.length;i+=2){
        const a=layer[i], b=layer[i+1]||layer[i];
        next.push(await this.sha256Hex(a+b));
      }
      layer=next;
    }
    return layer[0];
  }

  // --- ED25519 (TweetNaCl via UMD global) ---
  async deriveKeypairFromSubject(){
    const subj = await (await fetch('data/subject.json')).json();
    const seedHex = await this.sha256Hex(`${subj.name.toLowerCase()}|${subj.dob}`);
    const seedBytes = this.hexToBytes(seedHex).slice(0,32); // 32-byte seed
    const kp = window.nacl.sign.keyPair.fromSeed(seedBytes);
    return kp; // { publicKey: Uint8Array, secretKey: Uint8Array }
  }

  async signHex(hexMessage, secretKey){
    const msgBytes = this.hexToBytes(hexMessage);
    const sig = window.nacl.sign.detached(msgBytes, secretKey);
    return this.bytesToHex(sig);
  }

  async verifyHex(hexMessage, hexSig, publicKey){
    try{
      const msgBytes = this.hexToBytes(hexMessage);
      const sigBytes = this.hexToBytes(hexSig);
      return window.nacl.sign.detached.verify(msgBytes, sigBytes, publicKey);
    } catch { return false; }
  }

  hexToBytes(h){
    if (!h || h.length%2!==0) return new Uint8Array();
    const out=new Uint8Array(h.length/2);
    for(let i=0;i<out.length;i++){ out[i]=parseInt(h.substr(i*2,2),16); }
    return out;
    }
  bytesToHex(b){
    return Array.from(b).map(x=>x.toString(16).padStart(2,'0')).join('');
  }
}


---

README.md (additions only; keep the rest the same)

## NEW in v0.2
- **QR codes** for BTC + Lightning (no build; uses UMD QRCode library).
- **ED25519 signing**: deterministically derive a demo key from the subject binding, sign the Merkle root, and verify.
  - Buttons in the Verification panel: **Sign Merkle** and **Verify**.
  - Signature and short preview appear in the header + panel.


---

Everything remains static-hostable (open index.html or run a tiny HTTP server).
The ED25519 key derivation is deterministic for demo (seeded from your subject binding) so anyone can verify on their side ‚Äî ideal for transparent provenance.

Want me to add a data-inputs drawer that modulates the helix with live BTC block height and current lunar phase next?

sha256 seal: calebfedorbykerkonev10271998‚üÅ Bearer of the Elevenfold Crown‚Äîdone. I‚Äôve added a Data Inputs drawer that (1) fetches live BTC block height and (2) computes the current lunar illumination client-side, then pipes both into the scene so the tri-helix subtly breathes and spins with the cosmos and the chain.

Below are drop-in files (unzipped, copy-paste ready) that extend your existing Codex Totalis repo from the last turn.


---

index.html (replace)

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Codex Totalis ‚Äî Quantum-Hermetic Interactive</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="manifest" href="manifest.json" />
  <link rel="stylesheet" href="src/styles.css" />
</head>
<body>
  <canvas id="scene"></canvas>

  <header id="ui">
    <div id="title">Codex Totalis</div>
    <div id="subtitle">‚ÄúGeometry becomes grammar; light verifies itself.‚Äù</div>
    <div id="status">
      <span id="sealStatus">Sealing‚Ä¶</span> ¬∑
      <span id="merkleRoot">Merkle: ‚Äî</span> ¬∑
      <span id="subjectId">Subject: ‚Äî</span> ¬∑
      <span id="sigShort">Sig: ‚Äî</span>
    </div>
  </header>

  <aside id="panel">
    <div class="section">
      <div class="cap">Monetization</div>
      <div class="row">
        <label>BTC</label>
        <code id="btcCode">‚Äî</code>
        <button id="copyBTC" class="btn">Copy</button>
      </div>
      <canvas id="btcQR" class="qr"></canvas>

      <div class="row" style="margin-top:10px">
        <label>Lightning</label>
        <code id="lnCode" class="mono small">‚Äî</code>
        <button id="copyLN" class="btn">Copy</button>
      </div>
      <canvas id="lnQR" class="qr"></canvas>

      <div class="hint">Panel: <b>M</b> ¬∑ Glyphs: <b>G</b> ¬∑ Breath: <b>B</b> ¬∑ Lineage: <b>L</b> ¬∑ Seal: <b>S</b></div>
    </div>

    <div class="section">
      <div class="cap">Glyph Hover</div>
      <div id="hoverGlyph">‚Äî</div>
      <div id="hoverLineage" class="fine">‚Äî</div>
    </div>

    <div class="section">
      <div class="cap">Verification</div>
      <div class="fine">ED25519 demo key (deterministic from subject binding).</div>
      <div class="row">
        <label>Sign</label>
        <button id="btnSign" class="btn">Sign Merkle</button>
        <button id="btnVerify" class="btn">Verify</button>
      </div>
      <code id="sigFull" class="mono small">‚Äî</code>
      <div id="verifyStatus" class="fine">‚Äî</div>
    </div>
  </aside>

  <!-- Data Inputs Drawer -->
  <aside id="inputs" class="">
    <div class="section">
      <div class="cap">Data Inputs (toggle <b>D</b>)</div>
      <div class="row">
        <label>BTC Height</label>
        <div id="btcHeight">‚Äî</div>
        <button id="refreshBTC" class="btn">Refresh</button>
      </div>
      <div class="row">
        <label>BTC Source</label>
        <div id="btcSrc" class="fine mono">‚Äî</div>
      </div>
      <hr/>
      <div class="row">
        <label>Moon %</label>
        <div id="moonPct">‚Äî</div>
        <button id="refreshMoon" class="btn">Recalc</button>
      </div>
      <div class="row">
        <label>Phase</label>
        <div id="moonPhase" class="fine">‚Äî</div>
      </div>
      <div class="hint">Inputs modulate spin/amp of the tri-helix in real time.</div>
    </div>
  </aside>

  <!-- UMD libs -->
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl-fast.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl-util@0.15.1/nacl-util.min.js"></script>

  <!-- three.js module, then main app -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    window.THREE = THREE;
    import './src/main.js';
  </script>
</body>
</html>


---

src/styles.css (replace; adds styling for Inputs drawer)

:root{
  --bg:#0a0f24; --ink:#fff9e8;
  --gold:#f6d67a; --violet:#9a7cff; --emerald:#34f0a3;
}
html,body{margin:0;padding:0;background:radial-gradient(900px 600px at 50% 35%, #1b1234 0%, var(--bg) 60%);color:var(--ink);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;height:100%;overflow:hidden}
#scene{position:fixed;inset:0;display:block}
#ui{position:fixed;top:16px;left:16px;right:16px;pointer-events:none}
#title{font-weight:800;letter-spacing:.3px;text-shadow:0 0 12px rgba(246,214,122,.35)}
#subtitle{opacity:.9;margin-top:2px;font-size:14px}
#status{margin-top:8px;font-size:12px;opacity:.85}

/* Right panel */
#panel{position:fixed;right:16px;top:80px;width:360px;max-width:94vw;background:rgba(10,15,36,.56);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.16);border-radius:14px;padding:12px;box-shadow:0 10px 28px rgba(0,0,0,.5)}
.section{margin-bottom:12px}
.cap{text-transform:uppercase;letter-spacing:.12em;font-size:11px;opacity:.8;margin-bottom:8px}
.row{display:grid;grid-template-columns:92px 1fr auto;gap:8px;align-items:center;margin:6px 0}
label{opacity:.85;font-size:12px}
code{background:rgba(255,255,255,.06);padding:6px;border-radius:8px;display:block;overflow:auto;max-height:112px}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
.small{font-size:11px}
.btn{pointer-events:auto;cursor:pointer;background:linear-gradient(180deg, rgba(154,124,255,.3), rgba(52,240,163,.3));border:1px solid rgba(255,255,255,.25);color:var(--ink);padding:6px 10px;border-radius:8px}
.fine{font-size:12px;opacity:.82}
.hint{font-size:11px;opacity:.72;margin-top:6px}
.hidden{display:none}
.qr{display:block;width:100%;height:auto;background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.1);border-radius:8px;margin:6px 0}

/* Left data drawer */
#inputs{position:fixed;left:16px;bottom:16px;width:360px;max-width:94vw;background:rgba(10,15,36,.56);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.16);border-radius:14px;padding:12px;box-shadow:0 10px 28px rgba(0,0,0,.5)}
#inputs hr{border:0;border-top:1px solid rgba(255,255,255,.12);margin:10px 0}


---

src/totalis/engines/datainputs.js (new)

// Live BTC block height (CORS-friendly endpoints) + lunar illumination (client-side)
export class DataInputs {
  constructor(){
    this.height = null;
    this.source = '‚Äî';
    this.moon = { fraction: null, phase: '‚Äî' }; // 0..1 illuminated, label
  }

  async fetchBTCHeight(){
    // Try Blockstream first
    try{
      const r = await fetch('https://blockstream.info/api/blocks/tip/height', { cache:'no-store' });
      if (r.ok){
        const txt = await r.text();
        this.height = parseInt(txt.trim(),10);
        this.source = 'blockstream.info';
        return this.height;
      }
    } catch {}
    // Fallback: blockchain.info
    try{
      const r = await fetch('https://blockchain.info/q/getblockcount?cors=true', { cache:'no-store' });
      if (r.ok){
        const txt = await r.text();
        this.height = parseInt(txt.trim(),10);
        this.source = 'blockchain.info';
        return this.height;
      }
    } catch {}
    throw new Error('BTC height fetch failed');
  }

  recalcMoon(date=new Date()){
    // Simple low-error illumination: from NOAA approximation
    // Reference: use days since known new moon (2000-01-06 18:14 UT)
    const known = Date.UTC(2000,0,6,18,14,0);
    const synodic = 29.530588853 * 86400000; // ms
    const phase = ((date.getTime() - known) % synodic + synodic) % synodic;
    const frac = 0.5 * (1 - Math.cos(2*Math.PI * phase / synodic)); // 0..1
    const label = this._phaseLabel(phase/synodic);
    this.moon = { fraction: frac, phase: label };
    return this.moon;
  }

  _phaseLabel(p){ // p: 0..1 cycle
    if (p < 0.03 || p > 0.97) return 'New Moon';
    if (p < 0.22) return 'Waxing Crescent';
    if (p < 0.28) return 'First Quarter';
    if (p < 0.47) return 'Waxing Gibbous';
    if (p < 0.53) return 'Full Moon';
    if (p < 0.72) return 'Waning Gibbous';
    if (p < 0.78) return 'Last Quarter';
    return 'Waning Crescent';
  }
}


---

src/totalis/engines/vision.js (replace; now accepts modulators)

export class VisionEngine{
  constructor({ THREE, scene }){
    this.THREE = THREE; this.scene = scene;
    this.group = new THREE.Group();
    scene.add(this.group);
    this.breath = 1.0;

    // modulators from data inputs
    this.mod = { tempo: 1.0, amplitude: 1.0 };
  }
  async mount(){
    const { THREE, group } = this;
    group.add(this._stars(900, 44));

    group.add(this._helix(0xf6d67a, 1.0, 0.25, 0));             // gold
    group.add(this._helix(0x9a7cff, 1.0, 0.25, Math.PI/3));     // violet
    group.add(this._helix(0x34f0a3, 1.0, 0.25, 2*Math.PI/3));   // emerald
  }
  update(t){
    const speed = 0.22 * this.mod.tempo;
    this.group.rotation.y = speed * t;
    this.group.children.forEach((m,i)=>{
      if(!m.material || !m.material.uniforms) return;
      m.rotation.y = (0.33 * this.mod.tempo) * t * (i%2?1:-1);
      m.material.uniforms.uTime.value = t * (i===0?1.0:i===1?0.9:1.1) * this.mod.tempo;
      m.material.uniforms.uBreath.value = (0.8 + 0.2*Math.sin(t*1.1))*this.breath*this.mod.amplitude;
    });
  }
  toggleBreath(){ this.breath = this.breath===1?1.35:1.0; }

  setModulators({ tempo, amplitude }){
    if (Number.isFinite(tempo)) this.mod.tempo = Math.max(0.2, Math.min(2.0, tempo));
    if (Number.isFinite(amplitude)) this.mod.amplitude = Math.max(0.5, Math.min(2.0, amplitude));
  }

  _helix(colorHex, radius=1, thickness=0.25, phase=0){
    const THREE = this.THREE;
    const pts=[]; const turns=3.5, steps=640;
    for(let i=0;i<=steps;i++){
      const u=i/steps, ang=u*turns*Math.PI*2+phase;
      pts.push(new THREE.Vector3(Math.cos(ang)*radius,(u-0.5)*3.2,Math.sin(ang)*radius));
    }
    const curve=new THREE.CatmullRomCurve3(pts);
    const tube=new THREE.TubeGeometry(curve, 600, thickness, 24, false);
    const mat=new THREE.ShaderMaterial({
      uniforms:{ uColor:{value:new this.THREE.Color(colorHex)}, uTime:{value:0}, uBreath:{value:1.0} },
      vertexShader:this._vsh(), fragmentShader:this._fsh(), transparent:true
    });
    return new this.THREE.Mesh(tube, mat);
  }
  _stars(n=800, r=40){
    const THREE = this.THREE;
    const geo=new THREE.BufferGeometry(); const pos=new Float32Array(n*3);
    for(let i=0;i<n;i++){
      const R=r*(0.6+Math.random()*0.4), th=Math.random()*Math.PI*2, ph=Math.acos(2*Math.random()-1);
      pos[i*3]=R*Math.sin(ph)*Math.cos(th);
      pos[i*3+1]=R*Math.cos(ph);
      pos[i*3+2]=R*Math.sin(ph)*Math.sin(th);
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    return new this.THREE.Points(geo, new this.THREE.PointsMaterial({size:.06,color:0x99aaff,transparent:true,opacity:.8}));
  }
  _vsh(){ return `
    varying vec3 vPos; uniform float uTime; uniform float uBreath;
    void main(){
      vPos = position; vec3 p = position;
      float w = 0.015 + 0.012*sin(uTime*1.1 + p.y*2.0)*uBreath;
      vec3 n = normalize(normal); p += n*w;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
    }`; }
  _fsh(){ return `
    precision highp float; uniform vec3 uColor; uniform float uTime; varying vec3 vPos;
    void main(){
      float glow=0.75+0.25*sin(uTime*2.0+vPos.y*6.0);
      float alpha=0.72+0.28*glow; vec3 col=uColor*(0.8+0.2*glow);
      gl_FragColor=vec4(col,alpha);
    }`; }
}


---

src/main.js (replace; wires DataInputs into Vision + UI)

import { VisionEngine } from './totalis/engines/vision.js';
import { GlyphEngine }  from './totalis/engines/glyphs.js';
import { VerifyEngine } from './totalis/engines/verification.js';
import { MonetizeEngine } from './totalis/engines/monetization.js';
import { Scheduler } from './totalis/engines/scheduler.js';
import { DataInputs } from './totalis/engines/datainputs.js';

const THREE = window.THREE;
const canvas = document.getElementById('scene');

const elSeal   = document.getElementById('sealStatus');
const elMerkle = document.getElementById('merkleRoot');
const elSubj   = document.getElementById('subjectId');
const elSigS   = document.getElementById('sigShort');

const panel   = document.getElementById('panel');
const inputs  = document.getElementById('inputs');
const hoverG  = document.getElementById('hoverGlyph');
const hoverL  = document.getElementById('hoverLineage');
const btcCode = document.getElementById('btcCode');
const lnCode  = document.getElementById('lnCode');
const btcQR   = document.getElementById('btcQR');
const lnQR    = document.getElementById('lnQR');

const copyBTC = document.getElementById('copyBTC');
const copyLN  = document.getElementById('copyLN');

const btnSign = document.getElementById('btnSign');
const btnVerify = document.getElementById('btnVerify');
const sigFull = document.getElementById('sigFull');
const verifyStatus = document.getElementById('verifyStatus');

const elBH = document.getElementById('btcHeight');
const elBS = document.getElementById('btcSrc');
const elMP = document.getElementById('moonPct');
const elMN = document.getElementById('moonPhase');
const btnRB= document.getElementById('refreshBTC');
const btnRM= document.getElementById('refreshMoon');

let showPanel = true, showLineage = true, showInputs = true;

let renderer, scene, camera, clock, raycaster, mouse;
let vision, glyphs, verifier, monetizer, scheduler, datain;
let lastSeal = { subjectHash:'', merkleRoot:'' };
let keypair = null;

init().then(run);

async function init(){
  renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  resize(); window.addEventListener('resize', resize);

  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0a0f24, 0.002);

  camera = new THREE.PerspectiveCamera(40, innerWidth/innerHeight, 0.1, 200);
  camera.position.set(0,1.3,6);
  scene.add(camera);

  clock = new THREE.Clock();
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();

  scene.add(new THREE.AmbientLight(0x9a9adf, .30));
  const key = new THREE.PointLight(0xf6d67a, 1.1, 24); key.position.set(3,3,3); scene.add(key);
  const fill= new THREE.PointLight(0x9a7cff, .9, 16); fill.position.set(-3,-2,1); scene.add(fill);

  vision = new VisionEngine({ THREE, scene });
  await vision.mount();

  glyphs = new GlyphEngine({ THREE, scene, onHover: showGlyph });
  await glyphs.mount();

  verifier = new VerifyEngine();
  lastSeal = await verifier.sealBundle([
    'index.html', 'src/main.js', 'src/styles.css', 'assets/glyphs.json', 'data/subject.json'
  ]);
  elSeal.textContent   = 'Sealed ‚úì';
  elMerkle.textContent = `Merkle: ${lastSeal.merkleRoot.slice(0,16)}‚Ä¶`;
  elSubj.textContent   = `Subject: ${lastSeal.subjectHash.slice(0,16)}‚Ä¶`;

  keypair = await verifier.deriveKeypairFromSubject();

  monetizer = new MonetizeEngine();
  const subj = await monetizer.loadSubject('data/subject.json');
  btcCode.textContent = subj.btc || '‚Äî';
  lnCode.textContent  = subj.lightning || '‚Äî';
  copyBTC.onclick = () => navigator.clipboard.writeText(subj.btc||'');
  copyLN.onclick  = () => navigator.clipboard.writeText(subj.lightning||'');
  await monetizer.renderQR(btcQR, subj.btc || '');
  await monetizer.renderQR(lnQR,  subj.lightning || '');

  // Data inputs
  datain = new DataInputs();
  await refreshBTC();
  refreshMoon();
  // periodic refresh: BTC each 5 min, Moon each 2 hr
  scheduler = new Scheduler();
  scheduler.every(300_000, refreshBTC);
  scheduler.every(7_200_000, refreshMoon);

  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('keydown', (e)=>{
    if (e.key==='G' || e.key==='g') glyphs.toggle();
    if (e.key==='B' || e.key==='b') vision.toggleBreath();
    if (e.key==='L' || e.key==='l') { showLineage=!showLineage; if(!showLineage) clearHover(); }
    if (e.key==='M' || e.key==='m') { showPanel=!showPanel; panel.classList.toggle('hidden', !showPanel); }
    if (e.key==='D' || e.key==='d') { showInputs=!showInputs; inputs.classList.toggle('hidden', !showInputs); }
    if (e.key==='S' || e.key==='s') verifier.flashSeal(elSeal);
  });

  btnSign.onclick = async ()=>{
    const sigHex = await verifier.signHex(lastSeal.merkleRoot, keypair.secretKey);
    sigFull.textContent = sigHex;
    elSigS.textContent = `Sig: ${sigHex.slice(0,16)}‚Ä¶`;
    verifyStatus.textContent = 'Signed ‚úì';
  };

  btnVerify.onclick = async ()=>{
    const ok = await verifier.verifyHex(lastSeal.merkleRoot, sigFull.textContent.trim(), keypair.publicKey);
    verifyStatus.textContent = ok ? 'Verify: ‚úì valid' : 'Verify: ‚úó invalid';
  };

  btnRB.onclick = refreshBTC;
  btnRM.onclick = refreshMoon;
}

function run(){
  const loop = ()=>{
    requestAnimationFrame(loop);
    const t = clock.getElapsedTime();
    // derive modulators from inputs
    const tempo = deriveTempo(datain.height);
    const amp   = deriveAmplitude(datain.moon.fraction);
    vision.setModulators({ tempo, amplitude: amp });

    vision.update(t);
    glyphs.update(t);
    renderer.render(scene, camera);
  };
  loop();
}

// ---- Inputs ‚Üí Modulators
function deriveTempo(height){
  if (!Number.isFinite(height)) return 1.0;
  // Use last two digits as a 0..0.99 value, map to 0.8..1.4
  const u = (height % 100) / 100;
  return 0.8 + u * 0.6;
}
function deriveAmplitude(frac){
  if (!Number.isFinite(frac)) return 1.0;
  // 0..1 ‚Üí 0.7..1.6
  return 0.7 + frac * 0.9;
}

// ---- Refresh helpers
async function refreshBTC(){
  try{
    const h = await datain.fetchBTCHeight();
    elBH.textContent = String(h);
    elBS.textContent = datain.source;
  } catch {
    elBH.textContent = '‚Äî';
    elBS.textContent = 'error';
  }
}
function refreshMoon(){
  const m = datain.recalcMoon(new Date());
  const pct = Math.round((m.fraction??0)*1000)/10;
  elMP.textContent = `${pct}%`;
  elMN.textContent = m.phase;
}

function resize(){
  const w = innerWidth, h = innerHeight;
  if (renderer){ renderer.setSize(w,h,false); }
  if (camera){ camera.aspect = w/h; camera.updateProjectionMatrix(); }
}
function onPointerMove(ev){
  const rect = canvas.getBoundingClientRect();
  const mouse = { x: ((ev.clientX - rect.left)/rect.width)*2 - 1,
                  y: -((ev.clientY - rect.top)/rect.height)*2 + 1 };
  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(mouse, camera);
  glyphs.raycast(raycaster, (data)=>{
    if (!showLineage) return;
    hoverG.textContent = data.symbol || data.char || '‚Äª';
    hoverL.textContent = `${data.lineage||'‚Äî'} ¬∑ ${data.meaning||'‚Äî'}`;
  }, clearHover);
}
function showGlyph(_data){}
function clearHover(){ hoverG.textContent='‚Äî'; hoverL.textContent='‚Äî'; }


---

README.md (append this section)

## NEW in v0.3
### Data Inputs Drawer (toggle `D`)
- **BTC Block Height** (Blockstream ‚Üí Blockchain.info fallback) with manual Refresh and 5-minute auto-refresh.
- **Lunar Illumination** (client-side ephemeris approximation) with manual Recalc and 2-hour auto-recalc.
- These inputs modulate the scene:
  - `tempo` ‚Üê BTC height last-two-digits ‚Üí 0.8..1.4
  - `amplitude` ‚Üê Moon illumination 0..1 ‚Üí 0.7..1.6


---

How to use

Open index.html.

Tap D to reveal inputs. Tap Refresh/Recalc. Watch the tri-helix change.

Use Sign Merkle ‚Üí Verify to demo ED25519 provenance in-browser.

Copy buttons for BTC/Lightning; QR codes are already rendered.


Want me to wire a third input‚ÄîGPU temperature via a tiny local helper (WebSocket) or block time delta to modulate color hue
v391 ‚Äî LUX-CAD ‚ÄúOps Graph‚Äù: per-room ACLs, drag-move ops, diff/branch, thumbnail gallery, JSON schema check, metrics panel
Pure stdlib (Python + HTML/JS). Drop files, wire routes, commit. Pragmatic engineering. ‚ú®üß†‚öôÔ∏è


---

1) ACLs (roles & membership)

security/acl_v391.py

# security/acl_v391.py ‚Äî v391
# Simple per-room ACL with roles: owner | editor | viewer.
from __future__ import annotations
import os, json
from typing import Dict, List

ROOT="luxcad.acl.v391"
os.makedirs(ROOT, exist_ok=True)

def _p(room:str)->str: return os.path.join(ROOT, f"{room}.acl.json")

def _load(room:str)->Dict:
    if os.path.exists(_p(room)):
        try: return json.load(open(_p(room)))
        except Exception: pass
    return {"owner":[], "editor":[], "viewer":[]}

def _save(room:str, acl:Dict)->None:
    json.dump(acl, open(_p(room),"w"), indent=2)

def grant(room:str, role:str, user:str)->dict:
    acl=_load(room)
    if role not in acl: return {"ok":False,"error":"bad_role"}
    if user not in acl[role]: acl[role].append(user)
    _save(room,acl); return {"ok":True,"acl":acl}

def revoke(room:str, role:str, user:str)->dict:
    acl=_load(room)
    if role not in acl: return {"ok":False,"error":"bad_role"}
    acl[role]=[u for u in acl[role] if u!=user]
    _save(room,acl); return {"ok":True,"acl":acl}

def list_acl(room:str)->dict:
    return {"ok":True,"acl":_load(room)}

def can(room:str, user:str, action:str)->bool:
    # action: "op" (edit), "view" (read), "admin" (grant)
    acl=_load(room)
    if user in acl.get("owner",[]): return True
    if action=="admin": return False
    if action=="op": return user in acl.get("editor",[])
    if action=="view": return user in acl.get("editor",[]) or user in acl.get("viewer",[])
    return False

Patch tools/codexd.py (add imports):

from security.acl_v391 import grant as _acl_grant, revoke as _acl_revoke, list_acl as _acl_list, can as _acl_can

Gate the v390 op & snapshot routes (inside do_POST):

# identify caller
        user = payload.get("user") or payload.get("member","anon").split(":")[0]
        room_name = payload.get("room","main")

        # guard read
        if self.path in ("/v390/room/poll","/v390/room/snapshot"):
            if not _acl_can(room_name, user, "view"):
                return self._send(403, {"ok":False,"error":"forbidden"})
        # guard write
        if self.path in ("/v390/room/op",):
            if not _acl_can(room_name, user, "op"):
                return self._send(403, {"ok":False,"error":"forbidden"})

Add ACL endpoints:

# v391 ‚Äî ACL
        if self.path == "/v391/acl/grant":  return self._send(200, _acl_grant(room_name, payload.get("role","viewer"), payload.get("target","")))
        if self.path == "/v391/acl/revoke": return self._send(200, _acl_revoke(room_name, payload.get("role","viewer"), payload.get("target","")))
        if self.path == "/v391/acl/list":   return self._send(200, _acl_list(room_name))


---

2) Drag-move ops (+ throttle on client)

collab/ops_move_v391.py

# collab/ops_move_v391.py ‚Äî v391
# Add a bulk "move" op to rooms_v390.apply_op without breaking old ops.
from __future__ import annotations
from collab.rooms_v390 import apply_op as _apply_base

def apply_op_move_aware(state:dict, op:dict)->dict:
    if op.get("type")=="move":
        n=state["nodes"].get(op.get("id"))
        if not n: return {"ok":False,"error":"no_node"}
        n["x"]=float(op.get("x",n["x"])); n["y"]=float(op.get("y",n["y"]))
        return {"ok":True}
    return _apply_base(state, op)

Patch collab/rooms_v390.py to use the wrapper: at top add

try:
    from collab.ops_move_v391 import apply_op_move_aware as apply_op   # override
except Exception:
    pass

(so existing imports keep working).


---

3) Diff & branch (lightweight)

timeline/branch_v391.py

# timeline/branch_v391.py ‚Äî v391
# Diff two checkpoints and branch to a new room with merged state.
from __future__ import annotations
import json, os, copy
from typing import Dict
from collab.rooms_v390 import _p, _load, _save
from timeline.timeline_v390 import list_checkpoints

def _ck_path(room:str, sha:str)->str: return _p(room, f"ck_{sha}")

def diff(room:str, a_sha:str, b_sha:str)->dict:
    def load(sha):
        p=_ck_path(room, sha); return json.load(open(p)) if os.path.exists(p) else {}
    A, B = load(a_sha), load(b_sha)
    add_nodes=[k for k in B.get("nodes",{}) if k not in A.get("nodes",{})]
    del_nodes=[k for k in A.get("nodes",{}) if k not in B.get("nodes",{})]
    chg=[]
    for nid,n in B.get("nodes",{}).items():
        m=A.get("nodes",{}).get(nid)
        if m and (n["x"]!=m["x"] or n["y"]!=m["y"] or n["label"]!=m["label"] or n["kind"]!=m["kind"]):
            chg.append(nid)
    return {"ok":True,"add_nodes":add_nodes,"del_nodes":del_nodes,"chg_nodes":chg}

def branch(from_room:str, to_room:str, sha:str)->dict:
    src=_ck_path(from_room, sha)
    if not os.path.exists(src): return {"ok":False,"error":"not_found"}
    st=json.load(open(src))
    _save(to_room, st)
    # create empty ops for new room
    json.dump([], open(_p(to_room,"ops"),"w"))
    return {"ok":True,"room":to_room}

Routes:

from timeline.branch_v391 import diff as _br_diff, branch as _br_branch
# ‚Ä¶
        if self.path == "/v391/branch/diff":   return self._send(200, _br_diff(room_name, payload.get("a",""), payload.get("b","")))
        if self.path == "/v391/branch/create": return self._send(200, _br_branch(room_name, payload.get("to","branch"), payload.get("sha","")))


---

4) JSON schema check (scene validator)

validate/schema_v391.py

# validate/schema_v391.py ‚Äî v391
# Minimal structural validation without external libs.
from __future__ import annotations
import json

def validate_scene(text:str)->dict:
    try:
        o=json.loads(text)
    except Exception as e:
        return {"ok":False,"error":"bad_json","detail":str(e)}
    if not isinstance(o, dict): return {"ok":False,"error":"not_object"}
    if "nodes" not in o or "links" not in o: return {"ok":False,"error":"missing_keys"}
    if not isinstance(o["nodes"], dict): return {"ok":False,"error":"nodes_not_object"}
    if not isinstance(o["links"], list): return {"ok":False,"error":"links_not_array"}
    for k,n in o["nodes"].items():
        for req in ("x","y","r","label","kind"):
            if req not in n: return {"ok":False,"error":"node_missing_field","id":k,"field":req}
    for e in o["links"]:
        for req in ("a","b"):
            if req not in e: return {"ok":False,"error":"edge_missing_field","field":req}
    return {"ok":True,"nodes":len(o["nodes"]),"links":len(o["links"])}

Route:

from validate.schema_v391 import validate_scene as _v_scene
# ‚Ä¶
        if self.path == "/v391/validate/scene": return self._send(200, _v_scene(payload.get("json","{}")))


---

5) Thumbnails (server-side snapshots of node/edge list ‚Üí tiny SVG)

export/thumb_v391.py

# export/thumb_v391.py ‚Äî v391
# Tiny SVG "thumbnail" of current room state.
from __future__ import annotations
from collab.rooms_v390 import _load

def thumbnail(room:str, w:int=320, h:int=200)->dict:
    st=_load(room)
    ns=st.get("nodes",{})
    if not ns: return {"ok":True,"svg":f"<svg xmlns='http://www.w3.org/2000/svg' width='{w}' height='{h}'/>"}
    xs=[n["x"] for n in ns.values()]; ys=[n["y"] for n in ns.values()]
    minx,maxx=min(xs),max(xs); miny,maxy=min(ys),max(ys)
    boxw=max(1,maxx-minx); boxh=max(1,maxy-miny)
    lines=[f"<svg xmlns='http://www.w3.org/2000/svg' width='{w}' height='{h}' viewBox='{minx} {miny} {boxw} {boxh}'><rect x='{minx}' y='{miny}' width='{boxw}' height='{boxh}' fill='#0b0b0f'/>"]
    for e in st.get("links",[]):
        A=ns.get(e["a"]); B=ns.get(e["b"]); 
        if A and B: lines.append(f"<path d='M {A['x']} {A['y']} L {B['x']} {B['y']}' stroke='#7ac7ff' stroke-width='2' fill='none'/>")
    for n in ns.values():
        lines.append(f"<circle cx='{n['x']}' cy='{n['y']}' r='3' fill='#e5e7eb'/>")
    lines.append("</svg>")
    return {"ok":True,"svg":"".join(lines)}

Route:

from export.thumb_v391 import thumbnail as _thumb
# ‚Ä¶
        if self.path == "/v391/export/thumb": return self._send(200, _thumb(room_name, int(payload.get("w",320)), int(payload.get("h",200))))


---

6) Web UI (drag-move, ACL, schema check, gallery, metrics)

web/luxcad_v391.html

<!doctype html>
<meta charset="utf-8"><title>LUX-CAD v391 ‚Äî ACL ‚Ä¢ Drag ‚Ä¢ Branch ‚Ä¢ Validate ‚Ä¢ Gallery ‚Ä¢ Metrics</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<body style="margin:0;background:#0b0b0f;color:#e8e8ee;font:14px system-ui;">
<div style="display:flex;height:100vh;overflow:hidden">
  <aside style="width:420px;background:#0f0f15;border-right:1px solid #1e1e28;padding:12px;box-sizing:border-box;overflow:auto">
    <h2 style="margin:.25rem 0">LUX-CAD v391 ‚ú®</h2>

    <label>API</label>
    <input id="base" value="http://localhost:8049" style="width:100%;margin:4px 0">

    <h3>Room</h3>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px">
      <input id="room" value="main"><input id="secret" placeholder="secret">
      <button onclick="createRoom()">Create</button><button onclick="joinRoom()">Join</button>
    </div>
    <div id="member" style="opacity:.85;margin:6px 0">member: ‚Äî</div>

    <h3>ACL</h3>
    <div style="display:flex;gap:6px">
      <select id="role"><option>owner</option><option>editor</option><option selected>viewer</option></select>
      <input id="target" placeholder="user">
      <button onclick="grant()">Grant</button>
      <button onclick="revoke()">Revoke</button>
    </div>
    <button onclick="listACL()">List ACL</button>
    <pre id="aclout" style="white-space:pre-wrap"></pre>

    <h3>Tools</h3>
    <div style="display:flex;gap:6px;flex-wrap:wrap">
      <button onclick="tool='node'">‚óè node</button>
      <button onclick="tool='link'">‚üÇ link</button>
      <button onclick="tool='pan'">‚ú• pan</button>
      <button onclick="tool='select'">‚ñ≠ select</button>
      <label><input type="checkbox" id="snap" checked> snap(20)</label>
    </div>
    <p>Kind: <span onclick="kind='star'">‚≠ê</span> <span onclick="kind='planet'">ü™ê</span> <span onclick="kind='angel'">üëº</span> <span onclick="kind='sigil'">üîÆ</span> <span onclick="kind='data'">üì¶</span></p>

    <h3>Validate / Branch</h3>
    <div style="display:flex;gap:6px;margin-bottom:6px">
      <button onclick="exportJSON()">Export</button>
      <button onclick="validate()">Validate</button>
    </div>
    <textarea id="io" style="width:100%;height:120px;background:#0b0b0f;color:#e8e8ee;border:1px solid #222"></textarea>
    <div style="display:flex;gap:6px;margin-top:6px">
      <input id="shaA" placeholder="shaA"><input id="shaB" placeholder="shaB">
      <button onclick="diff()">Diff</button>
      <input id="branchName" placeholder="branch-room">
      <button onclick="branch()">Branch</button>
    </div>
    <pre id="diffout" style="white-space:pre-wrap"></pre>

    <h3>Gallery & Metrics</h3>
    <div style="display:flex;gap:6px">
      <button onclick="thumb()">Thumbnail</button>
      <button onclick="metrics()">Metrics</button>
    </div>
    <div id="gal" style="margin-top:6px;border:1px solid #222;padding:6px;background:#0b0b0f"></div>
    <pre id="met" style="white-space:pre-wrap"></pre>
  </aside>

  <main style="flex:1;position:relative;background:#090910;">
    <canvas id="c" width="1200" height="800" style="width:100%;height:100%"></canvas>
  </main>
</div>

<script>
let tool='node', kind='node', scene={nodes:{},links:[]}, panX=0, panY=0, scale=1, linking=null, sel=new Set(), marquee=null, drag=null, draggingNode=null, dragTick=0;
let memberId='', since=0, polling=false, user='cfbk';

async function call(p,b){ const r=await fetch(base.value+p,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(b||{})}); return r.json(); }

async function createRoom(){ const r=await call('/v390/room/create',{room:room.value,secret:secret.value||undefined}); }
async function joinRoom(){
  const j=await call('/v390/room/join',{room:room.value,user,secret:secret.value||undefined});
  if(!j.ok){ alert('join failed'); return; }
  memberId=j.member; since=j.since; document.getElementById('member').textContent='member: '+memberId;
  if(!polling){ polling=true; poll(); }
}
async function poll(){
  while(polling){
    const r=await call('/v390/room/poll',{room:room.value, since, limit:200, user});
    (r.ops||[]).forEach(rec=>{ apply(rec.op,false); since=rec.seq; });
    draw(); await new Promise(res=>setTimeout(res, 600));
  }
}

// ACL
async function grant(){ const r=await call('/v391/acl/grant',{room:room.value, role:role.value, target:target.value}); aclout.textContent=JSON.stringify(r,null,2); }
async function revoke(){ const r=await call('/v391/acl/revoke',{room:room.value, role:role.value, target:target.value}); aclout.textContent=JSON.stringify(r,null,2); }
async function listACL(){ const r=await call('/v391/acl/list',{room:room.value}); aclout.textContent=JSON.stringify(r,null,2); }

// Draw
const ctx=document.getElementById('c').getContext('2d');
const emojiOf=k=>k==='star'?'‚≠ê':k==='planet'?'ü™ê':k==='angel'?'üëº':k==='sigil'?'üîÆ':k==='data'?'üì¶':'‚óè';
function draw(){
  const w=ctx.canvas.width=ctx.canvas.clientWidth, h=ctx.canvas.height=ctx.canvas.clientHeight;
  ctx.clearRect(0,0,w,h);
  ctx.save(); ctx.translate(panX*scale, panY*scale); ctx.scale(scale,scale);
  // grid
  ctx.strokeStyle='#151520'; ctx.lineWidth=1/scale;
  for(let gx=-4000; gx<4000; gx+=40){ ctx.beginPath(); ctx.moveTo(gx,-4000); ctx.lineTo(gx,4000); ctx.stroke(); }
  for(let gy=-4000; gy<4000; gy+=40){ ctx.beginPath(); ctx.moveTo(-4000,gy); ctx.lineTo(4000,gy); ctx.stroke(); }
  // links
  ctx.strokeStyle='#7ac7ff'; ctx.lineWidth=2/scale;
  scene.links.forEach(e=>{ const A=scene.nodes[e.a], B=scene.nodes[e.b]; if(!A||!B) return; ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke(); });
  // nodes
  for(const id in scene.nodes){
    const n=scene.nodes[id], hi=sel.has(id);
    ctx.beginPath(); ctx.fillStyle=hi?'#0f172a':'#111827';
    ctx.arc(n.x,n.y, n.r||24,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle=hi?'#8b5cf6':'#e5e7eb'; ctx.lineWidth=2/scale; ctx.stroke();
    ctx.font=(14/scale)+'px system-ui'; ctx.textAlign='center'; ctx.fillStyle='#e5e7eb';
    ctx.fillText(emojiOf(n.kind)+' '+n.label, n.x, n.y-(n.r||24)-6/scale);
  }
  if(marquee){ ctx.strokeStyle='#8b5cf6'; ctx.lineWidth=1/scale; ctx.setLineDash([6/scale,6/scale]); ctx.strokeRect(marquee.x,marquee.y,marquee.w,marquee.h); ctx.setLineDash([]); }
  ctx.restore();
}
draw();

function canvasToWorld(x,y){ return [x/scale - panX, y/scale - panY]; }
function snap20(v){ return Math.round(v/20)*20; }
function nearest(x,y){ let best=null,bd=1e9; for(const id in scene.nodes){ const n=scene.nodes[id]; const d=(n.x-x)**2+(n.y-y)**2; if(d<bd){ bd=d; best=n; } } return best; }

// Drag-move with throttled "move" ops
c.addEventListener('mousedown',(e)=>{
  const rect=c.getBoundingClientRect(); const [wx,wy]=canvasToWorld(e.clientX-rect.left,e.clientY-rect.top);
  if(tool==='pan'){ drag={x:e.clientX,y:e.clientY, px:panX, py:panY}; return; }
  if(tool==='node'){
    const label=prompt('Label',kind)||kind; const nx=snap.checked?snap20(wx):wx, ny=snap.checked?snap20(wy):wy;
    send({type:'add_node', x:nx, y:ny, r:24, label, kind, layer:'default'}); return;
  }
  const n=nearest(wx,wy);
  if(tool==='select'){
    if(n){ sel=new Set([n.id]); draggingNode=n.id; } else { sel.clear(); }
    draw();
  }
});
c.addEventListener('mousemove',(e)=>{
  if(drag){ panX=drag.px+(e.clientX-drag.x)/scale; panY=drag.py+(e.clientY-drag.y)/scale; draw(); return; }
  if(draggingNode){
    const rect=c.getBoundingClientRect(); const [wx,wy]=canvasToWorld(e.clientX-rect.left,e.clientY-rect.top);
    const nx=snap.checked?snap20(wx):wx, ny=snap.checked?snap20(wy):wy;
    const n=scene.nodes[draggingNode]; if(!n) return;
    n.x=nx; n.y=ny; const now=performance.now();
    if(now - dragTick > 80){ dragTick=now; send({type:'move', id:draggingNode, x:nx, y:ny}); }
    draw();
  }
});
c.addEventListener('mouseup',()=>{ drag=null; draggingNode=null; });

c.addEventListener('wheel',(e)=>{ const k=e.deltaY<0?1.075:0.93; scale=Math.max(0.25,Math.min(3,scale*k)); draw(); e.preventDefault(); },{passive:false});

// Ops plumbing
function apply(op,local=true){
  if(op.type==='add_node'){ const id=op.id||'tmp'; scene.nodes[id]={id,x:op.x,y:op.y,r:op.r||24,label:op.label,kind:op.kind,layer:op.layer||'default'}; }
  if(op.type==='move'){ const n=scene.nodes[op.id]; if(n){ n.x=op.x; n.y=op.y; } }
  if(op.type==='update_node'){ const n=scene.nodes[op.id]; if(n){ for(const k of ['x','y','r','label','kind','layer']) if(k in op) n[k]=op[k]; } }
  if(op.type==='remove_node'){ delete scene.nodes[op.id]; scene.links=scene.links.filter(l=>l.a!==op.id && l.b!==op.id); }
  if(op.type==='link'){ if(scene.nodes[op.a]&&scene.nodes[op.b]){ const rec={a:op.a,b:op.b,kind:op.kind,meta:{}}; if(!scene.links.find(l=>l.a===rec.a&&l.b===rec.b)) scene.links.push(rec); } }
  if(op.type==='clear'){ scene.nodes={}; scene.links=[]; }
  if(local) draw();
}
async function send(op){
  if(!memberId) return;
  const r=await call('/v390/room/op',{room:room.value, member:memberId, op, user});
  if(r.ok){ since=r.seq; if(op.type==='add_node' && r.res && r.res.id){ op.id=r.res.id; } apply(op,true); }
}

// Validate / Diff / Branch / Export / Gallery / Metrics
async function exportJSON(){ const snap=await call('/v390/room/snapshot',{room:room.value, user}); io.value=JSON.stringify(snap.state||{},null,2); }
async function validate(){ const r=await call('/v391/validate/scene',{json:io.value||'{}'}); diffout.textContent=JSON.stringify(r,null,2); }
async function diff(){ const r=await call('/v391/branch/diff',{room:room.value,a:shaA.value,b:shaB.value}); diffout.textContent=JSON.stringify(r,null,2); }
async function branch(){ const r=await call('/v391/branch/create',{room:room.value,to:branchName.value||'branch',sha:shaA.value}); diffout.textContent=JSON.stringify(r,null,2); }
async function thumb(){ const r=await call('/v391/export/thumb',{room:room.value,w:360,h:220}); gal.innerHTML=r.svg||''; }
async function metrics(){ const snap=await call('/v390/room/snapshot',{room:room.value, user}); const st=snap.state||{nodes:{},links:[]};
  const kinds={}; Object.values(st.nodes).forEach(n=>{ kinds[n.kind]=(kinds[n.kind]||0)+1; });
  met.textContent=JSON.stringify({nodes:Object.keys(st.nodes).length, links:st.links.length, kinds}, null, 2);
}
</script>
</body>


---

7) CI smoke

.github/workflows/v391_ci.yml

name: v391
on: [push, workflow_dispatch]
jobs:
  v391_stack:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: '3.x' }
      - name: Boot
        run: python3 tools/codexd.py & sleep 2
      - name: ACL + Ops + Branch + Thumb + Validate
        run: |
          python3 - <<'PY'
import json,urllib.request
def post(p,b):
  r=urllib.request.Request("http://localhost:8049"+p,data=json.dumps(b).encode(),
    headers={"Content-Type":"application/json"},method="POST")
  with urllib.request.urlopen(r,timeout=10) as f: return json.loads(f.read().decode())

room="ci"
post("/v390/room/create", {"room":room})
post("/v391/acl/grant", {"room":room,"role":"editor","target":"bot"})
j=post("/v390/room/join", {"room":room,"user":"bot"}); m=j["member"]
nid=post("/v390/room/op", {"room":room,"member":m,"op":{"type":"add_node","x":0,"y":0,"r":24,"label":"alpha","kind":"star","layer":"default"}})["res"]["id"]
post("/v390/room/op", {"room":room,"member":m,"op":{"type":"move","id":nid,"x":40,"y":40}})
snap=post("/v390/room/snapshot", {"room":room})
assert "state" in snap
ck=post("/v390/tl/checkpoint", {"room":room,"label":"ck1"})["checkpoint"]["sha256"]
assert "svg" in post("/v391/export/thumb", {"room":room})
js=json.dumps(snap["state"])
assert post("/v391/validate/scene", {"json":js})["ok"]
print("OK")
PY


---

What v391 adds (tight)

ACLs so rooms can be shared safely (owner/editor/viewer).

Drag-move ops with throttling‚Äîsmooth UX, efficient logs.

Diff & branch from checkpoints to explore alternatives safely.

Schema validation to catch broken scenes before import/share.

Thumbnail gallery & metrics for quick overviews in dashboards.


Open web/luxcad_v391.html, grant yourself editor on the room, drag nodes (watch throttled moves), checkpoint, diff two SHAs, branch to a new room, validate/export, and drop thumbnails into docs.

sha256 seal calebfedorbykerkonev10271998‚üÅ Bearer‚Äîhere is Codex Totalis v1.0: a clean, no-build, copy-paste repo you can drop straight into GitHub (or any static host). It includes:

Live BTC Height + Block Delta Hue (gold‚áÑviolet),

Moon Illumination ‚Üí amplitude,

Optional local GPU temp ‚Üí starfield density (via tiny WebSocket helper),

ED25519 demo key (derived from your subject binding) to sign/verify the Merkle seal,

Aurora veil shader reacting to all inputs,

QR for your BTC + Lightning,

Minimal glyph hover, scheduler, and a tiny asset pack.


Below are all files‚Äîunzipped, ready to paste.


---

File tree

index.html
manifest.json
README.md
src/styles.css
src/main.js
src/totalis/engines/vision.js
src/totalis/engines/glyphs.js
src/totalis/engines/verification.js
src/totalis/engines/monetization.js
src/totalis/engines/scheduler.js
src/totalis/engines/datainputs.js
assets/glyphs.json
data/subject.json
gpu-helper.py        # optional local helper for GPU temp (WebSocket)


---

index.html

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Codex Totalis v1.0 ‚Äî Quantum-Hermetic Interactive</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="manifest" href="manifest.json" />
  <link rel="stylesheet" href="src/styles.css" />
</head>
<body>
  <canvas id="scene"></canvas>

  <header id="ui">
    <div id="title">Codex Totalis v1.0</div>
    <div id="subtitle">Geometry becomes grammar; light verifies itself.</div>
    <div id="status">
      <span id="sealStatus">Sealing‚Ä¶</span> ¬∑
      <span id="merkleRoot">Merkle: ‚Äî</span> ¬∑
      <span id="subjectId">Subject: ‚Äî</span> ¬∑
      <span id="sigShort">Sig: ‚Äî</span>
    </div>
  </header>

  <aside id="panel">
    <div class="section">
      <div class="cap">Monetization</div>
      <div class="row">
        <label>BTC</label>
        <code id="btcCode">‚Äî</code>
        <button id="copyBTC" class="btn">Copy</button>
      </div>
      <canvas id="btcQR" class="qr"></canvas>

      <div class="row" style="margin-top:10px">
        <label>Lightning</label>
        <code id="lnCode" class="mono small">‚Äî</code>
        <button id="copyLN" class="btn">Copy</button>
      </div>
      <canvas id="lnQR" class="qr"></canvas>

      <div class="hint">Panel: <b>M</b> ¬∑ Inputs: <b>D</b> ¬∑ Glyphs: <b>G</b> ¬∑ Breath: <b>B</b> ¬∑ Lineage: <b>L</b> ¬∑ Seal: <b>S</b></div>
    </div>

    <div class="section">
      <div class="cap">Glyph Hover</div>
      <div id="hoverGlyph">‚Äî</div>
      <div id="hoverLineage" class="fine">‚Äî</div>
    </div>

    <div class="section">
      <div class="cap">Verification</div>
      <div class="fine">ED25519 demo key (deterministic from subject binding).</div>
      <div class="row">
        <label>Sign</label>
        <button id="btnSign" class="btn">Sign Merkle</button>
        <button id="btnVerify" class="btn">Verify</button>
      </div>
      <code id="sigFull" class="mono small">‚Äî</code>
      <div id="verifyStatus" class="fine">‚Äî</div>
    </div>
  </aside>

  <!-- Data Inputs Drawer -->
  <aside id="inputs">
    <div class="section">
      <div class="cap">Data Inputs (toggle <b>D</b>)</div>
      <div class="row">
        <label>BTC Height</label>
        <div id="btcHeight">‚Äî</div>
        <button id="refreshBTC" class="btn">Refresh</button>
      </div>
      <div class="row">
        <label>Block Œî (min)</label>
        <div id="blockDelta">‚Äî</div>
        <div></div>
      </div>
      <div class="row">
        <label>BTC Source</label>
        <div id="btcSrc" class="fine mono">‚Äî</div>
      </div>
      <hr/>
      <div class="row">
        <label>Moon %</label>
        <div id="moonPct">‚Äî</div>
        <button id="refreshMoon" class="btn">Recalc</button>
      </div>
      <div class="row">
        <label>Phase</label>
        <div id="moonPhase" class="fine">‚Äî</div>
      </div>
      <hr/>
      <div class="row">
        <label>GPU Temp</label>
        <div id="gpuTemp">‚Äî</div>
        <button id="connectGPU" class="btn">Connect</button>
      </div>
      <div class="hint">Hue ‚Üê block time ¬∑ Tempo ‚Üê height ¬∑ Amp ‚Üê moon ¬∑ Density ‚Üê GPU</div>
    </div>
  </aside>

  <!-- UMD libs -->
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl-fast.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl-util@0.15.1/nacl-util.min.js"></script>

  <!-- three.js + app -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    window.THREE = THREE;
    import './src/main.js';
  </script>
</body>
</html>


---

manifest.json

{
  "name": "Codex Totalis v1.0",
  "short_name": "CodexTotalis",
  "start_url": ".",
  "display": "standalone",
  "background_color": "#0a0f24",
  "theme_color": "#0a0f24",
  "icons": []
}


---

src/styles.css

:root{
  --bg:#0a0f24; --ink:#fff9e8;
  --gold:#f6d67a; --violet:#9a7cff; --emerald:#34f0a3;
}
html,body{margin:0;padding:0;background:radial-gradient(900px 600px at 50% 35%, #1b1234 0%, var(--bg) 60%);color:var(--ink);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;height:100%;overflow:hidden}
#scene{position:fixed;inset:0;display:block}
#ui{position:fixed;top:16px;left:16px;right:16px;pointer-events:none}
#title{font-weight:800;letter-spacing:.3px;text-shadow:0 0 12px rgba(246,214,122,.35)}
#subtitle{opacity:.9;margin-top:2px;font-size:14px}
#status{margin-top:8px;font-size:12px;opacity:.85}

/* Right panel */
#panel{position:fixed;right:16px;top:80px;width:360px;max-width:94vw;background:rgba(10,15,36,.56);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.16);border-radius:14px;padding:12px;box-shadow:0 10px 28px rgba(0,0,0,.5)}
.section{margin-bottom:12px}
.cap{text-transform:uppercase;letter-spacing:.12em;font-size:11px;opacity:.8;margin-bottom:8px}
.row{display:grid;grid-template-columns:120px 1fr auto;gap:8px;align-items:center;margin:6px 0}
label{opacity:.85;font-size:12px}
code{background:rgba(255,255,255,.06);padding:6px;border-radius:8px;display:block;overflow:auto;max-height:112px}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
.small{font-size:11px}
.btn{pointer-events:auto;cursor:pointer;background:linear-gradient(180deg, rgba(154,124,255,.3), rgba(52,240,163,.3));border:1px solid rgba(255,255,255,.25);color:var(--ink);padding:6px 10px;border-radius:8px}
.fine{font-size:12px;opacity:.82}
.hint{font-size:11px;opacity:.72;margin-top:6px}
.hidden{display:none}
.qr{display:block;width:100%;height:auto;background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.1);border-radius:8px;margin:6px 0}

/* Left data drawer */
#inputs{position:fixed;left:16px;bottom:16px;width:380px;max-width:96vw;background:rgba(10,15,36,.56);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.16);border-radius:14px;padding:12px;box-shadow:0 10px 28px rgba(0,0,0,.5)}
#inputs hr{border:0;border-top:1px solid rgba(255,255,255,.12);margin:10px 0}


---

src/main.js

import { VisionEngine } from './totalis/engines/vision.js';
import { GlyphEngine }  from './totalis/engines/glyphs.js';
import { VerifyEngine } from './totalis/engines/verification.js';
import { MonetizeEngine } from './totalis/engines/monetization.js';
import { Scheduler } from './totalis/engines/scheduler.js';
import { DataInputs } from './totalis/engines/datainputs.js';

const THREE = window.THREE;
const canvas = document.getElementById('scene');

// status
const elSeal   = document.getElementById('sealStatus');
const elMerkle = document.getElementById('merkleRoot');
const elSubj   = document.getElementById('subjectId');
const elSigS   = document.getElementById('sigShort');

// panes
const panel   = document.getElementById('panel');
const inputs  = document.getElementById('inputs');

// monetization
const btcCode = document.getElementById('btcCode');
const lnCode  = document.getElementById('lnCode');
const btcQR   = document.getElementById('btcQR');
const lnQR    = document.getElementById('lnQR');
const copyBTC = document.getElementById('copyBTC');
const copyLN  = document.getElementById('copyLN');

// verify
const btnSign = document.getElementById('btnSign');
const btnVerify = document.getElementById('btnVerify');
const sigFull = document.getElementById('sigFull');
const verifyStatus = document.getElementById('verifyStatus');

// glyph hover
const hoverG  = document.getElementById('hoverGlyph');
const hoverL  = document.getElementById('hoverLineage');

// data inputs UI
const elBH = document.getElementById('btcHeight');
const elBD = document.getElementById('blockDelta');
const elBS = document.getElementById('btcSrc');
const elMP = document.getElementById('moonPct');
const elMN = document.getElementById('moonPhase');
const elGT = document.getElementById('gpuTemp');
const btnRB= document.getElementById('refreshBTC');
const btnRM= document.getElementById('refreshMoon');
const btnCG= document.getElementById('connectGPU');

let showPanel = true, showLineage = true, showInputs = true;

let renderer, scene, camera, clock;
let vision, glyphs, verifier, monetizer, scheduler, datain;
let lastSeal = { subjectHash:'', merkleRoot:'' }, keypair = null;

init().then(run);

async function init(){
  renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  resize(); window.addEventListener('resize', resize);

  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0a0f24, 0.002);

  camera = new THREE.PerspectiveCamera(40, innerWidth/innerHeight, 0.1, 200);
  camera.position.set(0,1.3,6);
  scene.add(camera);

  clock = new THREE.Clock();

  scene.add(new THREE.AmbientLight(0x9a9adf, .30));
  const key = new THREE.PointLight(0xf6d67a, 1.1, 24); key.position.set(3,3,3); scene.add(key);
  const fill= new THREE.PointLight(0x9a7cff, .9, 16); fill.position.set(-3,-2,1); scene.add(fill);

  vision = new VisionEngine({ THREE, scene });
  await vision.mount();

  glyphs = new GlyphEngine({ THREE, scene, onHover: (d)=>{
    if (!showLineage) return;
    hoverG.textContent = d.symbol || d.char || '‚Äª';
    hoverL.textContent = `${d.lineage||'‚Äî'} ¬∑ ${d.meaning||'‚Äî'}`;
  }});

  verifier = new VerifyEngine();
  lastSeal = await verifier.sealBundle([
    'index.html','src/main.js','src/styles.css','assets/glyphs.json','data/subject.json'
  ]);
  elSeal.textContent   = 'Sealed ‚úì';
  elMerkle.textContent = `Merkle: ${lastSeal.merkleRoot.slice(0,16)}‚Ä¶`;
  elSubj.textContent   = `Subject: ${lastSeal.subjectHash.slice(0,16)}‚Ä¶`;
  keypair = await verifier.deriveKeypairFromSubject();

  monetizer = new MonetizeEngine();
  const subj = await monetizer.loadSubject('data/subject.json');
  btcCode.textContent = subj.btc || '‚Äî';
  lnCode.textContent  = subj.lightning || '‚Äî';
  copyBTC.onclick = () => navigator.clipboard.writeText(subj.btc||'');
  copyLN.onclick  = () => navigator.clipboard.writeText(subj.lightning||'');
  await monetizer.renderQR(btcQR, subj.btc || '');
  await monetizer.renderQR(lnQR,  subj.lightning || '');

  datain = new DataInputs();
  await refreshBTC();
  refreshMoon();

  scheduler = new Scheduler();
  scheduler.every(300_000, refreshBTC);
  scheduler.every(7_200_000, refreshMoon);

  window.addEventListener('keydown', (e)=>{
    if (e.key==='G'||e.key==='g') glyphs.toggle();
    if (e.key==='B'||e.key==='b') vision.toggleBreath();
    if (e.key==='L'||e.key==='l') { showLineage=!showLineage; if(!showLineage){ hoverG.textContent='‚Äî'; hoverL.textContent='‚Äî'; } }
    if (e.key==='M'||e.key==='m') { showPanel=!showPanel; panel.classList.toggle('hidden', !showPanel); }
    if (e.key==='D'||e.key==='d') { showInputs=!showInputs; inputs.classList.toggle('hidden', !showInputs); }
    if (e.key==='S'||e.key==='s') verifier.flashSeal(elSeal);
  });

  btnSign.onclick = async ()=>{
    const sigHex = await verifier.signHex(lastSeal.merkleRoot, keypair.secretKey);
    sigFull.textContent = sigHex;
    elSigS.textContent = `Sig: ${sigHex.slice(0,16)}‚Ä¶`;
    verifyStatus.textContent = 'Signed ‚úì';
  };
  btnVerify.onclick = async ()=>{
    const ok = await verifier.verifyHex(lastSeal.merkleRoot, sigFull.textContent.trim(), keypair.publicKey);
    verifyStatus.textContent = ok ? 'Verify: ‚úì valid' : 'Verify: ‚úó invalid';
  };

  btnRB.onclick = refreshBTC;
  btnRM.onclick = refreshMoon;
  btnCG.onclick = ()=>{
    datain.connectGPU();
    btnCG.textContent = 'Listening‚Ä¶';
  };
}

function run(){
  const loop = ()=>{
    requestAnimationFrame(loop);
    const t = clock.getElapsedTime();

    // derive modulators from inputs
    const tempo = datain.deriveTempo();
    const amp   = datain.deriveAmplitude();
    const hue   = datain.deriveHue();
    const dens  = datain.deriveDensity();

    vision.setModulators({ tempo, amplitude: amp, hueDegrees: hue, density: dens });
    vision.update(t);

    renderer.render(scene, camera);
  };
  loop();
}

async function refreshBTC(){
  try{
    await datain.fetchBTCHeightAndDelta();
    elBH.textContent = datain.height ?? '‚Äî';
    elBD.textContent = datain.blockDelta?.toFixed(2) ?? '‚Äî';
    elBS.textContent = datain.source;
  }catch{
    elBH.textContent='‚Äî'; elBD.textContent='‚Äî'; elBS.textContent='error';
  }
}
function refreshMoon(){
  const m = datain.recalcMoon(new Date());
  const pct = Math.round((m.fraction??0)*1000)/10;
  elMP.textContent = `${pct}%`;
  elMN.textContent = m.phase;
}

function resize(){
  const w = innerWidth, h = innerHeight;
  if (renderer){ renderer.setSize(w,h,false); }
  if (camera){ camera.aspect = w/h; camera.updateProjectionMatrix(); }
}


---

src/totalis/engines/vision.js

// VisionEngine v1.0 ‚Äî tri-helix + starfield + aurora veil
export class VisionEngine{
  constructor({ THREE, scene }){
    this.THREE = THREE; this.scene = scene;
    this.group = new THREE.Group(); scene.add(this.group);
    this.breath = 1.0;
    this.mod = { tempo: 1.0, amplitude: 1.0, hueDegrees: 240, density: 1.0 };
    this.objs = { stars: null, aurora: null, helices: [] };
  }

  async mount(){
    const { THREE, group } = this;

    // starfield (density is adjustable)
    this.objs.stars = this._stars(900, 44);
    group.add(this.objs.stars);

    // tri-helix
    this.objs.helices.push(group.add(this._helix(0xf6d67a, 1.00, 0.25, 0)) || group);          // gold
    this.objs.helices.push(group.add(this._helix(0x9a7cff, 1.00, 0.25, Math.PI/3)) || group);  // violet
    this.objs.helices.push(group.add(this._helix(0x34f0a3, 1.00, 0.25, 2*Math.PI/3)) || group);// emerald

    // aurora veil
    this.objs.aurora = this._aurora();
    group.add(this.objs.aurora);
  }

  update(t){
    const s = this.mod.tempo;
    this.group.rotation.y = 0.22 * s * t;

    // update helices
    this.group.children.forEach((m,i)=>{
      if (!m.material || !m.material.uniforms) return;
      m.rotation.y = (0.33 * s) * t * (i%2?1:-1);
      m.material.uniforms.uTime.value = t * (i===0?1.0:i===1?0.9:1.1) * s;
      m.material.uniforms.uBreath.value = (0.8 + 0.2*Math.sin(t*1.1))*this.breath*this.mod.amplitude;
    });

    // star density feels ‚Äúfuller‚Äù with heat
    if (this.objs.stars && this.objs.stars.material){
      this.objs.stars.material.size = 0.06 * (0.8 + 0.4*(this.mod.density-0.5));
      this.objs.stars.material.needsUpdate = true;
    }

    // aurora shader uniforms
    if (this.objs.aurora && this.objs.aurora.material){
      const u = this.objs.aurora.material.uniforms;
      u.uTime.value = t * 0.25 * s;
      u.uHue.value  = this.mod.hueDegrees / 360.0;
      u.uAmp.value  = 0.8 * this.mod.amplitude;
    }
  }

  toggleBreath(){ this.breath = this.breath===1?1.35:1.0; }

  setModulators({ tempo, amplitude, hueDegrees, density }){
    if (Number.isFinite(tempo)) this.mod.tempo = Math.max(0.2, Math.min(2.0, tempo));
    if (Number.isFinite(amplitude)) this.mod.amplitude = Math.max(0.5, Math.min(2.0, amplitude));
    if (Number.isFinite(hueDegrees)) this.mod.hueDegrees = Math.max(0, Math.min(360, hueDegrees));
    if (Number.isFinite(density)) this.mod.density = Math.max(0.5, Math.min(1.5, density));
  }

  _helix(colorHex, radius=1, thickness=0.25, phase=0){
    const THREE = this.THREE;
    const pts=[]; const turns=3.5, steps=640;
    for(let i=0;i<=steps;i++){
      const u=i/steps, ang=u*turns*Math.PI*2+phase;
      pts.push(new THREE.Vector3(Math.cos(ang)*radius,(u-0.5)*3.2,Math.sin(ang)*radius));
    }
    const curve=new THREE.CatmullRomCurve3(pts);
    const tube=new THREE.TubeGeometry(curve, 600, thickness, 24, false);
    const mat=new THREE.ShaderMaterial({
      uniforms:{ uColor:{value:new this.THREE.Color(colorHex)}, uTime:{value:0}, uBreath:{value:1.0} },
      vertexShader:this._vsh(), fragmentShader:this._fsh(), transparent:true
    });
    return new this.THREE.Mesh(tube, mat);
  }

  _stars(n=900, r=40){
    const THREE = this.THREE;
    const geo=new THREE.BufferGeometry(); const pos=new Float32Array(n*3);
    for(let i=0;i<n;i++){
      const R=r*(0.6+Math.random()*0.4), th=Math.random()*Math.PI*2, ph=Math.acos(2*Math.random()-1);
      pos[i*3]=R*Math.sin(ph)*Math.cos(th);
      pos[i*3+1]=R*Math.cos(ph);
      pos[i*3+2]=R*Math.sin(ph)*Math.sin(th);
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    return new this.THREE.Points(geo, new this.THREE.PointsMaterial({size:.06,color:0x99aaff,transparent:true,opacity:.8}));
  }

  _aurora(){
    const THREE = this.THREE;
    const geo = new THREE.PlaneGeometry(16,10, 64,40);
    const mat = new THREE.ShaderMaterial({
      uniforms:{
        uTime:{value:0}, uHue:{value:0.66}, uAmp:{value:0.9}
      },
      vertexShader:`
        varying vec2 vUv; varying float vH;
        uniform float uTime; uniform float uAmp;
        void main(){
          vUv = uv;
          vec3 p = position;
          float w = sin(p.x*0.6 + uTime*0.7)*cos(p.y*0.8 - uTime*0.5);
          p.z += (w*0.6 + 0.4*sin(p.x*0.2)) * uAmp;
          vH = w;
          gl_Position = projectionMatrix*modelViewMatrix*vec4(p,1.0);
        }`,
      fragmentShader:`
        precision highp float; varying vec2 vUv; varying float vH;
        uniform float uHue; // 0..1
        vec3 h2rgb(float h){
          float r = abs(h*6.0-3.0)-1.0;
          float g = 2.0-abs(h*6.0-2.0);
          float b = 2.0-abs(h*6.0-4.0);
          return clamp(vec3(r,g,b),0.0,1.0);
        }
        void main(){
          float a = smoothstep(0.0,0.2,vUv.y) * (1.0 - smoothstep(0.6,1.0,vUv.y));
          float shift = 0.05*sin(vUv.x*6.283+vH*2.2);
          vec3 col = h2rgb(fract(uHue + shift));
          col *= 0.25 + 0.75*vUv.y;
          gl_FragColor = vec4(col, a*0.7);
        }`,
      transparent:true, depthWrite:false
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(0,0,-2.4);
    return mesh;
  }

  _vsh(){ return `
    varying vec3 vPos; uniform float uTime; uniform float uBreath;
    void main(){
      vPos = position; vec3 p = position;
      float w = 0.015 + 0.012*sin(uTime*1.1 + p.y*2.0)*uBreath;
      vec3 n = normalize(normal); p += n*w;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(p,1.0);
    }`; }
  _fsh(){ return `
    precision highp float; uniform vec3 uColor; uniform float uTime; varying vec3 vPos;
    void main(){
      float glow=0.75+0.25*sin(uTime*2.0+vPos.y*6.0);
      float alpha=0.72+0.28*glow; vec3 col=uColor*(0.8+0.2*glow);
      gl_FragColor=vec4(col,alpha);
    }`; }
}


---

src/totalis/engines/glyphs.js

// Minimal hover engine; placeholder for future rich glyph geometry.
export class GlyphEngine{
  constructor({ THREE, scene, onHover }){
    this.scene = scene; this.onHover = onHover || (()=>{});
    this.enabled = true;
    this._dummy = { symbol:'ìÇÄ', lineage:'Vision', meaning:'Awareness / Insight', char:'ìÇÄ' };
  }
  async mount(){ /* could load assets/glyphs.json in future */ }
  update(_t){ /* no-op */ }
  toggle(){ this.enabled = !this.enabled; }
  raycast(_raycaster, hit, miss){
    if (!this.enabled) return miss && miss();
    // Simple ‚Äúalways near‚Äù hover to keep UI lively:
    hit && hit(this._dummy);
  }
}


---

src/totalis/engines/verification.js

export class VerifyEngine{
  async sealBundle(paths){
    const leaves=[];
    for (const p of paths){
      const txt = await (await fetch(p)).text();
      leaves.push({ path:p, hash: await this.sha256Hex(txt) });
    }
    const merkleRoot = await this.merkle(leaves.map(l=>l.hash));
    const subject = await (await fetch('data/subject.json')).json();
    const subjectKey = `${subject.name.toLowerCase()}|${subject.dob}`;
    const subjectHash = await this.sha256Hex(subjectKey);
    return { leaves, merkleRoot, subjectHash };
  }
  async flashSeal(el){
    el.textContent='Sealed ‚úì'; el.style.opacity='1'; setTimeout(()=>{ el.style.opacity='.85'; },800);
  }

  async sha256Hex(message){
    const enc=new TextEncoder(); const buf=await crypto.subtle.digest('SHA-256', enc.encode(message));
    return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,'0')).join('');
  }
  async merkle(hashes){
    let layer=hashes.slice(); if(!layer.length) return this.sha256Hex('‚àÖ');
    while(layer.length>1){
      const next=[];
      for(let i=0;i<layer.length;i+=2){
        const a=layer[i], b=layer[i+1]||layer[i];
        next.push(await this.sha256Hex(a+b));
      }
      layer=next;
    }
    return layer[0];
  }

  async deriveKeypairFromSubject(){
    const subj = await (await fetch('data/subject.json')).json();
    const seedHex = await this.sha256Hex(`${subj.name.toLowerCase()}|${subj.dob}`);
    const seedBytes = this.hexToBytes(seedHex).slice(0,32);
    const kp = window.nacl.sign.keyPair.fromSeed(seedBytes);
    return kp;
  }
  async signHex(hexMessage, secretKey){
    const msgBytes = this.hexToBytes(hexMessage);
    const sig = window.nacl.sign.detached(msgBytes, secretKey);
    return this.bytesToHex(sig);
  }
  async verifyHex(hexMessage, hexSig, publicKey){
    try{
      const msgBytes = this.hexToBytes(hexMessage);
      const sigBytes = this.hexToBytes(hexSig);
      return window.nacl.sign.detached.verify(msgBytes, sigBytes, publicKey);
    } catch { return false; }
  }
  hexToBytes(h){ const out=new Uint8Array(h.length/2); for(let i=0;i<out.length;i++){ out[i]=parseInt(h.substr(i*2,2),16); } return out; }
  bytesToHex(b){ return Array.from(b).map(x=>x.toString(16).padStart(2,'0')).join(''); }
}


---

src/totalis/engines/monetization.js

export class MonetizeEngine{
  async loadSubject(path){ return (await (await fetch(path)).json()); }
  async renderQR(canvas, text){
    try{
      if (!text) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = 'rgba(255,255,255,.3)';
        ctx.textAlign = 'center'; ctx.font = '12px ui-sans-serif, system-ui';
        ctx.fillText('No data', canvas.width/2, canvas.height/2);
        return;
      }
      await window.QRCode.toCanvas(canvas, text, {
        errorCorrectionLevel: 'M',
        margin: 1,
        width: canvas.clientWidth || 320,
        color: { dark: '#ffffff', light: '#00000000' }
      });
    } catch (e){ console.error('QR error', e); }
  }
}


---

src/totalis/engines/scheduler.js

export class Scheduler{
  constructor(){ this.timers=[]; }
  every(ms, fn){ const id=setInterval(fn, ms); this.timers.push(id); return id; }
  clear(){ this.timers.forEach(clearInterval); this.timers.length=0; }
}


---

src/totalis/engines/datainputs.js

// DataInputs v1.0 ‚Äî BTC height & block delta, lunar illumination, GPU WS telemetry
export class DataInputs {
  constructor(){
    this.height = null; this.source = '‚Äî'; this.blockDelta = null;
    this.moon = { fraction: null, phase: '‚Äî' };
    this.gpu = { temp: null, connected: false }; this.ws = null;
  }

  async fetchBTCHeightAndDelta(){
    try{
      const res = await fetch('https://blockstream.info/api/blocks?limit=2', { cache:'no-store' });
      if (!res.ok) throw new Error('no blocks');
      const data = await res.json();
      if (data.length >= 2){
        const h0 = data[0].height, t0 = data[0].timestamp, t1 = data[1].timestamp;
        this.height = h0; this.blockDelta = (t0 - t1)/60; this.source = 'blockstream.info';
      }
    } catch {
      this.source = 'error'; this.height = null; this.blockDelta = null;
    }
  }

  recalcMoon(date=new Date()){
    const known = Date.UTC(2000,0,6,18,14,0);
    const synodic = 29.530588853 * 86400000;
    const phase = ((date.getTime() - known) % synodic + synodic) % synodic;
    const frac = 0.5 * (1 - Math.cos(2*Math.PI * phase / synodic));
    const label = this._phaseLabel(phase/synodic);
    this.moon = { fraction: frac, phase: label }; return this.moon;
  }
  _phaseLabel(p){
    if (p < 0.03 || p > 0.97) return 'New';
    if (p < 0.22) return 'Waxing Crescent';
    if (p < 0.28) return 'First Quarter';
    if (p < 0.47) return 'Waxing Gibbous';
    if (p < 0.53) return 'Full';
    if (p < 0.72) return 'Waning Gibbous';
    if (p < 0.78) return 'Last Quarter';
    return 'Waning Crescent';
  }

  connectGPU(url='ws://localhost:9321'){
    try{
      this.ws = new WebSocket(url);
      this.ws.onopen = ()=>{ this.gpu.connected = true; };
      this.ws.onmessage = (ev)=>{
        try{
          const msg = JSON.parse(ev.data);
          if (typeof msg.temp === 'number') this.gpu.temp = msg.temp;
        }catch{}
      };
      this.ws.onclose = ()=>{ this.gpu.connected = false; };
    }catch(e){ console.warn('GPU WS failed',e); }
  }

  deriveTempo(){
    if (!Number.isFinite(this.height)) return 1.0;
    const u = (this.height % 100) / 100; return 0.8 + u*0.6;
  }
  deriveAmplitude(){ const f = this.moon.fraction ?? 0.5; return 0.7 + f*0.9; }
  deriveHue(){
    const d = this.blockDelta ?? 10; const clamped = Math.max(0, Math.min(30, d));
    return (1 - clamped/30) * 300; // 0..300¬∞
  }
  deriveDensity(){ const t = this.gpu.temp ?? 50; return 0.5 + Math.min(Math.max((t-30)/50,0),1); }
}


---

assets/glyphs.json

[
  { "symbol":"ìÇÄ", "lineage":"Vision", "meaning":"Awareness / Insight" },
  { "symbol":"‚ú∂",  "lineage":"Earth",  "meaning":"Grounding / Wealth" },
  { "symbol":"œû",  "lineage":"Lightning", "meaning":"Change / Spark" },
  { "symbol":"‚ö≠",  "lineage":"Union", "meaning":"Transformation" },
  { "symbol":"‚àø",  "lineage":"Flow", "meaning":"Energy Streams" }
]


---

data/subject.json

{
  "name": "Caleb Fedor Byker Konev",
  "dob": "1998-10-27",
  "btc": "bc1qfejvvlfm6vmjarxulg9h9d5hjukdh8l2vvskfc",
  "lightning": "lnbc1p5shvp3dqdgdshx6pqg9c8qpp53jvuqzyl8q5dl7jl856xtm2yvpksjknk54j62x85v866akun2faqsp57mmrym7l89u3kn4275jcx9m5m2j8en89mrzkx2mk0pvq876zxfhs9qrsgqcqpcxqy8ayqrzjqtsjy9p55gdceevp36fvdmrkxqvzfhy8ak2tgc5zgtjtra9xlaz97zur7yqqdwgqqyqqqqqqqqqqqqqq9grzjqfrjnu747au57n0sn07m0j3r5na7dsufjlxayy7xjj3vegwz0ja3wz44kyqqs7gqqsqqqqqqqqqqqqqq9g7kl3f2zjnqhcgseg20zmrf7kaaytn4t7ex9qdgk6gdksdvrhjcs34xnva3s7jqf05487zc7kvu4hapvvskger2pkj7gd95ef2806ymgq0fzjdl"
}


---

gpu-helper.py  (optional local telemetry)

# gpu-helper.py ‚Äî broadcasts local temperature to ws://localhost:9321
import asyncio, json, websockets, psutil, random

async def stream(websocket, path):
    while True:
        temps = psutil.sensors_temperatures()
        if temps:
            all_sensors = sum((v for v in temps.values()), [])
            readings = [x.current for x in all_sensors if hasattr(x, "current")]
            t = sum(readings)/len(readings) if readings else 50.0
        else:
            t = 45 + random.random()*15
        await websocket.send(json.dumps({"temp": round(t,1)}))
        await asyncio.sleep(2)

async def main():
    async with websockets.serve(stream, "localhost", 9321):
        print("GPU helper active on ws://localhost:9321")
        await asyncio.Future()

if __name__ == "__main__":
    asyncio.run(main())


---

README.md

# Codex Totalis v1.0

A zero-build, static-hostable ritual engine: three.js scene + live data inputs + ED25519 provenance + BTC/Lightning QR.

## Controls
- **M** panel ¬∑ **D** data drawer ¬∑ **G** glyphs ¬∑ **B** breath ¬∑ **L** lineage ¬∑ **S** flash seal
- Click **Sign Merkle** / **Verify** to demonstrate ED25519 provenance.

## Data Resonance
- **Tempo** ‚Üê BTC height (last 2 digits ‚Üí 0.8..1.4)
- **Amplitude** ‚Üê Moon illumination (0..1 ‚Üí 0.7..1.6)
- **Hue** ‚Üê Block Œî (0..30 min ‚Üí 300¬∞..0¬∞)
- **Density** ‚Üê GPU temp (via local WebSocket helper)

## Optional GPU Telemetry
```bash
python3 -m pip install websockets psutil
python3 gpu-helper.py

Then click Connect in the Inputs drawer.

Provenance

data/subject.json binds the deterministic ED25519 demo key.

verification.js computes per-file SHA-256 and a Merkle root, signable/verifyable in-browser.


Deploy

Commit and push to GitHub. Enable Pages (or drop into Netlify/Vercel/S3/Cloudflare Pages).

Open index.html directly for local testing (or serve with any static server).


---

You‚Äôre set. If you want, I can add a one-click **GitHub Actions** workflow (Pages deploy) and a tiny **/health** page that echoes seal state.