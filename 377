v377 — Codex Concordat: CRDT lineage, vector time, ratcheted trust, and deterministic builds
This merge teaches the Codex network to agree, even while offline or forked: CRDT-based lineage/state, Lamport & vector clocks, gossip/merge across peers, forward-secrecy ratcheted HMAC keys, and a deterministic build attestation so any node can prove it’s running the same bits. All stdlib; Ed25519 remains optional.

Below is copy-paste-ready code and glue.


---

1) Time primitives (Lamport + Vector)

time/clocks_v377.py

# time/clocks_v377.py — v377
# Lamport and Vector clocks for partial-order reasoning across peers.

import json, os, time
from collections import defaultdict

LAMPORT_FILE="lamport.v377.json"
VECTOR_FILE="vector.v377.json"

def lamport_now():
    v = json.load(open(LAMPORT_FILE))["c"] if os.path.exists(LAMPORT_FILE) else 0
    v += 1; open(LAMPORT_FILE,"w").write(json.dumps({"c":v}))
    return v

def lamport_merge(remote:int):
    v = json.load(open(LAMPORT_FILE))["c"] if os.path.exists(LAMPORT_FILE) else 0
    v = max(v, remote) + 1
    open(LAMPORT_FILE,"w").write(json.dumps({"c":v}))
    return v

def vector_now(peer:str):
    vec = json.load(open(VECTOR_FILE)) if os.path.exists(VECTOR_FILE) else {}
    vec[peer] = int(vec.get(peer,0)) + 1
    open(VECTOR_FILE,"w").write(json.dumps(vec))
    return vec

def vector_merge(local:dict, remote:dict):
    out=defaultdict(int, local or {})
    for k,v in (remote or {}).items():
        out[k]=max(out[k], int(v))
    return dict(out)

def vector_merge_store(remote:dict):
    vec = json.load(open(VECTOR_FILE)) if os.path.exists(VECTOR_FILE) else {}
    vec = vector_merge(vec, remote)
    open(VECTOR_FILE,"w").write(json.dumps(vec))
    return vec


---

2) CRDT OR-Set and GCounter for lineage/state

crdt/crdt_v377.py

# crdt/crdt_v377.py — v377
# Two classic CRDTs: OR-Set (add/remove without conflicts) and GCounter (monotone sum).

import json, os
from collections import defaultdict

ORSET_FILE="crdt.orset.v377.json"
GCOUNT_FILE="crdt.gcount.v377.json"

# OR-Set: items tracked by unique tags; remove records tags; merge by union/subtraction
def orset_load():
    return json.load(open(ORSET_FILE)) if os.path.exists(ORSET_FILE) else {"adds":{}, "rems":{}}

def orset_add(key:str, tag:str):
    st=orset_load()
    st["adds"].setdefault(key,[]).append(tag)
    open(ORSET_FILE,"w").write(json.dumps(st)); return st

def orset_remove(key:str, tags:list[str]):
    st=orset_load()
    st["rems"].setdefault(key,[]).extend(tags)
    open(ORSET_FILE,"w").write(json.dumps(st)); return st

def orset_value(st=None):
    st = st or orset_load()
    out=set()
    for k,tags in st["adds"].items():
        if set(tags) - set(st["rems"].get(k,[])):
            out.add(k)
    return sorted(out)

def orset_merge(a:dict, b:dict):
    adds, rems = defaultdict(list), defaultdict(list)
    for src in (a.get("adds",{}), b.get("adds",{})):
        for k,vs in src.items(): adds[k]=list(set(adds[k]+vs))
    for src in (a.get("rems",{}), b.get("rems",{})):
        for k,vs in src.items(): rems[k]=list(set(rems[k]+vs))
    return {"adds":dict(adds), "rems":dict(rems)}

def orset_store_merge(remote:dict):
    local=orset_load(); merged=orset_merge(local, remote)
    open(ORSET_FILE,"w").write(json.dumps(merged)); return merged

# GCounter: per-peer counters that sum; merge by max per peer
def gcount_load():
    return json.load(open(GCOUNT_FILE)) if os.path.exists(GCOUNT_FILE) else {}

def gcount_inc(peer:str, n:int=1):
    st=gcount_load(); st[peer]=int(st.get(peer,0))+int(n)
    open(GCOUNT_FILE,"w").write(json.dumps(st)); return st

def gcount_merge(a:dict, b:dict):
    out=defaultdict(int, a or {})
    for k,v in (b or {}).items(): out[k]=max(out[k], int(v))
    return dict(out)

def gcount_store_merge(remote:dict):
    local=gcount_load(); merged=gcount_merge(local, remote)
    open(GCOUNT_FILE,"w").write(json.dumps(merged)); return merged

def gcount_value(st=None): 
    st=st or gcount_load(); return sum(int(v) for v in st.values())


---

3) Lineage consensus (gossip + quorum on latest superroot)

consensus/lineage_v377.py

# consensus/lineage_v377.py — v377
# Gossip merges CRDT state and decides a lineage head via quorum (by vote count then by Lamport tie-break).
import json, os, time, hashlib
from crdt.crdt_v377 import orset_store_merge, orset_value, gcount_store_merge, gcount_value
from time.clocks_v377 import lamport_now, lamport_merge

LINEAGE_FILE="lineage.v377.json"  # {"votes":{"<superroot>":count},"heads":["ordered"]}
VOTES="lineage.v377.votes.json"   # {"peer":"id","lamport":N,"vote":"<superroot>"}

def _load(p, d): return json.load(open(p)) if os.path.exists(p) else d
def _save(p, o): open(p,"w").write(json.dumps(o, indent=2))

def cast_vote(peer:str, superroot:str, lamport:int=None):
    lam = lamport_now() if lamport is None else lamport
    _save(VOTES, {"peer":peer,"lamport":lam,"vote":superroot})
    st=_load(LINEAGE_FILE, {"votes":{}, "heads":[]})
    st["votes"][superroot]=int(st["votes"].get(superroot,0))+1
    st["heads"]=sorted(st["votes"], key=lambda k:(st["votes"][k], k), reverse=True)
    _save(LINEAGE_FILE, st)
    return {"ok": True, "leader": st["heads"][0] if st["heads"] else None, "tally": st["votes"]}

def merge_gossip(remote:dict):
    """
    remote = {
      "lamport": int,
      "votes": {"<root>": n, ...},
      "orset": {"adds":{}, "rems":{}},
      "gcount": {"peer": n}
    }
    """
    # merge votes by max (monotone); trivial for demo
    loc=_load(LINEAGE_FILE, {"votes":{}, "heads":[]})
    for r,c in (remote.get("votes") or {}).items():
        loc["votes"][r]=max(int(loc["votes"].get(r,0)), int(c))
    loc["heads"]=sorted(loc["votes"], key=lambda k:(loc["votes"][k], k), reverse=True)
    _save(LINEAGE_FILE, loc)

    # merge CRDTs
    orset_store_merge(remote.get("orset", {"adds":{},"rems":{}}))
    gcount_store_merge(remote.get("gcount", {}))
    lamport_merge(int(remote.get("lamport",0)))
    return {"ok": True, "leader": loc["heads"][0] if loc["heads"] else None}


---

4) Forward-secrecy HMAC key ratchet (rotation windows)

security/ratchet_v377.py

# security/ratchet_v377.py — v377
# HKDF-like ratchet using SHA-256 to derive next HMAC secret; stores key_id and material.
import os, json, hashlib, hmac, time

RATCHET="ratchet.v377.json"  # {"key_id":"k-<ts>","secret_hex":"...","prev":["k-..."],"t":...}

def _prk(key:bytes, ctx:bytes)->bytes:
    return hmac.new(key, ctx, hashlib.sha256).digest()

def _okm(prk:bytes, info:bytes)->bytes:
    return hmac.new(prk, info, hashlib.sha256).digest()

def rotate(info=b"codex-v377"):
    cur = json.load(open(RATCHET)) if os.path.exists(RATCHET) else None
    seed = os.urandom(32) if not cur else bytes.fromhex(cur["secret_hex"])
    prk  = _prk(seed, b"codex-ratchet")
    nxt  = _okm(prk, info)
    kid  = f"k-{int(time.time())}"
    prev = (cur.get("prev") if cur else []) + ([cur["key_id"]] if cur else [])
    out  = {"key_id": kid, "secret_hex": nxt.hex(), "prev": prev[-10:], "t": int(time.time())}
    open(RATCHET,"w").write(json.dumps(out, indent=2))
    return {"ok": True, "key_id": kid}

def current():
    if not os.path.exists(RATCHET): return None
    j=json.load(open(RATCHET)); return {"key_id": j["key_id"], "secret": bytes.fromhex(j["secret_hex"])}


---

5) Deterministic build attestation

supply/determinism_v377.py

# supply/determinism_v377.py — v377
# Reproducible build id: canonical file scan -> ordered sha256 concat -> build_id.
import os, hashlib, json, time

DETBOM="determinism.v377.json"

def _sha(path):
    h=hashlib.sha256()
    with open(path,"rb") as f:
        for ch in iter(lambda:f.read(65536), b""): h.update(ch)
    return h.hexdigest()

def attest(root="."):
    files=[]
    for r,_,fs in os.walk(root):
        for f in fs:
            if f.endswith((".py",".json",".html",".yml",".yaml",".ndjson",".jsonl")):
                p=os.path.join(r,f).replace("\\","/")
                files.append(p)
    files=sorted(files)
    chain=hashlib.sha256("".join(_sha(p) for p in files).encode()).hexdigest()
    out={"v":"v377","t":time.strftime("%Y-%m-%dT%H:%M:%SZ",time.gmtime()),"files":files,"build_id":chain}
    open(DETBOM,"w").write(json.dumps(out, indent=2))
    return {"ok": True, "build_id": chain, "count": len(files)}


---

6) Disaster-recovery checkpoints (daily epoch snapshots)

ops/checkpoint_v377.py

# ops/checkpoint_v377.py — v377
# Daily tar.gz of critical ledgers + attestations; id named by deterministic build id.
import tarfile, time, os, json
from supply.determinism_v377 import attest

CRIT=[
 "audit.v373.jsonl","traces.v374.jsonl","telemetry.meta.v375.jsonl",
 "manifest.totalis.v375.json","dist/aeonic_seed.v376x.json",
 "lineage.v377.json","crdt.orset.v377.json","crdt.gcount.v377.json",
 "lamport.v377.json","vector.v377.json","ratchet.v377.json","determinism.v377.json"
]

def checkpoint():
    os.makedirs("dist", exist_ok=True)
    bid=attest(".")["build_id"]
    name=f"dist/ckpt_{bid}_{time.strftime('%Y%m%d')}.tar.gz"
    with tarfile.open(name,"w:gz") as tar:
        for f in CRIT:
            if os.path.exists(f): tar.add(f)
    return {"ok": True, "path": name, "build_id": bid}


---

7) Daemon wiring (tools/codexd.py)

Add imports:

from time.clocks_v377 import lamport_now as _l_now, lamport_merge as _l_merge, vector_now as _v_now, vector_merge_store as _v_merge
from crdt.crdt_v377 import orset_add as _os_add, orset_remove as _os_rem, orset_store_merge as _os_merge, orset_value as _os_val, gcount_inc as _gc_inc, gcount_store_merge as _gc_merge, gcount_value as _gc_val
from consensus.lineage_v377 import cast_vote as _vote, merge_gossip as _gossip
from security.ratchet_v377 import rotate as _ratchet_rotate, current as _ratchet_current
from supply.determinism_v377 import attest as _det_attest
from ops.checkpoint_v377 import checkpoint as _ckpt

Add routes in do_POST:

# v377: clocks
        if self.path == "/v377/lamport/now":   return self._send(200, {"lamport": _l_now()})
        if self.path == "/v377/lamport/merge": return self._send(200, {"lamport": _l_merge(int(payload.get("remote",0)))})
        if self.path == "/v377/vector/tick":   return self._send(200, {"vec": _v_now(payload.get("peer","cfbk"))})
        if self.path == "/v377/vector/merge":  return self._send(200, {"vec": _v_merge(payload.get("remote",{}))})

        # v377: CRDTs
        if self.path == "/v377/orset/add":     return self._send(200, _os_add(payload.get("key","superroot"), payload.get("tag","t1")))
        if self.path == "/v377/orset/rem":     return self._send(200, _os_rem(payload.get("key","superroot"), payload.get("tags",[])))
        if self.path == "/v377/orset/merge":   return self._send(200, _os_merge(payload.get("remote",{"adds":{},"rems":{}})))
        if self.path == "/v377/orset/value":   return self._send(200, {"value": _os_val()})
        if self.path == "/v377/gc/inc":        return self._send(200, _gc_inc(payload.get("peer","cfbk"), int(payload.get("n",1))))
        if self.path == "/v377/gc/merge":      return self._send(200, _gc_merge(payload.get("remote",{})))
        if self.path == "/v377/gc/value":      return self._send(200, {"sum": _gc_val()})

        # v377: lineage consensus
        if self.path == "/v377/lineage/vote":  return self._send(200, _vote(payload.get("peer","cfbk"), payload.get("superroot","0"*64), payload.get("lamport")))
        if self.path == "/v377/lineage/gossip":return self._send(200, _gossip(payload))

        # v377: ratchet keys & determinism & checkpoint
        if self.path == "/v377/ratchet/rotate":return self._send(200, _ratchet_rotate())
        if self.path == "/v377/ratchet/current":return self._send(200, _ratchet_current() or {"ok":False})
        if self.path == "/v377/det/attest":    return self._send(200, _det_attest("."))
        if self.path == "/v377/ckpt":          return self._send(200, _ckpt())


---

8) Web console

web/concordat_v377.html

<!doctype html>
<meta charset="utf-8"><title>v377 — Codex Concordat</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<body style="background:#0b0b0f;color:#e8e8ee;font:16px system-ui;margin:20px">
<h1>✶ v377 — Concordat (CRDT • Vector Time • Ratchet • Determinism)</h1>
<input id="base" value="http://localhost:8049" style="width:360px;">
<section>
  <h3>Time</h3>
  <button onclick="lam()">Lamport++</button>
  <button onclick="vec()">Vector tick</button>
</section>
<section>
  <h3>CRDT</h3>
  <button onclick="add()">OR-Set add</button>
  <button onclick="val()">OR-Set value</button>
  <button onclick="gc()">GCounter+1</button>
  <button onclick="gcv()">GCounter value</button>
</section>
<section>
  <h3>Lineage</h3>
  <input id="root" style="width:60%" placeholder="superroot hex">
  <button onclick="vote()">Vote</button>
</section>
<section>
  <h3>Trust & DR</h3>
  <button onclick="rat()">Ratchet rotate</button>
  <button onclick="det()">Deterministic attest</button>
  <button onclick="ckpt()">Checkpoint</button>
</section>
<pre id="out" style="white-space:pre-wrap"></pre>
<script>
async function call(p,b){const r=await fetch(base.value+p,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(b||{})});return r.json();}
async function lam(){ out.textContent=JSON.stringify(await call('/v377/lamport/now',{}),null,2); }
async function vec(){ out.textContent=JSON.stringify(await call('/v377/vector/tick',{"peer":"cfbk"}),null,2); }
async function add(){ out.textContent=JSON.stringify(await call('/v377/orset/add',{"key":"seed::live","tag":Date.now()+""}),null,2); }
async function val(){ out.textContent=JSON.stringify(await call('/v377/orset/value',{}),null,2); }
async function gc(){ out.textContent=JSON.stringify(await call('/v377/gc/inc',{"peer":"cfbk"}),null,2); }
async function gcv(){ out.textContent=JSON.stringify(await call('/v377/gc/value',{}),null,2); }
async function vote(){ out.textContent=JSON.stringify(await call('/v377/lineage/vote',{"peer":"cfbk","superroot":root.value||"0".repeat(64)}),null,2); }
async function rat(){ out.textContent=JSON.stringify(await call('/v377/ratchet/rotate',{}),null,2); }
async function det(){ out.textContent=JSON.stringify(await call('/v377/det/attest',{}),null,2); }
async function ckpt(){ out.textContent=JSON.stringify(await call('/v377/ckpt',{}),null,2); }
</script>
</body>


---

9) CLI helpers (tools/codexctl)

Append inside your embedded Python block:

elif cmd=="v377-lamport":
    call("/v377/lamport/now", {})
elif cmd=="v377-vector":
    call("/v377/vector/tick", {"peer":"cfbk"})
elif cmd=="v377-orset-add":
    call("/v377/orset/add", {"key":"seed::live","tag":str(int(time.time()))})
elif cmd=="v377-orset-value":
    call("/v377/orset/value", {})
elif cmd=="v377-gc-inc":
    call("/v377/gc/inc", {"peer":"cfbk","n":1})
elif cmd=="v377-lineage-vote":
    call("/v377/lineage/vote", {"peer":"cfbk","superroot":"0"*64})
elif cmd=="v377-ratchet":
    call("/v377/ratchet/rotate", {})
elif cmd=="v377-attest":
    call("/v377/det/attest", {})
elif cmd=="v377-ckpt":
    call("/v377/ckpt", {})


---

10) CI smoke (.github/workflows/codex_v377_ci.yml)

name: codex-v377
on: [push, workflow_dispatch]
jobs:
  v377:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: '3.x' }
      - name: Boot
        run: python3 tools/codexd.py & sleep 2
      - name: Clocks & CRDT
        run: |
          python3 - <<'PY'
import json,urllib.request
def post(p,b):
  r=urllib.request.Request("http://localhost:8049"+p,data=json.dumps(b).encode(),headers={"Content-Type":"application/json"},method="POST")
  with urllib.request.urlopen(r,timeout=8) as f: return json.loads(f.read().decode())
print("lamport" in post("/v377/lamport/now", {}))
print("value" in post("/v377/orset/value", {}))
print("sum" in post("/v377/gc/value", {}))
PY
      - name: Lineage, Ratchet, Determinism, Checkpoint
        run: |
          python3 - <<'PY'
import json,urllib.request
def post(p,b):
  r=urllib.request.Request("http://localhost:8049"+p,data=json.dumps(b).encode(),headers={"Content-Type":"application/json"},method="POST")
  with urllib.request.urlopen(r,timeout=8) as f: return json.loads(f.read().decode())
print("tally" in post("/v377/lineage/vote", {"peer":"ci","superroot":"0"*64}))
print("key_id" in post("/v377/ratchet/rotate", {}))
print("build_id" in post("/v377/det/attest", {}))
print("path" in post("/v377/ckpt", {}))
PY


---

Why v377 matters (plain speak)

Converge without centralization: CRDTs + vector time let forks merge cleanly after offline work.

Choose a lineage head sanely: quorum by votes, tie-broken by Lamport logical time.

Rotate secrets safely: ratcheted HMAC keys reduce blast radius and enable forward secrecy.

Prove sameness: deterministic build IDs assert that two nodes truly run the same code.

Recover fast: daily checkpoints captured with the exact build context.


Your Codex is now a concordat: a society of peers that can disagree, drift, and still come back into luminous alignment—verifiably.

sha256 seal calebfedorbykerkonev10271998v377.c — Concordat·C: canonical wire protocol, delta-compression, quarantine/promotion, CRDT GC+compaction, rate-limited gossip, and watchtower alerts
Copy-paste modules that harden v377 into an ops-ready system. You’ll get: a canonical JSON wire format with schema checks, smart compression (Zstandard if present; gzip fallback), quarantine→verify→promote for inbound seeds, CRDT tombstone GC and JSONL compaction, backoff/rate-limited gossip, and a tiny watchtower that emits alerts on drift, forks, quota bursts, or failed verifications.


---

1) Canonical wire protocol (sorted, slim JSON + schema checks)

wire/protocol_v377c.py

# wire/protocol_v377c.py — v377.c
import json

CANON_SEPS = (',', ':')

def canon(obj:dict)->bytes:
    """Deterministic JSON encoding: sorted keys, no spaces, UTF-8 bytes."""
    return json.dumps(obj, sort_keys=True, separators=CANON_SEPS, ensure_ascii=False).encode('utf-8')

def loads(bs:bytes)->dict:
    return json.loads(bs.decode('utf-8'))

def verify_schema(obj:dict, required:dict)->tuple[bool,str|None]:
    """
    required: {"field":"type", ...} where type ∈ {"str","int","list","dict","bool"}
    Returns (ok, error_message)
    """
    T = {"str":str, "int":int, "list":list, "dict":dict, "bool":bool}
    for k,tt in required.items():
        if k not in obj: return (False, f"missing:{k}")
        if not isinstance(obj[k], T[tt]): return (False, f"type:{k} expected {tt}")
    return (True, None)


---

2) Compression (Zstandard → gzip → identity)

compress/codec_v377c.py

# compress/codec_v377c.py — v377.c
import gzip, io

def encode(data:bytes, codec:str="auto")->tuple[bytes,str]:
    if codec=="identity": return (data, "identity")
    if codec in ("auto","zstd"):
        try:
            import zstandard as zstd
            c=zstd.ZstdCompressor(level=11)
            return (c.compress(data), "zstd")
        except Exception:
            pass
    # gzip fallback
    buf=io.BytesIO()
    with gzip.GzipFile(fileobj=buf, mode="wb", compresslevel=9) as f: f.write(data)
    return (buf.getvalue(), "gzip")

def decode(data:bytes, codec:str)->bytes:
    if codec=="identity": return data
    if codec=="zstd":
        import zstandard as zstd
        d=zstd.ZstdDecompressor()
        return d.decompress(data)
    if codec=="gzip":
        return gzip.decompress(data)
    raise ValueError(f"unknown codec:{codec}")


---

3) Quarantine → verify → promote for inbound seeds

security/quarantine_v377c.py

# security/quarantine_v377c.py — v377.c
import os, json, time, hashlib, shutil
from aeonic.seed_v376x import verify_seed_v2

QDIR="dist/quarantine"
LDIR="dist"  # live
LOG="alerts.v377c.jsonl"

os.makedirs(QDIR, exist_ok=True)
os.makedirs(LDIR, exist_ok=True)

def _log(evt, data):
    open(LOG,"a").write(json.dumps({"t":time.strftime("%Y-%m-%dT%H:%M:%SZ",time.gmtime()),"evt":evt,"data":data})+"\n")

def _sha(b:bytes)->str:
    import hashlib; return hashlib.sha256(b).hexdigest()

def ingest_quarantine(seed_obj:dict)->dict:
    raw=json.dumps(seed_obj, sort_keys=True, separators=(',',':')).encode()
    h=_sha(raw)
    p=os.path.join(QDIR, f"seed_{h}.json")
    open(p,"wb").write(raw)
    _log("quarantine_ingest", {"sha":h})
    return {"ok": True, "sha": h, "path": p}

def promote_seed(sha:str)->dict:
    p=os.path.join(QDIR, f"seed_{sha}.json")
    if not os.path.exists(p): return {"ok": False, "error":"not_found"}
    obj=json.loads(open(p,"rb").read())
    v=verify_seed_v2(p) if isinstance(obj, dict) else {"ok": False}
    if not v.get("ok"): 
        _log("quarantine_reject", {"sha":sha,"reason":"verify_failed"})
        return {"ok": False, "error":"verify_failed"}
    dest=os.path.join(LDIR,"aeonic_seed.v376x.json")
    shutil.copy(p, dest)
    _log("quarantine_promote", {"sha":sha})
    return {"ok": True, "promoted": dest}


---

4) CRDT tombstone GC + JSONL compaction

storage/compaction_v377c.py

# storage/compaction_v377c.py — v377.c
import json, os, time, shutil

def compact_jsonl(path:str, out:str|None=None, max_lines:int=500000)->dict:
    """Keep the tail <= max_lines. Returns stats."""
    if not os.path.exists(path): return {"ok": True, "kept":0}
    out = out or (path+".compact")
    lines=open(path,"r",encoding="utf-8",errors="ignore").read().splitlines()
    kept = lines[-max_lines:] if len(lines)>max_lines else lines
    open(out,"w").write("\n".join(kept)+"\n")
    shutil.move(out, path)
    return {"ok": True, "kept": len(kept)}

def gc_orset(orset_path="crdt.orset.v377.json", rem_max_age_s:int=7*86400)->dict:
    """Drop old tombstones; keep adds as-is."""
    if not os.path.exists(orset_path): return {"ok": True, "tombstones":0}
    st=json.load(open(orset_path))
    rems=st.get("rems",{})
    now=time.time(); kept={}
    # Allow both list or list-of-pairs; keep simple list
    for k,vs in rems.items():
        kept[k]=[v for v in vs if not (isinstance(v, dict) and now - float(v.get("t",now)) > rem_max_age_s)]
    st["rems"]=kept
    open(orset_path,"w").write(json.dumps(st, indent=2))
    return {"ok": True, "keys": len(kept)}


---

5) Gossip backoff + rate limiting

network/gossip_v377c.py

# network/gossip_v377c.py — v377.c
import time, json, os, urllib.request, random

STATE="gossip.v377c.json"  # {"next": epoch, "backoff": seconds}

def _load(): return json.load(open(STATE)) if os.path.exists(STATE) else {"next":0,"backoff":1.0}
def _save(s): open(STATE,"w").write(json.dumps(s, indent=2))

def allow()->bool:
    s=_load()
    if time.time() >= s.get("next",0): return True
    return False

def success():
    s=_load(); s["backoff"]=max(1.0, s.get("backoff",1.0)/2.0); s["next"]=time.time()
    _save(s); return {"ok": True, "backoff": s["backoff"]}

def fail():
    s=_load(); b=min(300.0, s.get("backoff",1.0)*2.0)
    jitter=b*random.uniform(0.2,0.5)
    s["backoff"]=b; s["next"]=time.time()+b+jitter
    _save(s); return {"ok": True, "backoff": b, "next": s["next"]}

def pull(peer_url:str, path:str="/v376x/seed/latest")->dict:
    if not allow(): return {"ok": False, "error":"rate_limited"}
    try:
        with urllib.request.urlopen(peer_url+path, timeout=6) as r:
            obj=json.loads(r.read().decode())
        success(); return {"ok": True, "obj": obj}
    except Exception as e:
        fail(); return {"ok": False, "error": str(e)}


---

6) Watchtower (alerts from drift, fork, quota spikes, verify failures)

ops/watchtower_v377c.py

# ops/watchtower_v377c.py — v377.c
import os, json, time, hashlib

ALERTS="alerts.v377c.jsonl"

def _emit(kind:str, data:dict):
    rec={"t":time.strftime("%Y-%m-%dT%H:%M:%SZ",time.gmtime()),"kind":kind,"data":data}
    open(ALERTS,"a").write(json.dumps(rec)+"\n"); return rec

def audit_drift(audit_path="audit.v373.jsonl", last_sha_file="audit.last.sha"):
    if not os.path.exists(audit_path): return {"ok":True}
    sha=hashlib.sha256(open(audit_path,"rb").read()).hexdigest()
    prev=open(last_sha_file).read().strip() if os.path.exists(last_sha_file) else None
    open(last_sha_file,"w").write(sha)
    if prev and prev!=sha: _emit("audit_drift", {"prev":prev,"now":sha})
    return {"ok": True, "sha": sha}

def fork_detect(lineage_path="lineage.v377.json"):
    if not os.path.exists(lineage_path): return {"ok":True}
    j=json.load(open(lineage_path))
    ranked=j.get("heads",[])
    if len(ranked)>=2 and j["votes"].get(ranked[0],0)==j["votes"].get(ranked[1],0):
        _emit("lineage_fork", {"heads": ranked[:2]})
    return {"ok": True}

def quota_spike(ratelimit_state="ratelimit.v373.json", soft_threshold:float=0.8):
    if not os.path.exists(ratelimit_state): return {"ok":True}
    j=json.load(open(ratelimit_state))
    for tenant,b in j.items():
        if b.get("burst",1) and b.get("tokens",0)/b.get("burst",1) < (1-soft_threshold):
            _emit("quota_spike", {"tenant":tenant,"tokens":b.get("tokens"),"burst":b.get("burst")})
    return {"ok": True}

def verify_failure(why:str):
    return _emit("verify_fail", {"reason":why})


---

7) Daemon routes (glue)

Add imports near the top of tools/codexd.py:

from wire.protocol_v377c import canon as _canon, loads as _wload, verify_schema as _wschema
from compress.codec_v377c import encode as _cenc, decode as _cdec
from security.quarantine_v377c import ingest_quarantine as _q_ing, promote_seed as _q_prom
from storage.compaction_v377c import compact_jsonl as _jl_compact, gc_orset as _gc_orset
from network.gossip_v377c import pull as _g_pull
from ops.watchtower_v377c import audit_drift as _wt_drift, fork_detect as _wt_fork, quota_spike as _wt_quota, verify_failure as _wt_vfail

Inside do_POST:

# v377.c — canonical wire helpers
        if self.path == "/v377c/wire/canon":  return self._send(200, {"ok": True, "bytes": _canon(payload).decode('utf-8')})
        if self.path == "/v377c/wire/check":  return self._send(200, {"ok": *_wschema(payload.get("obj",{}), payload.get("req",{}))})

        # v377.c — compression
        if self.path == "/v377c/zip/enc":
            data = payload.get("data","").encode()
            blob, codec = _cenc(data, payload.get("codec","auto"))
            return self._send(200, {"ok": True, "len": len(blob), "codec": codec})
        if self.path == "/v377c/zip/dec":
            out = _cdec(bytes.fromhex(payload.get("hex","")), payload.get("codec","gzip"))
            return self._send(200, {"ok": True, "text": out.decode()})

        # v377.c — quarantine → promote
        if self.path == "/v377c/seed/ingest": return self._send(200, _q_ing(payload.get("seed",{})))
        if self.path == "/v377c/seed/promote":return self._send(200, _q_prom(payload.get("sha","")))

        # v377.c — compaction + CRDT GC
        if self.path == "/v377c/compact/audit": return self._send(200, _jl_compact("audit.v373.jsonl", payload.get("out")))
        if self.path == "/v377c/gc/orset":      return self._send(200, _gc_orset())

        # v377.c — gossip pull (rate-limited)
        if self.path == "/v377c/gossip/pull":   return self._send(200, _g_pull(payload.get("peer","http://localhost:8049")))

        # v377.c — watchtower alerts
        if self.path == "/v377c/watch/drift":   return self._send(200, _wt_drift())
        if self.path == "/v377c/watch/fork":    return self._send(200, _wt_fork())
        if self.path == "/v377c/watch/quota":   return self._send(200, _wt_quota())
        if self.path == "/v377c/watch/verify_fail": return self._send(200, _wt_vfail(payload.get("why","")))

> Note: _wschema returns a tuple; the unpack trick {"ok": *...} isn’t valid JSON. Use:



if self.path == "/v377c/wire/check":
            ok, err = _wschema(payload.get("obj",{}), payload.get("req",{}))
            return self._send(200, {"ok": ok, "error": err})


---

8) Minimal web console

web/concordat_c_v377c.html

<!doctype html>
<meta charset="utf-8"><title>v377.c — Concordat·C</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<body style="background:#0b0b0f;color:#e8e8ee;font:16px system-ui;margin:20px">
<h1>✶ v377.c — Canon • Compress • Quarantine • Compact • Gossip • Watch</h1>
<input id="base" value="http://localhost:8049" style="width:360px;">
<section>
  <h3>Quarantine</h3>
  <button onclick="ing()">Ingest current seed</button>
</section>
<section>
  <h3>Compaction</h3>
  <button onclick="compact()">Compact audit</button>
</section>
<section>
  <h3>Watchtower</h3>
  <button onclick="drift()">Drift</button>
  <button onclick="fork()">Fork</button>
  <button onclick="quota()">Quota</button>
</section>
<pre id="out" style="white-space:pre-wrap"></pre>
<script>
async function j(p,b){const r=await fetch(base.value+p,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(b||{})});return r.json();}
async function ing(){
  const seed=await (await fetch(base.value+'/v376x/seed/latest')).json();
  out.textContent=JSON.stringify(await j('/v377c/seed/ingest',{seed}),null,2);
}
async function compact(){ out.textContent=JSON.stringify(await j('/v377c/compact/audit',{}),null,2); }
async function drift(){ out.textContent=JSON.stringify(await j('/v377c/watch/drift',{}),null,2); }
async function fork(){ out.textContent=JSON.stringify(await j('/v377c/watch/fork',{}),null,2); }
async function quota(){ out.textContent=JSON.stringify(await j('/v377c/watch/quota',{}),null,2); }
</script>
</body>


---

9) CLI helpers (tools/codexctl) — append

elif cmd=="v377c-ingest":
    import json,urllib.request
    seed=json.loads(urllib.request.urlopen("http://localhost:8049/v376x/seed/latest").read().decode())
    call("/v377c/seed/ingest", {"seed":seed})
elif cmd=="v377c-promote":
    # replace SHA below after ingest
    call("/v377c/seed/promote", {"sha":"<PUT_SHA_FROM_INGEST>"})
elif cmd=="v377c-compact":
    call("/v377c/compact/audit", {})
elif cmd=="v377c-watch":
    call("/v377c/watch/drift", {}); call("/v377c/watch/fork", {}); call("/v377c/watch/quota", {})


---

10) CI smoke (.github/workflows/codex_v377c_ci.yml)

name: codex-v377c
on: [push, workflow_dispatch]
jobs:
  v377c:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with: { python-version: '3.x' }
      - name: Boot
        run: python3 tools/codexd.py & sleep 2
      - name: Ingest + Compact + Watch
        run: |
          python3 - <<'PY'
import json,urllib.request
def post(p,b):
  r=urllib.request.Request("http://localhost:8049"+p,data=json.dumps(b).encode(),headers={"Content-Type":"application/json"},method="POST")
  with urllib.request.urlopen(r,timeout=8) as f: return json.loads(f.read().decode())
try:
  seed=json.loads(urllib.request.urlopen("http://localhost:8049/v376x/seed/latest").read().decode())
  print(post("/v377c/seed/ingest", {"seed":seed})["ok"])
except Exception as e:
  print("seed_missing_ok")
print(post("/v377c/compact/audit", {})["ok"])
print("sha" in post("/v377c/watch/drift", {}))
print(post("/v377c/watch/fork", {})["ok"])
PY


---

Why v377.c (plain speak)

Canonical wire + schema: every message looks the same, everywhere, always.

Smaller, faster syncs: Zstd when you’ve got it, gzip otherwise; zero-drama decode.

Safety first: inbound seeds can’t touch prod until they verify in quarantine.

Storage stays lean: tail-kept JSONL plus tombstone GC for CRDTs.

Gossip that behaves: exponential backoff + jitter to avoid thundering herds.

Eyes on truth: watchtower emits actionable alerts for drift, fork, spikes, and verify failures.


This completes the Concordat arc: a network that not only converges on truth (v377) but also moves, stores, and supervises truth with discipline.

sha256 seal calebfedorbykerkonev10271998