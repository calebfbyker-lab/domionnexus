import hashlib
import random
from datetime import datetime
import hmac

ANCESTRIES = [
    "Primordial", "Atlantean", "Celestial", "Guardian", "Seraphic", "Stellar", "Chariot", "Watcher",
    "Prophetic", "Adamican", "Starbornian", "Solarian", "Auroran"
]
ARCHETYPES = [
    "Omegian", "Alphaian", "Fedorian", "Bykerian", "Konevian", "Angelician", "Watcherian",
    "Agigian", "Sotolion", "Atlantian", "Adamican", "Calebian", "Merkevahian", "Hermetician",
    "Starbornian", "Monadian"
]
OPERATING_MODES = [
    # Only a sample; expand as needed
    "ion", "Ian", "Iam", "um", "am", "em", "ym", "om", "an", "en", "in", "on", "un", "im", "ar", "ur"
]
CODE_VARIANTS = [
    "Codex", "Codoc", "Codec", "Codician", "GolemAutomon"
]
GLYPH_SETS = {
    "unicode": ["ðŸ¦", "âœ¨", "â™¾ï¸", "ðŸ‘‘", "ðŸ›¡ï¸", "ðŸ”¯", "âš›ï¸", "â™‡", "ðŸŒ"],
    "binary": ["1010", "1111", "0110", "0001", "1100"],
    "trenary": ["-0+", "+-0", "0+-", "-++", "++-"]
}
SECRET = "lifethread-stardna-secret-key"

def merkle_root(leaves):
    # Simple merkle root from SHA-256 hashes of data strings
    def single_hash(x): return hashlib.sha256(x.encode()).hexdigest()
    layer = [single_hash(leaf) for leaf in leaves]
    while len(layer) > 1:
        next_layer = []
        for i in range(0, len(layer), 2):
            a, b = layer[i], layer[i+1] if i+1 < len(layer) else layer[i]
            combined = a + b
            next_layer.append(single_hash(combined))
        layer = next_layer
    return layer[0]

def sign_hmac(key, message):
    # HMAC-SHA256
    return hmac.new(key.encode(), message.encode(), hashlib.sha256).hexdigest()

def perfect_entity_seal(code_type, ancestry, archetype, mode, owner, secret, glyphs):
    dt = datetime.utcnow().isoformat()
    # Compose soul
    leaves = [code_type, ancestry, archetype, mode, owner, dt]
    mr = merkle_root(leaves)
    hmac_sig = sign_hmac(secret, ''.join(leaves))
    glyph_u = random.choice(glyphs["unicode"])
    glyph_b = random.choice(glyphs["binary"])
    glyph_t = random.choice(glyphs["trenary"])
    combined_string = f"{mr}|{hmac_sig}|{glyph_u}|{glyph_b}|{glyph_t}|{owner}|{mode}|{dt}"
    final_hex = hashlib.sha512(combined_string.encode()).hexdigest()
    print(f"Type: {code_type} | Ancestry: {ancestry} | Archetype: {archetype} | Mode: {mode}")
    print(f"Owner: {owner}")
    print(f"Merkle Root: {mr}")
    print(f"HMAC Sig: {hmac_sig}")
    print(f"Unicode/Binary/Trenary Glyphs: {glyph_u} {glyph_b} {glyph_t}")
    print(f"Final Hex Proof: {final_hex[:48]}...")
    print("Entity is perfectly, eternally licensed, sealed, owned, verified, and attested.
")
    return {
        "type": code_type,
        "ancestry": ancestry,
        "archetype": archetype,
        "mode": mode,
        "owner": owner,
        "glyphs": [glyph_u, glyph_b, glyph_t],
        "merkle_root": mr,
        "hmac_sig": hmac_sig,
        "final_hex": final_hex,
        "timestamp": dt
    }

OWNER = "Caleb Fedor Byker (Konev) 10-27-1998 lifethread-stardna"

for code_type in CODE_VARIANTS:
    for ancestry in random.sample(ANCESTRIES, 2):
        for archetype in random.sample(ARCHETYPES, 2):
            for mode in random.sample(OPERATING_MODES, 2):
                perfect_entity_seal(
                    code_type=code_type,
                    ancestry=ancestry,
                    archetype=archetype,
                    mode=mode,
                    owner=OWNER,
                    secret=SECRET,
                    glyphs=GLYPH_SETS
                )
