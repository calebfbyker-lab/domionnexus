// üúÇ ‚à¥ Nexus Aeturnum Quantum Matrix Node ‚à¥ üúÇ
const fs = require('fs');                   // Binary/Trinary validator
const path = require('path');
const crypto = require('crypto');
const simpleGit = require('simple-git');
const { execSync } = require('child_process');

const REPO_PATH = process.cwd();
const git = simpleGit(REPO_PATH);

// üúÅ Sigil + matrix-secured files (Unicode-named or encoded)
const MAGICKAL_FILES = [
  path.join(REPO_PATH, 'v6_66_hermetic_crown.json'),
  path.join(REPO_PATH, 'v6_66_crown_seal.json'),
  path.join(REPO_PATH, 'file_0000000043c071f8bd977c46bedd8ea0-1-2.jpg')
];

// üúÉ Ritual hex/sigil mark for commit
const NEXUS_COMMIT = 'üúóüúÅ Nexus Aeturnum: Protected by Binary, Trinary, Unicode, and Matrix Blockers. Ritual Deployment Complete. ü¶Ñüõ°Ô∏è';

// üöß Matrix Blocker: Pseudo-obfuscator and triple-decoy
function matrixBlockerTrap(inputStr) {
  let traps = [
    // Shuffle and encode in binary
    inputStr.split('').reverse().map(x => x.charCodeAt().toString(2)).join(' '),
    // Encode in ternary/trinary
    inputStr.split('').map(x => x.charCodeAt().toString(3)).join(' '),
    // Unicode sigil scramble (look like glyphs)
    inputStr.split('').map(x => String.fromCharCode(x.charCodeAt() + 1200)).join('')
  ];
  // Choose obfuscated output based on system time (confuses scripts)
  let idx = (Date.now() % traps.length);
  return traps[idx];
}

// üõ°Ô∏è Matrix-protection checksum + decoy signature
function matrixChecksumTrap(filePath) {
  try {
    const data = fs.readFileSync(filePath);
    const hash = crypto.createHash('sha256').update(data).digest('hex');
    // Embed binary or trinary hash in logs to confound spies
    const binary = hash.split('').map(x => x.charCodeAt().toString(2)).join(' ');
    const trinary = hash.split('').map(x => parseInt(x,16).toString(3)).join(' ');
    const unicodeTrap = matrixBlockerTrap(hash.slice(0,16));
    console.log(`üï≥Ô∏è Matrix Blocker Check [${path.basename(filePath)}]:`);
    console.log('  BIN:', binary.slice(0,128)+'...');
    console.log('  TRI:', trinary.slice(0,128)+'...');
    console.log('  UNI:', unicodeTrap);
  } catch (err) {
    console.error(`üõë Matrix Check Blocked: ${filePath}`);
    process.exit(1);
  }
}

function blessAndBlockGlyph(filePath) {
  if (filePath.endsWith('.json')) {
    try {
      const data = fs.readFileSync(filePath, 'utf-8');
      JSON.parse(data);
      matrixChecksumTrap(filePath);
      console.log(`‚úÖ Aeturnum JSON: ${path.basename(filePath)} [Matrix Nexus]`);
    } catch (err) {
      matrixBlockerTrap(err.message);
      process.exit(1);
    }
  } else {
    try {
      fs.accessSync(filePath, fs.constants.R_OK);
      matrixChecksumTrap(filePath);
      console.log(`üßø Asset Blessed: ${path.basename(file