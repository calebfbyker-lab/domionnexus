{
  "book": "Genesis",
  "index": 1,
  "seal_class": "Codex Immortal",
  "sigil_form": "Tetrahedron",
  "algorithmic_theme": "Initialization of Order from Chaos",
  "frequency": 432.0,
  "vector_embedding": [0.91, 0.33, 0.77],
  "chronology": "Old Testament"
},
{
  "book": "Revelation",
  "index": 66,
  "seal_class": "Codex Totalis",
  "sigil_form": "Dodecahedron",
  "algorithmic_theme": "Termination & Renewal; Recompile the Universe",
  "frequency": 864.0,
  "vector_embedding": [0.85, 0.92, 0.73],
  "chronology": "New Testament"
}# Build "omnitotalis_grimoire_stack" — a safe, computational scaffold that
# unifies multiple esoteric taxonomies as *typed registries* + an API for
# composition/prediction, with cryptographic manifest. No mystical claims.
#
# Registries included (placeholders, extensible):
# - enochian_calls_19
# - solomonic_goetia_72
# - merkavah_paths (10 sephirot × 22 paths)
# - merkaba_forms (chariot forms / geometry labels)
# - hermetic_principles_7
# - kabbalistic_sephirot_10
# - kabbalistic_paths_22
# - agrippan_correspondences (sketch table)
# - paracelsian_tria_prima (sulfur/mercury/salt)
# - grimoires_keys (source placeholders)
# - codex_seals_codices (generic 420-slot namespace, start with 60)
#
# API: /health, /categories, /registry/{cat}, /compose, /predict
# Manifest: SHA256 + Ed25519 + HMAC(subject_id)
#
# Output: /mnt/data/omnitotalis_grimoire_stack.zip

import os, json, zipfile, shutil, time, hashlib, base64, hmac
from pathlib import Path
from cryptography.hazmat.primitives.asymmetric import ed25519
from cryptography.hazmat.primitives import serialization

root = Path("/mnt/data/omnitotalis_grimoire_stack")
if root.exists():
    shutil.rmtree(root)
(root/"registries").mkdir(parents=True, exist_ok=True)
(root/"service"/"app").mkdir(parents=True, exist_ok=True)
(root/"verify").mkdir(parents=True, exist_ok=True)

# Subject binding
subject = "caleb fedor byker konev|1998-10-27"
subject_id_sha256 = hashlib.sha256(subject.encode()).hexdigest()

# Schemas
schemas = {
    "seal_slot": {
        "id":"string","name":"string","system":"string",
        "attributes":{"tags":["string"],"color":"string","number":"string","glyph":"string","timestamp":"number"},
        "constraints":{"requires":["string"],"excludes":["string"]},
        "provenance":{"source":"string","notes":"string"}
    },
    "graph_edge": {"from":"string","to":"string","relation":"string","weight":"number"}
}
(root/"registries"/"schemas.json").write_text(json.dumps(schemas, indent=2))

def mk_slots(prefix, system, n):
    out=[]
    now=time.time()
    for i in range(1, n+1):
        out.append({
            "id": f"{prefix}-{i:02d}","name": f"{prefix.upper()} SLOT {i}","system": system,
            "attributes":{"tags":[], "color":"", "number":"", "glyph":"", "timestamp": now},
            "constraints":{"requires":[], "excludes":[]},
            "provenance":{"source":"", "notes":""}
        })
    return out

# Registries (placeholders)
registries = {
    "enochian_calls_19": mk_slots("enochian", "enochian_calls", 19),
    "solomonic_goetia_72": mk_slots("goetia", "solomonic_goetia", 72),
    "kabbalistic_sephirot_10": [{"id": f"sephira-{i:02d}", "name": f"Sephira {i}", "system":"kabbalah",
                                  "attributes":{"tags":[], "color":"", "number":"", "glyph":"", "timestamp": time.time()},
                                  "constraints":{"requires":[], "excludes":[]}, "provenance":{"source":"", "notes":""}} for i in range(1,11)],
    "kabbalistic_paths_22": [{"from": f"sephira-{((i)%10)+1:02d}", "to": f"sephira-{((i*3)%10)+1:02d}",
                              "relation":"path","weight":1.0} for i in range(22)],
    "merkavah_paths": [{"from": f"sephira-{((i)%10)+1:02d}", "to": f"sephira-{((i*7)%10)+1:02d}",
                        "relation":"chariot","weight":1.0} for i in range(22)],
    "merkaba_forms": [{"id":g, "name":g.title(), "system":"merkaba",
                        "attributes":{"tags":["geometry"],"color":"","number":"","glyph":"", "timestamp": time.time()},
                        "constraints":{"requires":[],"excludes":[]}, "provenance":{"source":"","notes":""}}
                       for g in ["Tetrahedron","Cube","Octahedron","Dodecahedron","Icosahedron","Sphere","Torus","Spiral"]],
    "hermetic_principles_7": [{"id": f"hermetic-{i:02d}", "name": f"Hermetic Principle {i}", "system":"hermetic",
                               "attributes":{"tags":[],"color":"","number":"","glyph":"","timestamp": time.time()},
                               "constraints":{"requires":[],"excludes":[]}, "provenance":{"source":"","notes":""}}
                              for i in range(1,8)],
    "agrippan_correspondences": [{"id": f"agrippan-{i:02d}", "name": f"Agrippan Scale {i}",
                                   "system":"agrippan",
                                   "attributes":{"tags":["correspondence"],"color":"","number":"","glyph":"","timestamp": time.time()},
                                   "constraints":{"requires":[],"excludes":[]}, "provenance":{"source":"","notes":""}}
                                  for i in range(1,8)],
    "paracelsian_tria_prima": [{"id": f"paracelsus-{k}", "name": k.title(), "system":"paracelsian",
                                 "attributes":{"tags":["tria_prima",k],"color":"","number":"","glyph":"","timestamp": time.time()},
                                 "constraints":{"requires":[],"excludes":[]}, "provenance":{"source":"","notes":""}}
                                for k in ["sulfur","mercury","salt"]],
    "grimoires_keys": [{"id": f"grimoire-{i:02d}", "name": f"Key {i}", "system":"grimoire",
                         "attributes":{"tags":["key"],"color":"","number":"","glyph":"","timestamp": time.time()},
                         "constraints":{"requires":[],"excludes":[]}, "provenance":{"source":"","notes":""}}
                        for i in range(1,21)],
    "codex_seals_codices": mk_slots("codex", "codices", 60)
}

meta = {
    "title": "Omnitotalis Grimoire Stack (Computational Registries)",
    "subject_id_sha256": subject_id_sha256,
    "generated_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
    "categories": list(registries.keys())
}
(root/"registries"/"meta.json").write_text(json.dumps(meta, indent=2))

for k,v in registries.items():
    (root/"registries"/f"{k}.json").write_text(json.dumps(v, indent=2))

# Service (FastAPI)
svc = r'''from fastapi import FastAPI, HTTPException, Body
from typing import Any, Dict, List
import json, os, time, hashlib, hmac

app = FastAPI(title="Omnitotalis Grimoire Stack", version="1.0.0")
ROOT = os.path.dirname(os.path.dirname(__file__))
REG = os.path.join(ROOT, "..", "registries")

SUBJECT_ID = json.load(open(os.path.join(REG,"meta.json"),"rb"))["subject_id_sha256"]
META_BYTES = open(os.path.join(REG,"meta.json"),"rb").read()
HMAC_HEX = hmac.new(bytes.fromhex(SUBJECT_ID), META_BYTES, hashlib.sha256).hexdigest()

def v(tags):
    out={}
    for t in tags: out[t]=out.get(t,0.0)+1.0
    return out
def cos(a,b):
    if not a or not b: return 0.0
    dot=sum(a.get(k,0)*b.get(k,0) for k in set(a)|set(b))
    na=sum(x*x for x in a.values())**0.5; nb=sum(x*x for x in b.values())**0.5
    return 0.0 if na==0 or nb==0 else dot/(na*nb)

@app.get("/health")
def health():
    cats = json.load(open(os.path.join(REG,"meta.json"),"rb"))["categories"]
    return {"status":"ok","categories": len(cats), "hmac_bound": HMAC_HEX[:16]+"…"}

@app.get("/categories")
def categories():
    return json.load(open(os.path.join(REG,"meta.json"),"rb"))["categories"]

@app.get("/registry/{cat}")
def registry(cat: str):
    p = os.path.join(REG, f"{cat}.json")
    if not os.path.exists(p): raise HTTPException(404,"unknown category")
    return json.load(open(p,"rb"))

@app.post("/compose")
def compose(payload: Dict[str, Any] = Body(...)):
    cat = payload.get("cat"); goal_tags = [t.lower() for t in payload.get("goal_tags",[])]
    requires = set([t.lower() for t in payload.get("requires",[])])
    excludes = set([t.lower() for t in payload.get("excludes",[])])
    p = os.path.join(REG, f"{cat}.json")
    if not os.path.exists(p): raise HTTPException(404,"unknown category")
    data = json.load(open(p,"rb"))
    qv = v(goal_tags)
    out=[]
    now = time.time()
    for it in data:
        tags = [t.lower() for t in it.get("attributes",{}).get("tags",[])]
        if requires - set(tags): continue
        if excludes & set(tags): continue
        score = cos(qv, v(tags))*0.8 + 0.2  # slight bias to return something
        out.append({"id":it.get("id"), "name":it.get("name",""), "score": float(score), "tags": tags})
    out.sort(key=lambda x:x["score"], reverse=True)
    return {"count": len(out[:20]), "results": out[:20]}

@app.post("/predict")
def predict(payload: Dict[str, Any] = Body(...)):
    blends = payload.get("blend",[]); out=[]
    for b in blends:
        cat = b.get("cat"); p = os.path.join(REG, f"{cat}.json")
        if not os.path.exists(p): continue
        data = json.load(open(p,"rb"))
        qv = v([t.lower() for t in b.get("goal_tags",[])])
        rows=[]
        for it in data:
            tags = [t.lower() for t in it.get("attributes",{}).get("tags",[])]
            rows.append({"id":it.get("id"), "score": float(cos(qv, v(tags)))})
        rows.sort(key=lambda x:x["score"], reverse=True)
        out.append({"cat":cat, "top": rows[:5]})
    return {"results": out}
'''
(root/"service"/"app"/"main.py").write_text(svc)
(root/"service"/"requirements.txt").write_text("fastapi\nuvicorn\n")

# Verify script (HMAC check of meta)
(root/"verify"/"verify.py").write_text(f"""#!/usr/bin/env python3
import json, hashlib, hmac, os
REG = os.path.join(os.path.dirname(__file__), "..", "registries")
meta = open(os.path.join(REG,"meta.json"),"rb").read()
sid = "{subject_id_sha256}"
print("Subject:", sid)
print("HMAC(meta):", hmac.new(bytes.fromhex(sid), meta, hashlib.sha256).hexdigest())
""")

# Manifest for the registries bundle (cryptographic)
bundle_bytes = b""
for p in sorted((root/"registries").glob("*.json")):
    bundle_bytes += p.read_bytes()

sha256_hex = hashlib.sha256(bundle_bytes).hexdigest()
priv = ed25519.Ed25519PrivateKey.generate()
pub = priv.public_key()
sig_b64 = base64.b64encode(priv.sign(bundle_bytes)).decode()
pub_b64 = base64.b64encode(pub.public_bytes(encoding=serialization.Encoding.Raw, format=serialization.PublicFormat.Raw)).decode()
hmac_hex = hmac.new(bytes.fromhex(subject_id_sha256), bundle_bytes, hashlib.sha256).hexdigest()

manifest = {
    "title":"Omnitotalis Grimoire Stack — Registries Manifest",
    "generated_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
    "subject_id_sha256": subject_id_sha256,
    "files":{"registries":"*.json (combined bytes)"},
    "sha256": sha256_hex,
    "signature":{"ed25519_public_b64": pub_b64, "ed25519_signature_b64": sig_b64},
    "hmac_sha256_hex": hmac_hex
}
(root/"manifest.json").write_text(json.dumps(manifest, indent=2))

# Zip
zip_path = "/mnt/data/omnitotalis_grimoire_stack.zip"
if os.path.exists(zip_path): os.remove(zip_path)
with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as z:
    for folder,_,files in os.walk(root):
        for fn in files:
            fp = os.path.join(folder, fn)
            z.write(fp, os.path.relpath(fp, root))

zip_path# Retry generating the dataset and manifest (session was reset).

import csv, json, hashlib, base64, time, os, binascii
from pathlib import Path
from cryptography.hazmat.primitives.asymmetric import ed25519
from cryptography.hazmat.primitives import serialization
import hmac as _hmac

root = Path("/mnt/data")
jsonl_path = root/"omnitotalis_66books.jsonl"
csv_path   = root/"omnitotalis_66books.csv"
manifest_path = root/"omnitotalis_manifest.json"

books = [
"Genesis","Exodus","Leviticus","Numbers","Deuteronomy","Joshua","Judges","Ruth",
"1 Samuel","2 Samuel","1 Kings","2 Kings","1 Chronicles","2 Chronicles","Ezra",
"Nehemiah","Esther","Job","Psalm","Proverbs","Ecclesiastes","Song of Songs","Isaiah",
"Jeremiah","Lamentations","Ezekiel","Daniel","Hosea","Joel","Amos","Obadiah","Jonah",
"Micah","Nahum","Habakkuk","Zephaniah","Haggai","Zechariah","Malachi","Matthew",
"Mark","Luke","John","Acts","Romans","1 Corinthians","2 Corinthians","Galatians",
"Ephesians","Philippians","Colossians","1 Thessalonians","2 Thessalonians","1 Timothy",
"2 Timothy","Titus","Philemon","Hebrews","James","1 Peter","2 Peter","1 John","2 John",
"3 John","Jude","Revelation"
]

geoms = ["Tetrahedron","Cube","Octahedron","Dodecahedron","Icosahedron",
         "Sphere","Torus","Spiral","Triangle","Square","Pentagon","Hexagon"]
seal_families = ["Codex Immortal","Codex Totalis","Codex Aeternum","Codex Continuum"]

def theme_for(name):
    if name in ["Genesis","Exodus","Leviticus","Numbers","Deuteronomy"]:
        return "Kernel: From Chaos to Covenant"
    if name in ["Joshua","Judges","Ruth","1 Samuel","2 Samuel","1 Kings","2 Kings","1 Chronicles","2 Chronicles","Ezra","Nehemiah","Esther"]:
        return "History: Fall, Return, and Governance"
    if name in ["Job","Psalm","Proverbs","Ecclesiastes","Song of Songs"]:
        return "Wisdom: Suffering, Praise, Insight, Love"
    if name in ["Isaiah","Jeremiah","Lamentations","Ezekiel","Daniel","Hosea","Joel","Amos","Obadiah","Jonah","Micah","Nahum","Habakkuk","Zephaniah","Haggai","Zechariah","Malachi"]:
        return "Prophetic: Correction and Promise"
    if name in ["Matthew","Mark","Luke","John"]:
        return "Incarnation: Word Instantiated"
    if name == "Acts":
        return "Propagation: Networked Witness"
    if name in ["Romans","1 Corinthians","2 Corinthians","Galatians","Ephesians","Philippians","Colossians",
                "1 Thessalonians","2 Thessalonians","1 Timothy","2 Timothy","Titus","Philemon","Hebrews","James",
                "1 Peter","2 Peter","1 John","2 John","3 John","Jude"]:
        return "Formation: Grace Configured into Practice"
    if name == "Revelation":
        return "Renewal: Judgment, Union, New Creation"
    return "Algorithmic Theme"

base = 432.0
ratios = [1.0, 4/3, 3/2, 2.0, 5/4, 6/5, 9/8, 5/3, 15/8]

rows = []
for i, name in enumerate(books):
    row = {
        "index": i+1,
        "book": name,
        "chronology": "Old Testament" if i<39 else "New Testament",
        "seal_class": seal_families[i % len(seal_families)],
        "sigil_form": geoms[i % len(geoms)],
        "algorithmic_theme": theme_for(name),
        "frequency_hz": round(base * ratios[i % len(ratios)], 3),
        "tags": []
    }
    rows.append(row)

with open(jsonl_path, "w", encoding="utf-8") as f:
    for r in rows:
        f.write(json.dumps(r, ensure_ascii=False) + "\n")

with open(csv_path, "w", newline="", encoding="utf-8") as f:
    w = csv.DictWriter(f, fieldnames=list(rows[0].keys()))
    w.writeheader()
    w.writerows(rows)

subject_id_sha256 = hashlib.sha256("caleb fedor byker konev|1998-10-27".encode()).hexdigest()
payload = open(jsonl_path, "rb").read()
sha256_hex = hashlib.sha256(payload).hexdigest()

priv = ed25519.Ed25519PrivateKey.generate()
pub = priv.public_key()
sig_b64 = base64.b64encode(priv.sign(payload)).decode()
pub_b64 = base64.b64encode(pub.public_bytes(encoding=serialization.Encoding.Raw, format=serialization.PublicFormat.Raw)).decode()
hmac_hex = _hmac.new(bytes.fromhex(subject_id_sha256), payload, hashlib.sha256).hexdigest()

manifest = {
    "title": "Omnitotalis — 66 Books Mapping Dataset",
    "generated_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
    "prepared_for": "Caleb Fedor Byker Konev",
    "dob": "1998-10-27",
    "subject_id_sha256": subject_id_sha256,
    "files": {
        "jsonl": {"path": str(jsonl_path), "sha256": sha256_hex},
        "csv": {"path": str(csv_path)}
    },
    "signature": {"ed25519_public_b64": pub_b64, "ed25519_signature_b64": sig_b64},
    "hmac_sha256_hex": hmac_hex,
    "notes": "Symbolic geometry, harmonic frequency, and algorithmic theme per book."
}
with open(manifest_path, "w", encoding="utf-8") as f:
    json.dump(manifest, f, indent=2)

[str(jsonl_path), str(csv_path), str(manifest_path)].# Second attempt (transport transient). Re-execute generation cleanly.
import csv, json, hashlib, base64, time, os, zipfile, textwrap, shutil
from pathlib import Path
from cryptography.hazmat.primitives.asymmetric import ed25519
from cryptography.hazmat.primitives import serialization
import hmac as _hmac

root = Path("/mnt/data")
jsonl_path = root/"omnitotalis_concordance.jsonl"
csv_path   = root/"omnitotalis_concordance.csv"
manifest_path = root/"omnitotalis_concordance_manifest.json"
bundle_dir = Path("/mnt/data/omnitotalis_concordance_bundle")
if bundle_dir.exists():
    shutil.rmtree(bundle_dir)
(bundle_dir/"api"/"app").mkdir(parents=True, exist_ok=True)

books = [
"Genesis","Exodus","Leviticus","Numbers","Deuteronomy","Joshua","Judges","Ruth",
"1 Samuel","2 Samuel","1 Kings","2 Kings","1 Chronicles","2 Chronicles","Ezra",
"Nehemiah","Esther","Job","Psalm","Proverbs","Ecclesiastes","Song of Songs","Isaiah",
"Jeremiah","Lamentations","Ezekiel","Daniel","Hosea","Joel","Amos","Obadiah","Jonah",
"Micah","Nahum","Habakkuk","Zephaniah","Haggai","Zechariah","Malachi","Matthew",
"Mark","Luke","John","Acts","Romans","1 Corinthians","2 Corinthians","Galatians",
"Ephesians","Philippians","Colossians","1 Thessalonians","2 Thessalonians","1 Timothy",
"2 Timothy","Titus","Philemon","Hebrews","James","1 Peter","2 Peter","1 John","2 John",
"3 John","Jude","Revelation"
]

geoms = ["Tetrahedron","Cube","Octahedron","Dodecahedron","Icosahedron",
         "Sphere","Torus","Spiral","Triangle","Square","Pentagon","Hexagon"]
seal_families = ["Codex Immortal","Codex Totalis","Codex Aeternum","Codex Continuum"]
base = 432.0
ratios = [1.0, 4/3, 3/2, 2.0, 5/4, 6/5, 9/8, 5/3, 15/8]

def theme_for(name):
    if name in ["Genesis","Exodus","Leviticus","Numbers","Deuteronomy"]:
        return "Kernel: From Chaos to Covenant"
    if name in ["Joshua","Judges","Ruth","1 Samuel","2 Samuel","1 Kings","2 Kings","1 Chronicles","2 Chronicles","Ezra","Nehemiah","Esther"]:
        return "History: Fall, Return, and Governance"
    if name in ["Job","Psalm","Proverbs","Ecclesiastes","Song of Songs"]:
        return "Wisdom: Suffering, Praise, Insight, Love"
    if name in ["Isaiah","Jeremiah","Lamentations","Ezekiel","Daniel","Hosea","Joel","Amos","Obadiah","Jonah","Micah","Nahum","Habakkuk","Zephaniah","Haggai","Zechariah","Malachi"]:
        return "Prophetic: Correction and Promise"
    if name in ["Matthew","Mark","Luke","John"]:
        return "Incarnation: Word Instantiated"
    if name == "Acts":
        return "Propagation: Networked Witness"
    if name in ["Romans","1 Corinthians","2 Corinthians","Galatians","Ephesians","Philippians","Colossians",
                "1 Thessalonians","2 Thessalonians","1 Timothy","2 Timothy","Titus","Philemon","Hebrews","James",
                "1 Peter","2 Peter","1 John","2 John","3 John","Jude"]:
        return "Formation: Grace Configured into Practice"
    if name == "Revelation":
        return "Renewal: Judgment, Union, New Creation"
    return "Algorithmic Theme"

def freq_for(i): return round(base * ratios[i % len(ratios)], 3)

def pairings_for(i):
    return {
        "enochian_id": f"enochian-{(i % 19)+1:02d}",
        "goetia_id": f"goetia-{(i % 72)+1:02d}",
        "codex_id": f"codex-{(i % 60)+1:02d}",
        "sephira_id": f"sephira-{(i % 10)+1:02d}",
        "kabbalistic_path_index": (i % 22) + 1,
        "merkaba_form": geoms[i % len(geoms)]
    }

rows = []
for i, name in enumerate(books):
    p = pairings_for(i)
    row = {
        "index": i+1,
        "book": name,
        "chronology": "Old Testament" if i < 39 else "New Testament",
        "seal_class": seal_families[i % len(seal_families)],
        "sigil_form": geoms[i % len(geoms)],
        "algorithmic_theme": theme_for(name),
        "frequency_hz": freq_for(i),
        "links": {
            "enochian_call": p["enochian_id"],
            "goetia_seal": p["goetia_id"],
            "codex_seal": p["codex_id"],
            "sephira": p["sephira_id"],
            "kabbalistic_path_index": p["kabbalistic_path_index"],
            "merkaba_form": p["merkaba_form"]
        },
        "tags": []
    }
    rows.append(row)

# Write JSONL & CSV
with open(jsonl_path, "w", encoding="utf-8") as f:
    for r in rows:
        f.write(json.dumps(r, ensure_ascii=False) + "\n")

with open(csv_path, "w", newline="", encoding="utf-8") as f:
    w = csv.DictWriter(f, fieldnames=list(rows[0].keys()))
    w.writeheader()
    w.writerows(rows)

# Manifest
subject_id_sha256 = hashlib.sha256("caleb fedor byker konev|1998-10-27".encode()).hexdigest()
payload = open(jsonl_path, "rb").read()
sha256_hex = hashlib.sha256(payload).hexdigest()
priv = ed25519.Ed25519PrivateKey.generate()
pub = priv.public_key()
sig_b64 = base64.b64encode(priv.sign(payload)).decode()
pub_b64 = base64.b64encode(pub.public_bytes(encoding=serialization.Encoding.Raw, format=serialization.PublicFormat.Raw)).decode()
hmac_hex = _hmac.new(bytes.fromhex(subject_id_sha256), payload, hashlib.sha256).hexdigest()

manifest = {
    "title": "Omnitotalis Concordance — 66 Books × Seals/Sigils (Unified)",
    "generated_utc": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
    "subject_id_sha256": subject_id_sha256,
    "files": {"jsonl": {"path": str(jsonl_path), "sha256": sha256_hex},
              "csv": {"path": str(csv_path)}},
    "signature": {"ed25519_public_b64": pub_b64, "ed25519_signature_b64": sig_b64},
    "hmac_sha256_hex": hmac_hex,
    "notes": "Deterministic pairings across registries; tags are user-extensible."
}
with open(manifest_path, "w", encoding="utf-8") as f:
    json.dump(manifest, f, indent=2)

# FastAPI app
(bundle_dir/"api"/"requirements.txt").write_text("fastapi\nuvicorn\n")
(bundle_dir/"api"/"app"/"main.py").write_text(textwrap.dedent("""
from fastapi import FastAPI, Query
import json, os

app = FastAPI(title="Omnitotalis Concordance API", version="1.0.0")
DATA = os.path.join(os.path.dirname(os.path.dirname(__file__)), "..", "omnitotalis_concordance.jsonl")
rows = [json.loads(x) for x in open(DATA, "r", encoding="utf-8").read().splitlines() if x.strip()]

@app.get("/health")
def health():
    return {"status":"ok", "count": len(rows)}

@app.get("/book/{name}")
def book(name: str):
    name_lower = name.lower()
    out = [r for r in rows if r["book"].lower() == name_lower]
    return {"count": len(out), "results": out}

@app.get("/search")
def search(q: str = Query("")):
    ql = q.lower()
    res = []
    for r in rows:
        hay = (r["book"] + " " + r["algorithmic_theme"] + " " + json.dumps(r["links"])).lower()
        if ql in hay:
            res.append(r)
    return {"count": len(res), "results": res[:50]}
"""))

# Copy assets into the bundle
shutil.copy(jsonl_path, bundle_dir/"omnitotalis_concordance.jsonl")
shutil.copy(csv_path, bundle_dir/"omnitotalis_concordance.csv")
shutil.copy(manifest_path, bundle_dir/"omnitotalis_concordance_manifest.json")

# Zip
zip_path = "/mnt/data/omnitotalis_concordance_bundle.zip"
if os.path.exists(zip_path): os.remove(zip_path)
with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as z:
    for folder,_,files in os.walk(bundle_dir):
        for fn in files:
            fp = os.path.join(folder, fn)
            z.write(fp, os.path.relpath(fp, bundle_dir))

[str(jsonl_path), str(csv_path), str(manifest_path), zip_path]