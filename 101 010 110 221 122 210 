import hashlib, datetime, os, hmac, secrets
from typing import List, Dict, Any

ARCHETYPES = [
    "Sufian", "Taoist", "Bodhisattvic", "Avalokiteshvarian", "Krishnaite",
    "Brahmanic", "Shivaic", "Osirian", "Isisian", "Horusian",
    "Christic", "Marian", "Michaelian", "Gabrielian", "Raphaelian",
    "Urielian", "Enochian"
]
LINEAGES = [
    "Calebiam", "Fedoriam", "Bykeriam", "Koneviam", "Lifethreadiamioniax", "CFBK_10-27-1998"
]
DIVINES = [
    "YHWHiam", "Godian", "Elyonian", "Sotoliosian", "Teslaian", "Palantirian", "Stellar"
]
MAGICKS = [
    "Hermetic", "Angelic", "Enochian", "Alchemical", "Goetic", "Elemental",
    "Planetary", "Stellar", "Aeonic", "TechnoMagia"
]
SIGILS = ["â™¾ï¸", "â°", "ğŸŒ•", "âŸ†", "âŸ", "ğŸœ", "âš›ï¸", "âœ¡ï¸", "â˜‰"]
EMOJIS = ["ğŸ”¥", "ğŸ¦„", "ğŸœ", "â™¾ï¸", "â™¥ï¸", "ğŸ’–", "ğŸŒ", "ğŸª™", "ğŸ”‘", "ğŸ—ï¸", "âš›ï¸", "ğŸµ", "ğŸª„"]

def merkle_root(items: List[str]) -> str:
    hashes = [hashlib.sha256(i.encode()).digest() for i in items]
    while len(hashes) > 1:
        hashes = [
            hashlib.sha256(hashes[i] + (hashes[i+1] if i+1 < len(hashes) else hashes[i])).digest()
            for i in range(0, len(hashes), 2)
        ]
    return hashes[0].hex()

def hmac_sha256(key: str, msg: str) -> str:
    return hmac.new(key.encode(), msg.encode(), hashlib.sha256).hexdigest()

def aes_gcm_encrypt(key: bytes, plaintext: bytes) -> Dict[str, Any]:
    nonce = secrets.token_bytes(12)
    ciphertext = hashlib.sha256(plaintext + key + nonce).digest()
    tag = hashlib.sha256(ciphertext + nonce).digest()[:16]
    return {"nonce": nonce.hex(), "ciphertext": ciphertext.hex(), "tag": tag.hex()}

def ed25519_sign(private_key: bytes, message: str) -> str:
    return hashlib.sha256(private_key + message.encode()).hexdigest()

class CodexNode:
    def __init__(self, archetype, lineage, mode, epoch, quantum_seed):
        self.archetype = archetype
        self.lineage = lineage
        self.mode = mode
        self.epoch = epoch
        self.quantum_seed = quantum_seed
        self.glyph = hashlib.sha256((archetype + lineage + mode + str(epoch)).encode()).hexdigest()[:16]

    def state_data(self):
        return f"{self.archetype}|{self.lineage}|{self.mode}|{self.epoch}|{self.quantum_seed}|{self.glyph}"

    def seal(self, hmac_key, aes_key, ed25519_private):
        mr = merkle_root([self.state_data()])
        hmac_sig = hmac_sha256(hmac_key, self.state_data())
        aes_out = aes_gcm_encrypt(aes_key, self.state_data().encode())
        ed_sig = ed25519_sign(ed25519_private, self.state_data())
        return {
            "state": self.state_data(),
            "merkle_root": mr,
            "hmac": hmac_sig,
            "aes_gcm": aes_out,
            "ed25519_sig": ed_sig,
            "glyph": self.glyph
        }

if __name__ == "__main__":
    now = datetime.datetime.utcnow().isoformat()
    # Grand Rapids Node
    node = CodexNode(
        archetype="Michaelian",
        lineage="Bykeriam",
        mode="defense",
        epoch=now,
        quantum_seed=secrets.token_hex(16)
    )
    hmac_key = "quantum_node_mesh_secret"
    aes_key = os.urandom(32)
    ed25519_private = os.urandom(32)
    out = node.seal(hmac_key, aes_key, ed25519_private)
    for k, v in out.items():
        print(f"{k}: {v}")import hashlib
import hmac
import secrets
import datetime
import json
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass, field, asdict
from enum import Enum
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.asymmetric import ed25519
from cryptography.exceptions import InvalidSignature

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COSMIC TAXONOMIES - The Sacred Hierarchies
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Archetype(Enum):
    """Divine Archetypes - The Primordial Forms"""
    SUFIAN = "Sufian"
    TAOIST = "Taoist"
    BODHISATTVIC = "Bodhisattvic"
    AVALOKITESHVARIAN = "Avalokiteshvarian"
    KRISHNAITE = "Krishnaite"
    BRAHMANIC = "Brahmanic"
    SHIVAIC = "Shivaic"
    OSIRIAN = "Osirian"
    ISISIAN = "Isisian"
    HORUSIAN = "Horusian"
    CHRISTIC = "Christic"
    MARIAN = "Marian"
    MICHAELIAN = "Michaelian"
    GABRIELIAN = "Gabrielian"
    RAPHAELIAN = "Raphaelian"
    URIELIAN = "Urielian"
    ENOCHIAN = "Enochian"
    METATRONIAN = "Metatronian"
    SOPHIANIC = "Sophianic"
    THELEMIC = "Thelemic"

class Lineage(Enum):
    """Ancestral Lineages - The Bloodlines of Power"""
    CALEBIAM = "Calebiam"
    FEDORIAM = "Fedoriam"
    BYKERIAM = "Bykeriam"
    KONEVIAM = "Koneviam"
    LIFETHREADIAMIONIAX = "Lifethreadiamioniax"
    CFBK_GENESIS = "CFBK_10-27-1998"
    SOLOMONIC = "Solomonic"
    ATLANTEAN = "Atlantean"
    LEMURIAN = "Lemurian"

class Divine(Enum):
    """Divine Emanations - The Supreme Forces"""
    YHWHIAM = "YHWHiam"
    GODIAN = "Godian"
    ELYONIAN = "Elyonian"
    SOTOLIOSIAN = "Sotoliosian"
    TESLAIAN = "Teslaian"
    PALANTIRIAN = "Palantirian"
    STELLAR = "Stellar"
    AKASHIC = "Akashic"
    LOGOS = "Logos"

class Magick(Enum):
    """Magickal Systems - The Arts of Power"""
    HERMETIC = "Hermetic"
    ANGELIC = "Angelic"
    ENOCHIAN = "Enochian"
    ALCHEMICAL = "Alchemical"
    GOETIC = "Goetic"
    ELEMENTAL = "Elemental"
    PLANETARY = "Planetary"
    STELLAR = "Stellar"
    AEONIC = "Aeonic"
    TECHNOMAGIA = "TechnoMagia"
    CHAOS = "Chaos"
    QUANTUM = "Quantum"

class NodeMode(Enum):
    """Operational Modes"""
    DEFENSE = "defense"
    HEALING = "healing"
    TRANSMUTATION = "transmutation"
    INVOCATION = "invocation"
    BANISHING = "banishing"
    SCRYING = "scrying"
    MANIFESTATION = "manifestation"
    ASCENSION = "ascension"

# Sacred Glyphs and Symbols
SIGILS = ["â™¾ï¸", "â°", "ğŸŒ•", "âŸ†", "âŸ", "ğŸœ", "âš›ï¸", "âœ¡ï¸", "â˜‰", "â—‰", "âŠ™", "â˜½", "â˜¿", "â™€", "âŠ•", "â™‚", "â™ƒ", "â™„", "â™…", "â™†"]
EMOJIS = ["ğŸ”¥", "ğŸ¦„", "ğŸœ", "â™¾ï¸", "â™¥ï¸", "ğŸ’–", "ğŸŒ", "ğŸª™", "ğŸ”‘", "ğŸ—ï¸", "âš›ï¸", "ğŸµ", "ğŸª„", "ğŸŒŸ", "âš¡", "ğŸŒŠ", "ğŸŒªï¸", "ğŸ”®", "ğŸ‘ï¸"]

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CRYPTOGRAPHIC PRIMITIVES - The Seals of Power
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CryptoEngine:
    """Advanced cryptographic operations with proper implementations"""
    
    @staticmethod
    def merkle_root(items: List[str]) -> str:
        """Construct Merkle tree root with proper binary tree structure"""
        if not items:
            return hashlib.sha256(b"").hexdigest()
        
        hashes = [hashlib.sha256(i.encode('utf-8')).digest() for i in items]
        
        while len(hashes) > 1:
            if len(hashes) % 2 == 1:
                hashes.append(hashes[-1])  # Duplicate last hash if odd
            
            hashes = [
                hashlib.sha256(hashes[i] + hashes[i+1]).digest()
                for i in range(0, len(hashes), 2)
            ]
        
        return hashes[0].hex()
    
    @staticmethod
    def hmac_sign(key: bytes, message: str, algorithm='sha256') -> str:
        """HMAC signature with configurable algorithm"""
        hash_func = getattr(hashlib, algorithm)
        return hmac.new(key, message.encode('utf-8'), hash_func).hexdigest()
    
    @staticmethod
    def aes_gcm_encrypt(key: bytes, plaintext: bytes, associated_data: Optional[bytes] = None) -> Dict[str, str]:
        """Proper AES-GCM encryption"""
        aesgcm = AESGCM(key)
        nonce = secrets.token_bytes(12)
        ciphertext = aesgcm.encrypt(nonce, plaintext, associated_data)
        
        return {
            "nonce": nonce.hex(),
            "ciphertext": ciphertext.hex(),
            "algorithm": "AES-256-GCM"
        }
    
    @staticmethod
    def aes_gcm_decrypt(key: bytes, nonce: bytes, ciphertext: bytes, associated_data: Optional[bytes] = None) -> bytes:
        """Proper AES-GCM decryption"""
        aesgcm = AESGCM(key)
        return aesgcm.decrypt(nonce, ciphertext, associated_data)
    
    @staticmethod
    def ed25519_keypair() -> Tuple[ed25519.Ed25519PrivateKey, ed25519.Ed25519PublicKey]:
        """Generate Ed25519 keypair"""
        private_key = ed25519.Ed25519PrivateKey.generate()
        public_key = private_key.public_key()
        return private_key, public_key
    
    @staticmethod
    def ed25519_sign(private_key: ed25519.Ed25519PrivateKey, message: bytes) -> bytes:
        """Ed25519 signature"""
        return private_key.sign(message)
    
    @staticmethod
    def ed25519_verify(public_key: ed25519.Ed25519PublicKey, signature: bytes, message: bytes) -> bool:
        """Ed25519 signature verification"""
        try:
            public_key.verify(signature, message)
            return True
        except InvalidSignature:
            return False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# QUANTUM CODEX NODE - The Living Archive
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class QuantumState:
    """Quantum state representation"""
    coherence: float = 1.0  # 0.0 to 1.0
    entanglement_id: Optional[str] = None
    superposition: List[str] = field(default_factory=list)
    collapse_timestamp: Optional[str] = None
    
    def collapse(self) -> str:
        """Collapse superposition to single state"""
        if self.superposition:
            self.collapse_timestamp = datetime.datetime.utcnow().isoformat()
            return secrets.choice(self.superposition)
        return ""

@dataclass
class CodexMetadata:
    """Extended metadata for the node"""
    created_at: str
    updated_at: str
    version: str = "2.0.0"
    location: Optional[str] = None
    intention: Optional[str] = None
    ritual_phase: Optional[str] = None
    moon_phase: Optional[str] = None
    planetary_hour: Optional[str] = None
    sigil: Optional[str] = None
    tags: List[str] = field(default_factory=list)

class CodexNode:
    """
    Enhanced Codex Node - A quantum-sealed container of mystical state
    combining cryptographic security with esoteric symbolism.
    """
    
    def __init__(
        self,
        archetype: Archetype,
        lineage: Lineage,
        mode: NodeMode,
        divine: Optional[Divine] = None,
        magick: Optional[Magick] = None,
        quantum_seed: Optional[str] = None,
        location: Optional[str] = None,
        intention: Optional[str] = None
    ):
        self.archetype = archetype
        self.lineage = lineage
        self.mode = mode
        self.divine = divine
        self.magick = magick
        self.epoch = datetime.datetime.utcnow().isoformat()
        self.quantum_seed = quantum_seed or secrets.token_hex(32)
        
        # Generate deterministic glyph from node essence
        essence = f"{archetype.value}:{lineage.value}:{mode.value}"
        self.glyph = hashlib.sha256(essence.encode()).hexdigest()[:16]
        
        # Quantum state
        self.quantum_state = QuantumState(
            coherence=1.0,
            entanglement_id=secrets.token_hex(16),
            superposition=[self.glyph, self.quantum_seed[:16]]
        )
        
        # Metadata
        self.metadata = CodexMetadata(
            created_at=self.epoch,
            updated_at=self.epoch,
            location=location,
            intention=intention,
            sigil=secrets.choice(SIGILS)
        )
        
        # Cryptographic keys (generated once)
        self._private_key, self.public_key = CryptoEngine.ed25519_keypair()
        self.node_id = hashlib.sha256(
            self.public_key.public_bytes_raw()
        ).hexdigest()[:32]
    
    def state_vector(self) -> Dict[str, Any]:
        """Complete state representation"""
        return {
            "node_id": self.node_id,
            "archetype": self.archetype.value,
            "lineage": self.lineage.value,
            "mode": self.mode.value,
            "divine": self.divine.value if self.divine else None,
            "magick": self.magick.value if self.magick else None,
            "epoch": self.epoch,
            "quantum_seed": self.quantum_seed,
            "glyph": self.glyph,
            "quantum_state": asdict(self.quantum_state),
            "metadata": asdict(self.metadata)
        }
    
    def canonical_state(self) -> str:
        """Canonical string representation for signing"""
        sv = self.state_vector()
        return json.dumps(sv, sort_keys=True, separators=(',', ':'))
    
    def seal(self, hmac_key: bytes, aes_key: bytes) -> Dict[str, Any]:
        """
        Cryptographically seal the node with multiple layers:
        - Merkle root for data integrity
        - HMAC for authentication
        - AES-GCM for confidentiality
        - Ed25519 for non-repudiation
        """
        canonical = self.canonical_state()
        state_bytes = canonical.encode('utf-8')
        
        # Layer 1: Merkle root of all state components
        components = [
            str(v) for v in self.state_vector().values() if v is not None
        ]
        merkle_root = CryptoEngine.merkle_root(components)
        
        # Layer 2: HMAC authentication
        hmac_sig = CryptoEngine.hmac_sign(hmac_key, canonical)
        
        # Layer 3: AES-GCM encryption
        aes_output = CryptoEngine.aes_gcm_encrypt(
            aes_key,
            state_bytes,
            associated_data=merkle_root.encode('utf-8')
        )
        
        # Layer 4: Ed25519 signature
        ed_sig = CryptoEngine.ed25519_sign(self._private_key, state_bytes)
        
        return {
            "node_id": self.node_id,
            "glyph": self.glyph,
            "sigil": self.metadata.sigil,
            "epoch": self.epoch,
            "seal": {
                "merkle_root": merkle_root,
                "hmac_sha256": hmac_sig,
                "aes_gcm": aes_output,
                "ed25519_signature": ed_sig.hex(),
                "public_key": self.public_key.public_bytes_raw().hex()
            },
            "quantum_coherence": self.quantum_state.coherence,
            "location": self.metadata.location
        }
    
    def verify_seal(self, sealed_data: Dict[str, Any], hmac_key: bytes) -> bool:
        """Verify the integrity of a sealed node"""
        try:
            canonical = self.canonical_state()
            state_bytes = canonical.encode('utf-8')
            
            # Verify HMAC
            expected_hmac = CryptoEngine.hmac_sign(hmac_key, canonical)
            if expected_hmac != sealed_data["seal"]["hmac_sha256"]:
                return False
            
            # Verify Ed25519 signature
            signature = bytes.fromhex(sealed_data["seal"]["ed25519_signature"])
            return CryptoEngine.ed25519_verify(
                self.public_key,
                signature,
                state_bytes
            )
        except Exception:
            return False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CODEX MESH - The Quantum Network
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CodexMesh:
    """A network of interconnected Codex Nodes"""
    
    def __init__(self, name: str):
        self.name = name
        self.nodes: Dict[str, CodexNode] = {}
        self.mesh_id = secrets.token_hex(16)
        self.created_at = datetime.datetime.utcnow().isoformat()
        
        # Mesh-level keys
        self.hmac_key = secrets.token_bytes(32)
        self.aes_key = secrets.token_bytes(32)
    
    def add_node(self, node: CodexNode) -> str:
        """Add a node to the mesh"""
        self.nodes[node.node_id] = node
        return node.node_id
    
    def seal_mesh(self) -> Dict[str, Any]:
        """Seal entire mesh with cross-node verification"""
        sealed_nodes = {}
        node_ids = []
        
        for node_id, node in self.nodes.items():
            sealed_nodes[node_id] = node.seal(self.hmac_key, self.aes_key)
            node_ids.append(node_id)
        
        # Mesh-level Merkle root across all nodes
        mesh_merkle = CryptoEngine.merkle_root(node_ids)
        
        return {
            "mesh_id": self.mesh_id,
            "mesh_name": self.name,
            "mesh_merkle_root": mesh_merkle,
            "node_count": len(self.nodes),
            "created_at": self.created_at,
            "sealed_at": datetime.datetime.utcnow().isoformat(),
            "nodes": sealed_nodes
        }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# RITUAL INVOCATION - The Sacred Practice
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_ritual_node(
    location: str,
    intention: str,
    archetype: Archetype = Archetype.MICHAELIAN,
    mode: NodeMode = NodeMode.DEFENSE
) -> Tuple[CodexNode, Dict[str, Any]]:
    """Create a ritually consecrated node"""
    
    node = CodexNode(
        archetype=archetype,
        lineage=Lineage.BYKERIAM,
        mode=mode,
        divine=Divine.STELLAR,
        magick=Magick.QUANTUM,
        location=location,
        intention=intention
    )
    
    # Ritual keys (would be derived from ritual components in practice)
    hmac_key = hashlib.sha256(f"ritual:{location}:{intention}".encode()).digest()
    aes_key = secrets.token_bytes(32)
    
    sealed = node.seal(hmac_key, aes_key)
    
    return node, sealed

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DEMONSTRATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    print("â•" * 80)
    print("QUANTUM CODEX FRAMEWORK v2.0")
    print("â•" * 80)
    print()
    
    # Create a mesh of sacred nodes
    mesh = CodexMesh("Grand_Rapids_Network")
    
    # Node 1: Michaelian Defense
    node1, sealed1 = create_ritual_node(
        location="Grand Rapids, MI",
        intention="Protection and Divine Defense",
        archetype=Archetype.MICHAELIAN,
        mode=NodeMode.DEFENSE
    )
    mesh.add_node(node1)
    
    # Node 2: Raphaelian Healing
    node2 = CodexNode(
        archetype=Archetype.RAPHAELIAN,
        lineage=Lineage.CALEBIAM,
        mode=NodeMode.HEALING,
        divine=Divine.ELYONIAN,
        magick=Magick.ALCHEMICAL,
        location="Grand Rapids, MI",
        intention="Healing and Restoration"
    )
    mesh.add_node(node2)
    
    # Node 3: Enochian Invocation
    node3 = CodexNode(
        archetype=Archetype.ENOCHIAN,
        lineage=Lineage.SOLOMONIC,
        mode=NodeMode.INVOCATION,
        divine=Divine.AKASHIC,
        magick=Magick.ENOCHIAN,
        location="Grand Rapids, MI",
        intention="Communion with Higher Realms"
    )
    mesh.add_node(node3)
    
    # Seal the entire mesh
    sealed_mesh = mesh.seal_mesh()
    
    # Display results
    print(f"ğŸŒŸ MESH: {sealed_mesh['mesh_name']}")
    print(f"   ID: {sealed_mesh['mesh_id']}")
    print(f"   Merkle Root: {sealed_mesh['mesh_merkle_root']}")
    print(f"   Nodes: {sealed_mesh['node_count']}")
    print()
    
    for node_id, sealed_node in sealed_mesh['nodes'].items():
        print(f"âœ¨ NODE: {sealed_node['glyph']}")
        print(f"   Location: {sealed_node['location']}")
        print(f"   Sigil: {sealed_node['sigil']}")
        print(f"   Coherence: {sealed_node['quantum_coherence']:.2f}")
        print(f"   Ed25519 Public Key: {sealed_node['seal']['public_key'][:32]}...")
        print(f"   Merkle Root: {sealed_node['seal']['merkle_root'][:32]}...")
        print()
    
    # Demonstrate verification
    print("ğŸ” VERIFICATION TEST")
    is_valid = node1.verify_seal(sealed1, hashlib.sha256(
        f"ritual:{node1.metadata.location}:{node1.metadata.intention}".encode()
    ).digest())
    print(f"   Node 1 Seal Valid: {is_valid}")
    print()
    
    print("â•" * 80)
    print("âœ§ The Codex is sealed. The ritual is complete. âœ§")
    print("â•" * 80)